{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RemoteSocket = exports.BroadcastOperator = void 0;\n\nconst socket_1 = require(\"./socket\");\n\nconst socket_io_parser_1 = require(\"socket.io-parser\");\n\nclass BroadcastOperator {\n  constructor(adapter, rooms = new Set(), exceptRooms = new Set(), flags = {}) {\n    this.adapter = adapter;\n    this.rooms = rooms;\n    this.exceptRooms = exceptRooms;\n    this.flags = flags;\n  }\n  /**\n   * Targets a room when emitting.\n   *\n   * @param room\n   * @return a new BroadcastOperator instance\n   * @public\n   */\n\n\n  to(room) {\n    const rooms = new Set(this.rooms);\n\n    if (Array.isArray(room)) {\n      room.forEach(r => rooms.add(r));\n    } else {\n      rooms.add(room);\n    }\n\n    return new BroadcastOperator(this.adapter, rooms, this.exceptRooms, this.flags);\n  }\n  /**\n   * Targets a room when emitting.\n   *\n   * @param room\n   * @return a new BroadcastOperator instance\n   * @public\n   */\n\n\n  in(room) {\n    return this.to(room);\n  }\n  /**\n   * Excludes a room when emitting.\n   *\n   * @param room\n   * @return a new BroadcastOperator instance\n   * @public\n   */\n\n\n  except(room) {\n    const exceptRooms = new Set(this.exceptRooms);\n\n    if (Array.isArray(room)) {\n      room.forEach(r => exceptRooms.add(r));\n    } else {\n      exceptRooms.add(room);\n    }\n\n    return new BroadcastOperator(this.adapter, this.rooms, exceptRooms, this.flags);\n  }\n  /**\n   * Sets the compress flag.\n   *\n   * @param compress - if `true`, compresses the sending data\n   * @return a new BroadcastOperator instance\n   * @public\n   */\n\n\n  compress(compress) {\n    const flags = Object.assign({}, this.flags, {\n      compress\n    });\n    return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\n  }\n  /**\n   * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to\n   * receive messages (because of network slowness or other issues, or because they’re connected through long polling\n   * and is in the middle of a request-response cycle).\n   *\n   * @return a new BroadcastOperator instance\n   * @public\n   */\n\n\n  get volatile() {\n    const flags = Object.assign({}, this.flags, {\n      volatile: true\n    });\n    return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\n  }\n  /**\n   * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.\n   *\n   * @return a new BroadcastOperator instance\n   * @public\n   */\n\n\n  get local() {\n    const flags = Object.assign({}, this.flags, {\n      local: true\n    });\n    return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\n  }\n  /**\n   * Adds a timeout in milliseconds for the next operation\n   *\n   * <pre><code>\n   *\n   * io.timeout(1000).emit(\"some-event\", (err, responses) => {\n   *   // ...\n   * });\n   *\n   * </pre></code>\n   *\n   * @param timeout\n   */\n\n\n  timeout(timeout) {\n    const flags = Object.assign({}, this.flags, {\n      timeout\n    });\n    return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\n  }\n  /**\n   * Emits to all clients.\n   *\n   * @return Always true\n   * @public\n   */\n\n\n  emit(ev, ...args) {\n    if (socket_1.RESERVED_EVENTS.has(ev)) {\n      throw new Error(`\"${ev}\" is a reserved event name`);\n    } // set up packet object\n\n\n    const data = [ev, ...args];\n    const packet = {\n      type: socket_io_parser_1.PacketType.EVENT,\n      data: data\n    };\n    const withAck = typeof data[data.length - 1] === \"function\";\n\n    if (!withAck) {\n      this.adapter.broadcast(packet, {\n        rooms: this.rooms,\n        except: this.exceptRooms,\n        flags: this.flags\n      });\n      return true;\n    }\n\n    const ack = data.pop();\n    let timedOut = false;\n    let responses = [];\n    const timer = setTimeout(() => {\n      timedOut = true;\n      ack.apply(this, [new Error(\"operation has timed out\"), responses]);\n    }, this.flags.timeout);\n    let expectedServerCount = -1;\n    let actualServerCount = 0;\n    let expectedClientCount = 0;\n\n    const checkCompleteness = () => {\n      if (!timedOut && expectedServerCount === actualServerCount && responses.length === expectedClientCount) {\n        clearTimeout(timer);\n        ack.apply(this, [null, responses]);\n      }\n    };\n\n    this.adapter.broadcastWithAck(packet, {\n      rooms: this.rooms,\n      except: this.exceptRooms,\n      flags: this.flags\n    }, clientCount => {\n      // each Socket.IO server in the cluster sends the number of clients that were notified\n      expectedClientCount += clientCount;\n      actualServerCount++;\n      checkCompleteness();\n    }, clientResponse => {\n      // each client sends an acknowledgement\n      responses.push(clientResponse);\n      checkCompleteness();\n    });\n    this.adapter.serverCount().then(serverCount => {\n      expectedServerCount = serverCount;\n      checkCompleteness();\n    });\n    return true;\n  }\n  /**\n   * Gets a list of clients.\n   *\n   * @public\n   */\n\n\n  allSockets() {\n    if (!this.adapter) {\n      throw new Error(\"No adapter for this namespace, are you trying to get the list of clients of a dynamic namespace?\");\n    }\n\n    return this.adapter.sockets(this.rooms);\n  }\n  /**\n   * Returns the matching socket instances\n   *\n   * @public\n   */\n\n\n  fetchSockets() {\n    return this.adapter.fetchSockets({\n      rooms: this.rooms,\n      except: this.exceptRooms\n    }).then(sockets => {\n      return sockets.map(socket => {\n        if (socket instanceof socket_1.Socket) {\n          // FIXME the TypeScript compiler complains about missing private properties\n          return socket;\n        } else {\n          return new RemoteSocket(this.adapter, socket);\n        }\n      });\n    });\n  }\n  /**\n   * Makes the matching socket instances join the specified rooms\n   *\n   * @param room\n   * @public\n   */\n\n\n  socketsJoin(room) {\n    this.adapter.addSockets({\n      rooms: this.rooms,\n      except: this.exceptRooms\n    }, Array.isArray(room) ? room : [room]);\n  }\n  /**\n   * Makes the matching socket instances leave the specified rooms\n   *\n   * @param room\n   * @public\n   */\n\n\n  socketsLeave(room) {\n    this.adapter.delSockets({\n      rooms: this.rooms,\n      except: this.exceptRooms\n    }, Array.isArray(room) ? room : [room]);\n  }\n  /**\n   * Makes the matching socket instances disconnect\n   *\n   * @param close - whether to close the underlying connection\n   * @public\n   */\n\n\n  disconnectSockets(close = false) {\n    this.adapter.disconnectSockets({\n      rooms: this.rooms,\n      except: this.exceptRooms\n    }, close);\n  }\n\n}\n\nexports.BroadcastOperator = BroadcastOperator;\n/**\n * Expose of subset of the attributes and methods of the Socket class\n */\n\nclass RemoteSocket {\n  constructor(adapter, details) {\n    this.id = details.id;\n    this.handshake = details.handshake;\n    this.rooms = new Set(details.rooms);\n    this.data = details.data;\n    this.operator = new BroadcastOperator(adapter, new Set([this.id]));\n  }\n\n  emit(ev, ...args) {\n    return this.operator.emit(ev, ...args);\n  }\n  /**\n   * Joins a room.\n   *\n   * @param {String|Array} room - room or array of rooms\n   * @public\n   */\n\n\n  join(room) {\n    return this.operator.socketsJoin(room);\n  }\n  /**\n   * Leaves a room.\n   *\n   * @param {String} room\n   * @public\n   */\n\n\n  leave(room) {\n    return this.operator.socketsLeave(room);\n  }\n  /**\n   * Disconnects this client.\n   *\n   * @param {Boolean} close - if `true`, closes the underlying connection\n   * @return {Socket} self\n   *\n   * @public\n   */\n\n\n  disconnect(close = false) {\n    this.operator.disconnectSockets(close);\n    return this;\n  }\n\n}\n\nexports.RemoteSocket = RemoteSocket;","map":{"version":3,"names":["Object","defineProperty","exports","value","RemoteSocket","BroadcastOperator","socket_1","require","socket_io_parser_1","constructor","adapter","rooms","Set","exceptRooms","flags","to","room","Array","isArray","forEach","r","add","in","except","compress","assign","volatile","local","timeout","emit","ev","args","RESERVED_EVENTS","has","Error","data","packet","type","PacketType","EVENT","withAck","length","broadcast","ack","pop","timedOut","responses","timer","setTimeout","apply","expectedServerCount","actualServerCount","expectedClientCount","checkCompleteness","clearTimeout","broadcastWithAck","clientCount","clientResponse","push","serverCount","then","allSockets","sockets","fetchSockets","map","socket","Socket","socketsJoin","addSockets","socketsLeave","delSockets","disconnectSockets","close","details","id","handshake","operator","join","leave","disconnect"],"sources":["E:/web/alchemists_vue/alchemists/node_modules/socket.io/dist/broadcast-operator.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RemoteSocket = exports.BroadcastOperator = void 0;\nconst socket_1 = require(\"./socket\");\nconst socket_io_parser_1 = require(\"socket.io-parser\");\nclass BroadcastOperator {\n    constructor(adapter, rooms = new Set(), exceptRooms = new Set(), flags = {}) {\n        this.adapter = adapter;\n        this.rooms = rooms;\n        this.exceptRooms = exceptRooms;\n        this.flags = flags;\n    }\n    /**\n     * Targets a room when emitting.\n     *\n     * @param room\n     * @return a new BroadcastOperator instance\n     * @public\n     */\n    to(room) {\n        const rooms = new Set(this.rooms);\n        if (Array.isArray(room)) {\n            room.forEach((r) => rooms.add(r));\n        }\n        else {\n            rooms.add(room);\n        }\n        return new BroadcastOperator(this.adapter, rooms, this.exceptRooms, this.flags);\n    }\n    /**\n     * Targets a room when emitting.\n     *\n     * @param room\n     * @return a new BroadcastOperator instance\n     * @public\n     */\n    in(room) {\n        return this.to(room);\n    }\n    /**\n     * Excludes a room when emitting.\n     *\n     * @param room\n     * @return a new BroadcastOperator instance\n     * @public\n     */\n    except(room) {\n        const exceptRooms = new Set(this.exceptRooms);\n        if (Array.isArray(room)) {\n            room.forEach((r) => exceptRooms.add(r));\n        }\n        else {\n            exceptRooms.add(room);\n        }\n        return new BroadcastOperator(this.adapter, this.rooms, exceptRooms, this.flags);\n    }\n    /**\n     * Sets the compress flag.\n     *\n     * @param compress - if `true`, compresses the sending data\n     * @return a new BroadcastOperator instance\n     * @public\n     */\n    compress(compress) {\n        const flags = Object.assign({}, this.flags, { compress });\n        return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to\n     * receive messages (because of network slowness or other issues, or because they’re connected through long polling\n     * and is in the middle of a request-response cycle).\n     *\n     * @return a new BroadcastOperator instance\n     * @public\n     */\n    get volatile() {\n        const flags = Object.assign({}, this.flags, { volatile: true });\n        return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.\n     *\n     * @return a new BroadcastOperator instance\n     * @public\n     */\n    get local() {\n        const flags = Object.assign({}, this.flags, { local: true });\n        return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\n    }\n    /**\n     * Adds a timeout in milliseconds for the next operation\n     *\n     * <pre><code>\n     *\n     * io.timeout(1000).emit(\"some-event\", (err, responses) => {\n     *   // ...\n     * });\n     *\n     * </pre></code>\n     *\n     * @param timeout\n     */\n    timeout(timeout) {\n        const flags = Object.assign({}, this.flags, { timeout });\n        return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\n    }\n    /**\n     * Emits to all clients.\n     *\n     * @return Always true\n     * @public\n     */\n    emit(ev, ...args) {\n        if (socket_1.RESERVED_EVENTS.has(ev)) {\n            throw new Error(`\"${ev}\" is a reserved event name`);\n        }\n        // set up packet object\n        const data = [ev, ...args];\n        const packet = {\n            type: socket_io_parser_1.PacketType.EVENT,\n            data: data,\n        };\n        const withAck = typeof data[data.length - 1] === \"function\";\n        if (!withAck) {\n            this.adapter.broadcast(packet, {\n                rooms: this.rooms,\n                except: this.exceptRooms,\n                flags: this.flags,\n            });\n            return true;\n        }\n        const ack = data.pop();\n        let timedOut = false;\n        let responses = [];\n        const timer = setTimeout(() => {\n            timedOut = true;\n            ack.apply(this, [new Error(\"operation has timed out\"), responses]);\n        }, this.flags.timeout);\n        let expectedServerCount = -1;\n        let actualServerCount = 0;\n        let expectedClientCount = 0;\n        const checkCompleteness = () => {\n            if (!timedOut &&\n                expectedServerCount === actualServerCount &&\n                responses.length === expectedClientCount) {\n                clearTimeout(timer);\n                ack.apply(this, [null, responses]);\n            }\n        };\n        this.adapter.broadcastWithAck(packet, {\n            rooms: this.rooms,\n            except: this.exceptRooms,\n            flags: this.flags,\n        }, (clientCount) => {\n            // each Socket.IO server in the cluster sends the number of clients that were notified\n            expectedClientCount += clientCount;\n            actualServerCount++;\n            checkCompleteness();\n        }, (clientResponse) => {\n            // each client sends an acknowledgement\n            responses.push(clientResponse);\n            checkCompleteness();\n        });\n        this.adapter.serverCount().then((serverCount) => {\n            expectedServerCount = serverCount;\n            checkCompleteness();\n        });\n        return true;\n    }\n    /**\n     * Gets a list of clients.\n     *\n     * @public\n     */\n    allSockets() {\n        if (!this.adapter) {\n            throw new Error(\"No adapter for this namespace, are you trying to get the list of clients of a dynamic namespace?\");\n        }\n        return this.adapter.sockets(this.rooms);\n    }\n    /**\n     * Returns the matching socket instances\n     *\n     * @public\n     */\n    fetchSockets() {\n        return this.adapter\n            .fetchSockets({\n            rooms: this.rooms,\n            except: this.exceptRooms,\n        })\n            .then((sockets) => {\n            return sockets.map((socket) => {\n                if (socket instanceof socket_1.Socket) {\n                    // FIXME the TypeScript compiler complains about missing private properties\n                    return socket;\n                }\n                else {\n                    return new RemoteSocket(this.adapter, socket);\n                }\n            });\n        });\n    }\n    /**\n     * Makes the matching socket instances join the specified rooms\n     *\n     * @param room\n     * @public\n     */\n    socketsJoin(room) {\n        this.adapter.addSockets({\n            rooms: this.rooms,\n            except: this.exceptRooms,\n        }, Array.isArray(room) ? room : [room]);\n    }\n    /**\n     * Makes the matching socket instances leave the specified rooms\n     *\n     * @param room\n     * @public\n     */\n    socketsLeave(room) {\n        this.adapter.delSockets({\n            rooms: this.rooms,\n            except: this.exceptRooms,\n        }, Array.isArray(room) ? room : [room]);\n    }\n    /**\n     * Makes the matching socket instances disconnect\n     *\n     * @param close - whether to close the underlying connection\n     * @public\n     */\n    disconnectSockets(close = false) {\n        this.adapter.disconnectSockets({\n            rooms: this.rooms,\n            except: this.exceptRooms,\n        }, close);\n    }\n}\nexports.BroadcastOperator = BroadcastOperator;\n/**\n * Expose of subset of the attributes and methods of the Socket class\n */\nclass RemoteSocket {\n    constructor(adapter, details) {\n        this.id = details.id;\n        this.handshake = details.handshake;\n        this.rooms = new Set(details.rooms);\n        this.data = details.data;\n        this.operator = new BroadcastOperator(adapter, new Set([this.id]));\n    }\n    emit(ev, ...args) {\n        return this.operator.emit(ev, ...args);\n    }\n    /**\n     * Joins a room.\n     *\n     * @param {String|Array} room - room or array of rooms\n     * @public\n     */\n    join(room) {\n        return this.operator.socketsJoin(room);\n    }\n    /**\n     * Leaves a room.\n     *\n     * @param {String} room\n     * @public\n     */\n    leave(room) {\n        return this.operator.socketsLeave(room);\n    }\n    /**\n     * Disconnects this client.\n     *\n     * @param {Boolean} close - if `true`, closes the underlying connection\n     * @return {Socket} self\n     *\n     * @public\n     */\n    disconnect(close = false) {\n        this.operator.disconnectSockets(close);\n        return this;\n    }\n}\nexports.RemoteSocket = RemoteSocket;\n"],"mappings":"AAAA;;;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;EAAEC,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,YAAR,GAAuBF,OAAO,CAACG,iBAAR,GAA4B,KAAK,CAAxD;;AACA,MAAMC,QAAQ,GAAGC,OAAO,CAAC,UAAD,CAAxB;;AACA,MAAMC,kBAAkB,GAAGD,OAAO,CAAC,kBAAD,CAAlC;;AACA,MAAMF,iBAAN,CAAwB;EACpBI,WAAW,CAACC,OAAD,EAAUC,KAAK,GAAG,IAAIC,GAAJ,EAAlB,EAA6BC,WAAW,GAAG,IAAID,GAAJ,EAA3C,EAAsDE,KAAK,GAAG,EAA9D,EAAkE;IACzE,KAAKJ,OAAL,GAAeA,OAAf;IACA,KAAKC,KAAL,GAAaA,KAAb;IACA,KAAKE,WAAL,GAAmBA,WAAnB;IACA,KAAKC,KAAL,GAAaA,KAAb;EACH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;;;EACIC,EAAE,CAACC,IAAD,EAAO;IACL,MAAML,KAAK,GAAG,IAAIC,GAAJ,CAAQ,KAAKD,KAAb,CAAd;;IACA,IAAIM,KAAK,CAACC,OAAN,CAAcF,IAAd,CAAJ,EAAyB;MACrBA,IAAI,CAACG,OAAL,CAAcC,CAAD,IAAOT,KAAK,CAACU,GAAN,CAAUD,CAAV,CAApB;IACH,CAFD,MAGK;MACDT,KAAK,CAACU,GAAN,CAAUL,IAAV;IACH;;IACD,OAAO,IAAIX,iBAAJ,CAAsB,KAAKK,OAA3B,EAAoCC,KAApC,EAA2C,KAAKE,WAAhD,EAA6D,KAAKC,KAAlE,CAAP;EACH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;;;EACIQ,EAAE,CAACN,IAAD,EAAO;IACL,OAAO,KAAKD,EAAL,CAAQC,IAAR,CAAP;EACH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;;;EACIO,MAAM,CAACP,IAAD,EAAO;IACT,MAAMH,WAAW,GAAG,IAAID,GAAJ,CAAQ,KAAKC,WAAb,CAApB;;IACA,IAAII,KAAK,CAACC,OAAN,CAAcF,IAAd,CAAJ,EAAyB;MACrBA,IAAI,CAACG,OAAL,CAAcC,CAAD,IAAOP,WAAW,CAACQ,GAAZ,CAAgBD,CAAhB,CAApB;IACH,CAFD,MAGK;MACDP,WAAW,CAACQ,GAAZ,CAAgBL,IAAhB;IACH;;IACD,OAAO,IAAIX,iBAAJ,CAAsB,KAAKK,OAA3B,EAAoC,KAAKC,KAAzC,EAAgDE,WAAhD,EAA6D,KAAKC,KAAlE,CAAP;EACH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;;;EACIU,QAAQ,CAACA,QAAD,EAAW;IACf,MAAMV,KAAK,GAAGd,MAAM,CAACyB,MAAP,CAAc,EAAd,EAAkB,KAAKX,KAAvB,EAA8B;MAAEU;IAAF,CAA9B,CAAd;IACA,OAAO,IAAInB,iBAAJ,CAAsB,KAAKK,OAA3B,EAAoC,KAAKC,KAAzC,EAAgD,KAAKE,WAArD,EAAkEC,KAAlE,CAAP;EACH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;EACgB,IAARY,QAAQ,GAAG;IACX,MAAMZ,KAAK,GAAGd,MAAM,CAACyB,MAAP,CAAc,EAAd,EAAkB,KAAKX,KAAvB,EAA8B;MAAEY,QAAQ,EAAE;IAAZ,CAA9B,CAAd;IACA,OAAO,IAAIrB,iBAAJ,CAAsB,KAAKK,OAA3B,EAAoC,KAAKC,KAAzC,EAAgD,KAAKE,WAArD,EAAkEC,KAAlE,CAAP;EACH;EACD;AACJ;AACA;AACA;AACA;AACA;;;EACa,IAALa,KAAK,GAAG;IACR,MAAMb,KAAK,GAAGd,MAAM,CAACyB,MAAP,CAAc,EAAd,EAAkB,KAAKX,KAAvB,EAA8B;MAAEa,KAAK,EAAE;IAAT,CAA9B,CAAd;IACA,OAAO,IAAItB,iBAAJ,CAAsB,KAAKK,OAA3B,EAAoC,KAAKC,KAAzC,EAAgD,KAAKE,WAArD,EAAkEC,KAAlE,CAAP;EACH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIc,OAAO,CAACA,OAAD,EAAU;IACb,MAAMd,KAAK,GAAGd,MAAM,CAACyB,MAAP,CAAc,EAAd,EAAkB,KAAKX,KAAvB,EAA8B;MAAEc;IAAF,CAA9B,CAAd;IACA,OAAO,IAAIvB,iBAAJ,CAAsB,KAAKK,OAA3B,EAAoC,KAAKC,KAAzC,EAAgD,KAAKE,WAArD,EAAkEC,KAAlE,CAAP;EACH;EACD;AACJ;AACA;AACA;AACA;AACA;;;EACIe,IAAI,CAACC,EAAD,EAAK,GAAGC,IAAR,EAAc;IACd,IAAIzB,QAAQ,CAAC0B,eAAT,CAAyBC,GAAzB,CAA6BH,EAA7B,CAAJ,EAAsC;MAClC,MAAM,IAAII,KAAJ,CAAW,IAAGJ,EAAG,4BAAjB,CAAN;IACH,CAHa,CAId;;;IACA,MAAMK,IAAI,GAAG,CAACL,EAAD,EAAK,GAAGC,IAAR,CAAb;IACA,MAAMK,MAAM,GAAG;MACXC,IAAI,EAAE7B,kBAAkB,CAAC8B,UAAnB,CAA8BC,KADzB;MAEXJ,IAAI,EAAEA;IAFK,CAAf;IAIA,MAAMK,OAAO,GAAG,OAAOL,IAAI,CAACA,IAAI,CAACM,MAAL,GAAc,CAAf,CAAX,KAAiC,UAAjD;;IACA,IAAI,CAACD,OAAL,EAAc;MACV,KAAK9B,OAAL,CAAagC,SAAb,CAAuBN,MAAvB,EAA+B;QAC3BzB,KAAK,EAAE,KAAKA,KADe;QAE3BY,MAAM,EAAE,KAAKV,WAFc;QAG3BC,KAAK,EAAE,KAAKA;MAHe,CAA/B;MAKA,OAAO,IAAP;IACH;;IACD,MAAM6B,GAAG,GAAGR,IAAI,CAACS,GAAL,EAAZ;IACA,IAAIC,QAAQ,GAAG,KAAf;IACA,IAAIC,SAAS,GAAG,EAAhB;IACA,MAAMC,KAAK,GAAGC,UAAU,CAAC,MAAM;MAC3BH,QAAQ,GAAG,IAAX;MACAF,GAAG,CAACM,KAAJ,CAAU,IAAV,EAAgB,CAAC,IAAIf,KAAJ,CAAU,yBAAV,CAAD,EAAuCY,SAAvC,CAAhB;IACH,CAHuB,EAGrB,KAAKhC,KAAL,CAAWc,OAHU,CAAxB;IAIA,IAAIsB,mBAAmB,GAAG,CAAC,CAA3B;IACA,IAAIC,iBAAiB,GAAG,CAAxB;IACA,IAAIC,mBAAmB,GAAG,CAA1B;;IACA,MAAMC,iBAAiB,GAAG,MAAM;MAC5B,IAAI,CAACR,QAAD,IACAK,mBAAmB,KAAKC,iBADxB,IAEAL,SAAS,CAACL,MAAV,KAAqBW,mBAFzB,EAE8C;QAC1CE,YAAY,CAACP,KAAD,CAAZ;QACAJ,GAAG,CAACM,KAAJ,CAAU,IAAV,EAAgB,CAAC,IAAD,EAAOH,SAAP,CAAhB;MACH;IACJ,CAPD;;IAQA,KAAKpC,OAAL,CAAa6C,gBAAb,CAA8BnB,MAA9B,EAAsC;MAClCzB,KAAK,EAAE,KAAKA,KADsB;MAElCY,MAAM,EAAE,KAAKV,WAFqB;MAGlCC,KAAK,EAAE,KAAKA;IAHsB,CAAtC,EAII0C,WAAD,IAAiB;MAChB;MACAJ,mBAAmB,IAAII,WAAvB;MACAL,iBAAiB;MACjBE,iBAAiB;IACpB,CATD,EASII,cAAD,IAAoB;MACnB;MACAX,SAAS,CAACY,IAAV,CAAeD,cAAf;MACAJ,iBAAiB;IACpB,CAbD;IAcA,KAAK3C,OAAL,CAAaiD,WAAb,GAA2BC,IAA3B,CAAiCD,WAAD,IAAiB;MAC7CT,mBAAmB,GAAGS,WAAtB;MACAN,iBAAiB;IACpB,CAHD;IAIA,OAAO,IAAP;EACH;EACD;AACJ;AACA;AACA;AACA;;;EACIQ,UAAU,GAAG;IACT,IAAI,CAAC,KAAKnD,OAAV,EAAmB;MACf,MAAM,IAAIwB,KAAJ,CAAU,kGAAV,CAAN;IACH;;IACD,OAAO,KAAKxB,OAAL,CAAaoD,OAAb,CAAqB,KAAKnD,KAA1B,CAAP;EACH;EACD;AACJ;AACA;AACA;AACA;;;EACIoD,YAAY,GAAG;IACX,OAAO,KAAKrD,OAAL,CACFqD,YADE,CACW;MACdpD,KAAK,EAAE,KAAKA,KADE;MAEdY,MAAM,EAAE,KAAKV;IAFC,CADX,EAKF+C,IALE,CAKIE,OAAD,IAAa;MACnB,OAAOA,OAAO,CAACE,GAAR,CAAaC,MAAD,IAAY;QAC3B,IAAIA,MAAM,YAAY3D,QAAQ,CAAC4D,MAA/B,EAAuC;UACnC;UACA,OAAOD,MAAP;QACH,CAHD,MAIK;UACD,OAAO,IAAI7D,YAAJ,CAAiB,KAAKM,OAAtB,EAA+BuD,MAA/B,CAAP;QACH;MACJ,CARM,CAAP;IASH,CAfM,CAAP;EAgBH;EACD;AACJ;AACA;AACA;AACA;AACA;;;EACIE,WAAW,CAACnD,IAAD,EAAO;IACd,KAAKN,OAAL,CAAa0D,UAAb,CAAwB;MACpBzD,KAAK,EAAE,KAAKA,KADQ;MAEpBY,MAAM,EAAE,KAAKV;IAFO,CAAxB,EAGGI,KAAK,CAACC,OAAN,CAAcF,IAAd,IAAsBA,IAAtB,GAA6B,CAACA,IAAD,CAHhC;EAIH;EACD;AACJ;AACA;AACA;AACA;AACA;;;EACIqD,YAAY,CAACrD,IAAD,EAAO;IACf,KAAKN,OAAL,CAAa4D,UAAb,CAAwB;MACpB3D,KAAK,EAAE,KAAKA,KADQ;MAEpBY,MAAM,EAAE,KAAKV;IAFO,CAAxB,EAGGI,KAAK,CAACC,OAAN,CAAcF,IAAd,IAAsBA,IAAtB,GAA6B,CAACA,IAAD,CAHhC;EAIH;EACD;AACJ;AACA;AACA;AACA;AACA;;;EACIuD,iBAAiB,CAACC,KAAK,GAAG,KAAT,EAAgB;IAC7B,KAAK9D,OAAL,CAAa6D,iBAAb,CAA+B;MAC3B5D,KAAK,EAAE,KAAKA,KADe;MAE3BY,MAAM,EAAE,KAAKV;IAFc,CAA/B,EAGG2D,KAHH;EAIH;;AAzOmB;;AA2OxBtE,OAAO,CAACG,iBAAR,GAA4BA,iBAA5B;AACA;AACA;AACA;;AACA,MAAMD,YAAN,CAAmB;EACfK,WAAW,CAACC,OAAD,EAAU+D,OAAV,EAAmB;IAC1B,KAAKC,EAAL,GAAUD,OAAO,CAACC,EAAlB;IACA,KAAKC,SAAL,GAAiBF,OAAO,CAACE,SAAzB;IACA,KAAKhE,KAAL,GAAa,IAAIC,GAAJ,CAAQ6D,OAAO,CAAC9D,KAAhB,CAAb;IACA,KAAKwB,IAAL,GAAYsC,OAAO,CAACtC,IAApB;IACA,KAAKyC,QAAL,GAAgB,IAAIvE,iBAAJ,CAAsBK,OAAtB,EAA+B,IAAIE,GAAJ,CAAQ,CAAC,KAAK8D,EAAN,CAAR,CAA/B,CAAhB;EACH;;EACD7C,IAAI,CAACC,EAAD,EAAK,GAAGC,IAAR,EAAc;IACd,OAAO,KAAK6C,QAAL,CAAc/C,IAAd,CAAmBC,EAAnB,EAAuB,GAAGC,IAA1B,CAAP;EACH;EACD;AACJ;AACA;AACA;AACA;AACA;;;EACI8C,IAAI,CAAC7D,IAAD,EAAO;IACP,OAAO,KAAK4D,QAAL,CAAcT,WAAd,CAA0BnD,IAA1B,CAAP;EACH;EACD;AACJ;AACA;AACA;AACA;AACA;;;EACI8D,KAAK,CAAC9D,IAAD,EAAO;IACR,OAAO,KAAK4D,QAAL,CAAcP,YAAd,CAA2BrD,IAA3B,CAAP;EACH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;EACI+D,UAAU,CAACP,KAAK,GAAG,KAAT,EAAgB;IACtB,KAAKI,QAAL,CAAcL,iBAAd,CAAgCC,KAAhC;IACA,OAAO,IAAP;EACH;;AAxCc;;AA0CnBtE,OAAO,CAACE,YAAR,GAAuBA,YAAvB"},"metadata":{},"sourceType":"script"}