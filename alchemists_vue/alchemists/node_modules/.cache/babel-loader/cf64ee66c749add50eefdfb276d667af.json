{"ast":null,"code":"import \"core-js/modules/es.array.includes.js\";\n\nconst calculateRetryDelay = ({\n  attemptCount,\n  retryOptions,\n  error,\n  retryAfter,\n  computedValue\n}) => {\n  if (error.name === 'RetryError') {\n    return 1;\n  }\n\n  if (attemptCount > retryOptions.limit) {\n    return 0;\n  }\n\n  const hasMethod = retryOptions.methods.includes(error.options.method);\n  const hasErrorCode = retryOptions.errorCodes.includes(error.code);\n  const hasStatusCode = error.response && retryOptions.statusCodes.includes(error.response.statusCode);\n\n  if (!hasMethod || !hasErrorCode && !hasStatusCode) {\n    return 0;\n  }\n\n  if (error.response) {\n    if (retryAfter) {\n      // In this case `computedValue` is `options.request.timeout`\n      if (retryAfter > computedValue) {\n        return 0;\n      }\n\n      return retryAfter;\n    }\n\n    if (error.response.statusCode === 413) {\n      return 0;\n    }\n  }\n\n  const noise = Math.random() * retryOptions.noise;\n  return Math.min(2 ** (attemptCount - 1) * 1000, retryOptions.backoffLimit) + noise;\n};\n\nexport default calculateRetryDelay;","map":{"version":3,"names":["calculateRetryDelay","attemptCount","retryOptions","error","retryAfter","computedValue","name","limit","hasMethod","methods","includes","options","method","hasErrorCode","errorCodes","code","hasStatusCode","response","statusCodes","statusCode","noise","Math","random","min","backoffLimit"],"sources":["E:/web/alchemists_vue/alchemists/node_modules/got/dist/source/core/calculate-retry-delay.js"],"sourcesContent":["const calculateRetryDelay = ({ attemptCount, retryOptions, error, retryAfter, computedValue, }) => {\n    if (error.name === 'RetryError') {\n        return 1;\n    }\n    if (attemptCount > retryOptions.limit) {\n        return 0;\n    }\n    const hasMethod = retryOptions.methods.includes(error.options.method);\n    const hasErrorCode = retryOptions.errorCodes.includes(error.code);\n    const hasStatusCode = error.response && retryOptions.statusCodes.includes(error.response.statusCode);\n    if (!hasMethod || (!hasErrorCode && !hasStatusCode)) {\n        return 0;\n    }\n    if (error.response) {\n        if (retryAfter) {\n            // In this case `computedValue` is `options.request.timeout`\n            if (retryAfter > computedValue) {\n                return 0;\n            }\n            return retryAfter;\n        }\n        if (error.response.statusCode === 413) {\n            return 0;\n        }\n    }\n    const noise = Math.random() * retryOptions.noise;\n    return Math.min(((2 ** (attemptCount - 1)) * 1000), retryOptions.backoffLimit) + noise;\n};\nexport default calculateRetryDelay;\n"],"mappings":";;AAAA,MAAMA,mBAAmB,GAAG,CAAC;EAAEC,YAAF;EAAgBC,YAAhB;EAA8BC,KAA9B;EAAqCC,UAArC;EAAiDC;AAAjD,CAAD,KAAuE;EAC/F,IAAIF,KAAK,CAACG,IAAN,KAAe,YAAnB,EAAiC;IAC7B,OAAO,CAAP;EACH;;EACD,IAAIL,YAAY,GAAGC,YAAY,CAACK,KAAhC,EAAuC;IACnC,OAAO,CAAP;EACH;;EACD,MAAMC,SAAS,GAAGN,YAAY,CAACO,OAAb,CAAqBC,QAArB,CAA8BP,KAAK,CAACQ,OAAN,CAAcC,MAA5C,CAAlB;EACA,MAAMC,YAAY,GAAGX,YAAY,CAACY,UAAb,CAAwBJ,QAAxB,CAAiCP,KAAK,CAACY,IAAvC,CAArB;EACA,MAAMC,aAAa,GAAGb,KAAK,CAACc,QAAN,IAAkBf,YAAY,CAACgB,WAAb,CAAyBR,QAAzB,CAAkCP,KAAK,CAACc,QAAN,CAAeE,UAAjD,CAAxC;;EACA,IAAI,CAACX,SAAD,IAAe,CAACK,YAAD,IAAiB,CAACG,aAArC,EAAqD;IACjD,OAAO,CAAP;EACH;;EACD,IAAIb,KAAK,CAACc,QAAV,EAAoB;IAChB,IAAIb,UAAJ,EAAgB;MACZ;MACA,IAAIA,UAAU,GAAGC,aAAjB,EAAgC;QAC5B,OAAO,CAAP;MACH;;MACD,OAAOD,UAAP;IACH;;IACD,IAAID,KAAK,CAACc,QAAN,CAAeE,UAAf,KAA8B,GAAlC,EAAuC;MACnC,OAAO,CAAP;IACH;EACJ;;EACD,MAAMC,KAAK,GAAGC,IAAI,CAACC,MAAL,KAAgBpB,YAAY,CAACkB,KAA3C;EACA,OAAOC,IAAI,CAACE,GAAL,CAAW,MAAMtB,YAAY,GAAG,CAArB,CAAD,GAA4B,IAAtC,EAA6CC,YAAY,CAACsB,YAA1D,IAA0EJ,KAAjF;AACH,CA3BD;;AA4BA,eAAepB,mBAAf"},"metadata":{},"sourceType":"module"}