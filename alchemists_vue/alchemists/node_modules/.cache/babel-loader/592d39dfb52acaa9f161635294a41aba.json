{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport process from 'node:process';\nimport { Buffer } from 'node:buffer';\nimport { Duplex } from 'node:stream';\nimport { URL, URLSearchParams } from 'node:url';\nimport http, { ServerResponse } from 'node:http';\nimport timer from '@szmarczak/http-timer';\nimport CacheableRequest from 'cacheable-request';\nimport decompressResponse from 'decompress-response';\nimport is from '@sindresorhus/is';\nimport { buffer as getBuffer } from 'get-stream';\nimport { FormDataEncoder, isFormDataLike } from 'form-data-encoder';\nimport getBodySize from './utils/get-body-size.js';\nimport isFormData from './utils/is-form-data.js';\nimport proxyEvents from './utils/proxy-events.js';\nimport timedOut, { TimeoutError as TimedOutTimeoutError } from './timed-out.js';\nimport urlToOptions from './utils/url-to-options.js';\nimport WeakableMap from './utils/weakable-map.js';\nimport calculateRetryDelay from './calculate-retry-delay.js';\nimport Options from './options.js';\nimport { isResponseOk } from './response.js';\nimport isClientRequest from './utils/is-client-request.js';\nimport { RequestError, ReadError, MaxRedirectsError, HTTPError, TimeoutError, UploadError, CacheError } from './errors.js';\nconst supportsBrotli = is.string(process.versions.brotli);\nconst methodsWithoutBody = new Set(['GET', 'HEAD']);\nconst cacheableStore = new WeakableMap();\nconst redirectCodes = new Set([300, 301, 302, 303, 304, 307, 308]);\nconst proxiedRequestEvents = ['socket', 'connect', 'continue', 'information', 'upgrade'];\n\nconst noop = () => {};\n\nexport default class Request extends Duplex {\n  constructor(url, options, defaults) {\n    super({\n      // Don't destroy immediately, as the error may be emitted on unsuccessful retry\n      autoDestroy: false,\n      // It needs to be zero because we're just proxying the data to another stream\n      highWaterMark: 0\n    });\n    Object.defineProperty(this, 'constructor', {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_noPipe\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    }); // @ts-expect-error https://github.com/microsoft/TypeScript/issues/9568\n\n    Object.defineProperty(this, \"options\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"response\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"requestUrl\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"redirectUrls\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"retryCount\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_stopRetry\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_downloadedSize\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_uploadedSize\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_stopReading\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_pipedServerResponses\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_request\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_responseSize\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_bodySize\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_unproxyEvents\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_isFromCache\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_cannotHaveBody\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_triggerRead\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_cancelTimeouts\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_nativeResponse\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_flushed\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_aborted\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    }); // We need this because `this._request` if `undefined` when using cache\n\n    Object.defineProperty(this, \"_requestInitialized\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this._downloadedSize = 0;\n    this._uploadedSize = 0;\n    this._stopReading = false;\n    this._pipedServerResponses = new Set();\n    this._cannotHaveBody = false;\n    this._unproxyEvents = noop;\n    this._triggerRead = false;\n    this._cancelTimeouts = noop;\n    this._jobs = [];\n    this._flushed = false;\n    this._requestInitialized = false;\n    this._aborted = false;\n    this.redirectUrls = [];\n    this.retryCount = 0;\n    this._stopRetry = noop;\n    this.on('pipe', source => {\n      if (source.headers) {\n        Object.assign(this.options.headers, source.headers);\n      }\n    });\n    this.on('newListener', event => {\n      if (event === 'retry' && this.listenerCount('retry') > 0) {\n        throw new Error('A retry listener has been attached already.');\n      }\n    });\n\n    try {\n      this.options = new Options(url, options, defaults);\n\n      if (!this.options.url) {\n        if (this.options.prefixUrl === '') {\n          throw new TypeError('Missing `url` property');\n        }\n\n        this.options.url = '';\n      }\n\n      this.requestUrl = this.options.url;\n    } catch (error) {\n      const {\n        options\n      } = error;\n\n      if (options) {\n        this.options = options;\n      }\n\n      this.flush = async () => {\n        this.flush = async () => {};\n\n        this.destroy(error);\n      };\n\n      return;\n    } // Important! If you replace `body` in a handler with another stream, make sure it's readable first.\n    // The below is run only once.\n\n\n    const {\n      body\n    } = this.options;\n\n    if (is.nodeStream(body)) {\n      body.once('error', error => {\n        if (this._flushed) {\n          this._beforeError(new UploadError(error, this));\n        } else {\n          this.flush = async () => {\n            this.flush = async () => {};\n\n            this._beforeError(new UploadError(error, this));\n          };\n        }\n      });\n    }\n  }\n\n  async flush() {\n    if (this._flushed) {\n      return;\n    }\n\n    this._flushed = true;\n\n    try {\n      await this._finalizeBody();\n\n      if (this.destroyed) {\n        return;\n      }\n\n      await this._makeRequest();\n\n      if (this.destroyed) {\n        this._request?.destroy();\n        return;\n      } // Queued writes etc.\n\n\n      for (const job of this._jobs) {\n        job();\n      } // Prevent memory leak\n\n\n      this._jobs.length = 0;\n      this._requestInitialized = true;\n    } catch (error) {\n      this._beforeError(error);\n    }\n  }\n\n  _beforeError(error) {\n    if (this._stopReading) {\n      return;\n    }\n\n    const {\n      response,\n      options\n    } = this;\n    const attemptCount = this.retryCount + (error.name === 'RetryError' ? 0 : 1);\n    this._stopReading = true;\n\n    if (!(error instanceof RequestError)) {\n      error = new RequestError(error.message, error, this);\n    }\n\n    const typedError = error;\n    void (async () => {\n      // Node.js parser is really weird.\n      // It emits post-request Parse Errors on the same instance as previous request. WTF.\n      // Therefore we need to check if it has been destroyed as well.\n      //\n      // Furthermore, Node.js 16 `response.destroy()` doesn't immediately destroy the socket,\n      // but makes the response unreadable. So we additionally need to check `response.readable`.\n      if (response?.readable && !response.rawBody && !this._request?.socket?.destroyed) {\n        // @types/node has incorrect typings. `setEncoding` accepts `null` as well.\n        response.setEncoding(this.readableEncoding);\n        const success = await this._setRawBody(response);\n\n        if (success) {\n          response.body = response.rawBody.toString();\n        }\n      }\n\n      if (this.listenerCount('retry') !== 0) {\n        let backoff;\n\n        try {\n          let retryAfter;\n\n          if (response && 'retry-after' in response.headers) {\n            retryAfter = Number(response.headers['retry-after']);\n\n            if (Number.isNaN(retryAfter)) {\n              retryAfter = Date.parse(response.headers['retry-after']) - Date.now();\n\n              if (retryAfter <= 0) {\n                retryAfter = 1;\n              }\n            } else {\n              retryAfter *= 1000;\n            }\n          }\n\n          const retryOptions = options.retry;\n          backoff = await retryOptions.calculateDelay({\n            attemptCount,\n            retryOptions,\n            error: typedError,\n            retryAfter,\n            computedValue: calculateRetryDelay({\n              attemptCount,\n              retryOptions,\n              error: typedError,\n              retryAfter,\n              computedValue: retryOptions.maxRetryAfter ?? options.timeout.request ?? Number.POSITIVE_INFINITY\n            })\n          });\n        } catch (error_) {\n          void this._error(new RequestError(error_.message, error_, this));\n          return;\n        }\n\n        if (backoff) {\n          await new Promise(resolve => {\n            const timeout = setTimeout(resolve, backoff);\n\n            this._stopRetry = () => {\n              clearTimeout(timeout);\n              resolve();\n            };\n          }); // Something forced us to abort the retry\n\n          if (this.destroyed) {\n            return;\n          }\n\n          try {\n            for (const hook of this.options.hooks.beforeRetry) {\n              // eslint-disable-next-line no-await-in-loop\n              await hook(typedError, this.retryCount + 1);\n            }\n          } catch (error_) {\n            void this._error(new RequestError(error_.message, error, this));\n            return;\n          } // Something forced us to abort the retry\n\n\n          if (this.destroyed) {\n            return;\n          }\n\n          this.destroy();\n          this.emit('retry', this.retryCount + 1, error, updatedOptions => {\n            const request = new Request(options.url, updatedOptions, options);\n            request.retryCount = this.retryCount + 1;\n            process.nextTick(() => {\n              void request.flush();\n            });\n            return request;\n          });\n          return;\n        }\n      }\n\n      void this._error(typedError);\n    })();\n  }\n\n  _read() {\n    this._triggerRead = true;\n    const {\n      response\n    } = this;\n\n    if (response && !this._stopReading) {\n      // We cannot put this in the `if` above\n      // because `.read()` also triggers the `end` event\n      if (response.readableLength) {\n        this._triggerRead = false;\n      }\n\n      let data;\n\n      while ((data = response.read()) !== null) {\n        this._downloadedSize += data.length; // eslint-disable-line @typescript-eslint/restrict-plus-operands\n\n        const progress = this.downloadProgress;\n\n        if (progress.percent < 1) {\n          this.emit('downloadProgress', progress);\n        }\n\n        this.push(data);\n      }\n    }\n  }\n\n  _write(chunk, encoding, callback) {\n    const write = () => {\n      this._writeRequest(chunk, encoding, callback);\n    };\n\n    if (this._requestInitialized) {\n      write();\n    } else {\n      this._jobs.push(write);\n    }\n  }\n\n  _final(callback) {\n    const endRequest = () => {\n      // We need to check if `this._request` is present,\n      // because it isn't when we use cache.\n      if (!this._request || this._request.destroyed) {\n        callback();\n        return;\n      }\n\n      this._request.end(error => {\n        // The request has been destroyed before `_final` finished.\n        // See https://github.com/nodejs/node/issues/39356\n        if (this._request._writableState?.errored) {\n          return;\n        }\n\n        if (!error) {\n          this._bodySize = this._uploadedSize;\n          this.emit('uploadProgress', this.uploadProgress);\n\n          this._request.emit('upload-complete');\n        }\n\n        callback(error);\n      });\n    };\n\n    if (this._requestInitialized) {\n      endRequest();\n    } else {\n      this._jobs.push(endRequest);\n    }\n  }\n\n  _destroy(error, callback) {\n    this._stopReading = true;\n\n    this.flush = async () => {}; // Prevent further retries\n\n\n    this._stopRetry();\n\n    this._cancelTimeouts();\n\n    if (this.options) {\n      const {\n        body\n      } = this.options;\n\n      if (is.nodeStream(body)) {\n        body.destroy();\n      }\n    }\n\n    if (this._request) {\n      this._request.destroy();\n    }\n\n    if (error !== null && !is.undefined(error) && !(error instanceof RequestError)) {\n      error = new RequestError(error.message, error, this);\n    }\n\n    callback(error);\n  }\n\n  pipe(destination, options) {\n    if (destination instanceof ServerResponse) {\n      this._pipedServerResponses.add(destination);\n    }\n\n    return super.pipe(destination, options);\n  }\n\n  unpipe(destination) {\n    if (destination instanceof ServerResponse) {\n      this._pipedServerResponses.delete(destination);\n    }\n\n    super.unpipe(destination);\n    return this;\n  }\n\n  async _finalizeBody() {\n    const {\n      options\n    } = this;\n    const {\n      headers\n    } = options;\n    const isForm = !is.undefined(options.form); // eslint-disable-next-line @typescript-eslint/naming-convention\n\n    const isJSON = !is.undefined(options.json);\n    const isBody = !is.undefined(options.body);\n    const cannotHaveBody = methodsWithoutBody.has(options.method) && !(options.method === 'GET' && options.allowGetBody);\n    this._cannotHaveBody = cannotHaveBody;\n\n    if (isForm || isJSON || isBody) {\n      if (cannotHaveBody) {\n        throw new TypeError(`The \\`${options.method}\\` method cannot be used with a body`);\n      } // Serialize body\n\n\n      const noContentType = !is.string(headers['content-type']);\n\n      if (isBody) {\n        // Body is spec-compliant FormData\n        if (isFormDataLike(options.body)) {\n          const encoder = new FormDataEncoder(options.body);\n\n          if (noContentType) {\n            headers['content-type'] = encoder.headers['Content-Type'];\n          }\n\n          headers['content-length'] = encoder.headers['Content-Length'];\n          options.body = encoder.encode();\n        } // Special case for https://github.com/form-data/form-data\n\n\n        if (isFormData(options.body) && noContentType) {\n          headers['content-type'] = `multipart/form-data; boundary=${options.body.getBoundary()}`;\n        }\n      } else if (isForm) {\n        if (noContentType) {\n          headers['content-type'] = 'application/x-www-form-urlencoded';\n        }\n\n        const {\n          form\n        } = options;\n        options.form = undefined;\n        options.body = new URLSearchParams(form).toString();\n      } else {\n        if (noContentType) {\n          headers['content-type'] = 'application/json';\n        }\n\n        const {\n          json\n        } = options;\n        options.json = undefined;\n        options.body = options.stringifyJson(json);\n      }\n\n      const uploadBodySize = await getBodySize(options.body, options.headers); // See https://tools.ietf.org/html/rfc7230#section-3.3.2\n      // A user agent SHOULD send a Content-Length in a request message when\n      // no Transfer-Encoding is sent and the request method defines a meaning\n      // for an enclosed payload body.  For example, a Content-Length header\n      // field is normally sent in a POST request even when the value is 0\n      // (indicating an empty payload body).  A user agent SHOULD NOT send a\n      // Content-Length header field when the request message does not contain\n      // a payload body and the method semantics do not anticipate such a\n      // body.\n\n      if (is.undefined(headers['content-length']) && is.undefined(headers['transfer-encoding']) && !cannotHaveBody && !is.undefined(uploadBodySize)) {\n        headers['content-length'] = String(uploadBodySize);\n      }\n    }\n\n    if (options.responseType === 'json' && !('accept' in options.headers)) {\n      options.headers.accept = 'application/json';\n    }\n\n    this._bodySize = Number(headers['content-length']) || undefined;\n  }\n\n  async _onResponseBase(response) {\n    // This will be called e.g. when using cache so we need to check if this request has been aborted.\n    if (this.isAborted) {\n      return;\n    }\n\n    const {\n      options\n    } = this;\n    const {\n      url\n    } = options;\n    this._nativeResponse = response;\n\n    if (options.decompress) {\n      response = decompressResponse(response);\n    }\n\n    const statusCode = response.statusCode;\n    const typedResponse = response;\n    typedResponse.statusMessage = typedResponse.statusMessage ? typedResponse.statusMessage : http.STATUS_CODES[statusCode];\n    typedResponse.url = options.url.toString();\n    typedResponse.requestUrl = this.requestUrl;\n    typedResponse.redirectUrls = this.redirectUrls;\n    typedResponse.request = this;\n    typedResponse.isFromCache = this._nativeResponse.fromCache ?? false;\n    typedResponse.ip = this.ip;\n    typedResponse.retryCount = this.retryCount;\n    this._isFromCache = typedResponse.isFromCache;\n    this._responseSize = Number(response.headers['content-length']) || undefined;\n    this.response = typedResponse;\n    response.once('end', () => {\n      this._responseSize = this._downloadedSize;\n      this.emit('downloadProgress', this.downloadProgress);\n    });\n    response.once('error', error => {\n      this._aborted = true; // Force clean-up, because some packages don't do this.\n      // TODO: Fix decompress-response\n\n      response.destroy();\n\n      this._beforeError(new ReadError(error, this));\n    });\n    response.once('aborted', () => {\n      this._aborted = true;\n\n      this._beforeError(new ReadError({\n        name: 'Error',\n        message: 'The server aborted pending request',\n        code: 'ECONNRESET'\n      }, this));\n    });\n    this.emit('downloadProgress', this.downloadProgress);\n    const rawCookies = response.headers['set-cookie'];\n\n    if (is.object(options.cookieJar) && rawCookies) {\n      let promises = rawCookies.map(async rawCookie => options.cookieJar.setCookie(rawCookie, url.toString()));\n\n      if (options.ignoreInvalidCookies) {\n        promises = promises.map(async promise => {\n          try {\n            await promise;\n          } catch {}\n        });\n      }\n\n      try {\n        await Promise.all(promises);\n      } catch (error) {\n        this._beforeError(error);\n\n        return;\n      }\n    } // The above is running a promise, therefore we need to check if this request has been aborted yet again.\n\n\n    if (this.isAborted) {\n      return;\n    }\n\n    if (options.followRedirect && response.headers.location && redirectCodes.has(statusCode)) {\n      // We're being redirected, we don't care about the response.\n      // It'd be best to abort the request, but we can't because\n      // we would have to sacrifice the TCP connection. We don't want that.\n      response.resume();\n\n      this._cancelTimeouts();\n\n      this._unproxyEvents();\n\n      if (this.redirectUrls.length >= options.maxRedirects) {\n        this._beforeError(new MaxRedirectsError(this));\n\n        return;\n      }\n\n      this._request = undefined;\n      const updatedOptions = new Options(undefined, undefined, this.options);\n      const shouldBeGet = statusCode === 303 && updatedOptions.method !== 'GET' && updatedOptions.method !== 'HEAD';\n\n      if (shouldBeGet || updatedOptions.methodRewriting) {\n        // Server responded with \"see other\", indicating that the resource exists at another location,\n        // and the client should request it from that location via GET or HEAD.\n        updatedOptions.method = 'GET';\n        updatedOptions.body = undefined;\n        updatedOptions.json = undefined;\n        updatedOptions.form = undefined;\n        delete updatedOptions.headers['content-length'];\n      }\n\n      try {\n        // We need this in order to support UTF-8\n        const redirectBuffer = Buffer.from(response.headers.location, 'binary').toString();\n        const redirectUrl = new URL(redirectBuffer, url); // Redirecting to a different site, clear sensitive data.\n\n        if (redirectUrl.hostname !== url.hostname || redirectUrl.port !== url.port) {\n          if ('host' in updatedOptions.headers) {\n            delete updatedOptions.headers.host;\n          }\n\n          if ('cookie' in updatedOptions.headers) {\n            delete updatedOptions.headers.cookie;\n          }\n\n          if ('authorization' in updatedOptions.headers) {\n            delete updatedOptions.headers.authorization;\n          }\n\n          if (updatedOptions.username || updatedOptions.password) {\n            updatedOptions.username = '';\n            updatedOptions.password = '';\n          }\n        } else {\n          redirectUrl.username = updatedOptions.username;\n          redirectUrl.password = updatedOptions.password;\n        }\n\n        this.redirectUrls.push(redirectUrl);\n        updatedOptions.prefixUrl = '';\n        updatedOptions.url = redirectUrl;\n\n        for (const hook of updatedOptions.hooks.beforeRedirect) {\n          // eslint-disable-next-line no-await-in-loop\n          await hook(updatedOptions, typedResponse);\n        }\n\n        this.emit('redirect', updatedOptions, typedResponse);\n        this.options = updatedOptions;\n        await this._makeRequest();\n      } catch (error) {\n        this._beforeError(error);\n\n        return;\n      }\n\n      return;\n    }\n\n    if (options.isStream && options.throwHttpErrors && !isResponseOk(typedResponse)) {\n      this._beforeError(new HTTPError(typedResponse));\n\n      return;\n    }\n\n    response.on('readable', () => {\n      if (this._triggerRead) {\n        this._read();\n      }\n    });\n    this.on('resume', () => {\n      response.resume();\n    });\n    this.on('pause', () => {\n      response.pause();\n    });\n    response.once('end', () => {\n      this.push(null);\n    });\n\n    if (this._noPipe) {\n      const success = await this._setRawBody();\n\n      if (success) {\n        this.emit('response', response);\n      }\n\n      return;\n    }\n\n    this.emit('response', response);\n\n    for (const destination of this._pipedServerResponses) {\n      if (destination.headersSent) {\n        continue;\n      } // eslint-disable-next-line guard-for-in\n\n\n      for (const key in response.headers) {\n        const isAllowed = options.decompress ? key !== 'content-encoding' : true;\n        const value = response.headers[key];\n\n        if (isAllowed) {\n          destination.setHeader(key, value);\n        }\n      }\n\n      destination.statusCode = statusCode;\n    }\n  }\n\n  async _setRawBody(from = this) {\n    if (from.readableEnded) {\n      return false;\n    }\n\n    try {\n      // Errors are emitted via the `error` event\n      const rawBody = await getBuffer(from); // On retry Request is destroyed with no error, therefore the above will successfully resolve.\n      // So in order to check if this was really successfull, we need to check if it has been properly ended.\n\n      if (!this.isAborted) {\n        this.response.rawBody = rawBody;\n        return true;\n      }\n    } catch {}\n\n    return false;\n  }\n\n  async _onResponse(response) {\n    try {\n      await this._onResponseBase(response);\n    } catch (error) {\n      /* istanbul ignore next: better safe than sorry */\n      this._beforeError(error);\n    }\n  }\n\n  _onRequest(request) {\n    const {\n      options\n    } = this;\n    const {\n      timeout,\n      url\n    } = options;\n    timer(request);\n\n    if (this.options.http2) {\n      // Unset stream timeout, as the `timeout` option was used only for connection timeout.\n      request.setTimeout(0);\n    }\n\n    this._cancelTimeouts = timedOut(request, timeout, url);\n    const responseEventName = options.cache ? 'cacheableResponse' : 'response';\n    request.once(responseEventName, response => {\n      void this._onResponse(response);\n    });\n    request.once('error', error => {\n      this._aborted = true; // Force clean-up, because some packages (e.g. nock) don't do this.\n\n      request.destroy();\n      error = error instanceof TimedOutTimeoutError ? new TimeoutError(error, this.timings, this) : new RequestError(error.message, error, this);\n\n      this._beforeError(error);\n    });\n    this._unproxyEvents = proxyEvents(request, this, proxiedRequestEvents);\n    this._request = request;\n    this.emit('uploadProgress', this.uploadProgress);\n\n    this._sendBody();\n\n    this.emit('request', request);\n  }\n\n  async _asyncWrite(chunk) {\n    return new Promise((resolve, reject) => {\n      super.write(chunk, error => {\n        if (error) {\n          reject(error);\n          return;\n        }\n\n        resolve();\n      });\n    });\n  }\n\n  _sendBody() {\n    // Send body\n    const {\n      body\n    } = this.options;\n    const currentRequest = this.redirectUrls.length === 0 ? this : this._request ?? this;\n\n    if (is.nodeStream(body)) {\n      body.pipe(currentRequest);\n    } else if (is.generator(body) || is.asyncGenerator(body)) {\n      (async () => {\n        try {\n          for await (const chunk of body) {\n            await this._asyncWrite(chunk);\n          }\n\n          super.end();\n        } catch (error) {\n          this._beforeError(error);\n        }\n      })();\n    } else if (!is.undefined(body)) {\n      this._writeRequest(body, undefined, () => {});\n\n      currentRequest.end();\n    } else if (this._cannotHaveBody || this._noPipe) {\n      currentRequest.end();\n    }\n  }\n\n  _prepareCache(cache) {\n    if (!cacheableStore.has(cache)) {\n      cacheableStore.set(cache, new CacheableRequest((requestOptions, handler) => {\n        const result = requestOptions._request(requestOptions, handler); // TODO: remove this when `cacheable-request` supports async request functions.\n\n\n        if (is.promise(result)) {\n          // We only need to implement the error handler in order to support HTTP2 caching.\n          // The result will be a promise anyway.\n          // @ts-expect-error ignore\n          // eslint-disable-next-line @typescript-eslint/promise-function-async\n          result.once = (event, handler) => {\n            if (event === 'error') {\n              (async () => {\n                try {\n                  await result;\n                } catch (error) {\n                  handler(error);\n                }\n              })();\n            } else if (event === 'abort') {\n              // The empty catch is needed here in case when\n              // it rejects before it's `await`ed in `_makeRequest`.\n              (async () => {\n                try {\n                  const request = await result;\n                  request.once('abort', handler);\n                } catch {}\n              })();\n            } else {\n              /* istanbul ignore next: safety check */\n              throw new Error(`Unknown HTTP2 promise event: ${event}`);\n            }\n\n            return result;\n          };\n        }\n\n        return result;\n      }, cache));\n    }\n  }\n\n  async _createCacheableRequest(url, options) {\n    return new Promise((resolve, reject) => {\n      // TODO: Remove `utils/url-to-options.ts` when `cacheable-request` is fixed\n      Object.assign(options, urlToOptions(url));\n      let request; // TODO: Fix `cacheable-response`. This is ugly.\n\n      const cacheRequest = cacheableStore.get(options.cache)(options, async response => {\n        response._readableState.autoDestroy = false;\n\n        if (request) {\n          const fix = () => {\n            if (response.req) {\n              response.complete = response.req.res.complete;\n            }\n          };\n\n          response.prependOnceListener('end', fix);\n          fix();\n          (await request).emit('cacheableResponse', response);\n        }\n\n        resolve(response);\n      });\n      cacheRequest.once('error', reject);\n      cacheRequest.once('request', async requestOrPromise => {\n        request = requestOrPromise;\n        resolve(request);\n      });\n    });\n  }\n\n  async _makeRequest() {\n    const {\n      options\n    } = this;\n    const {\n      headers,\n      username,\n      password\n    } = options;\n    const cookieJar = options.cookieJar;\n\n    for (const key in headers) {\n      if (is.undefined(headers[key])) {\n        // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n        delete headers[key];\n      } else if (is.null_(headers[key])) {\n        throw new TypeError(`Use \\`undefined\\` instead of \\`null\\` to delete the \\`${key}\\` header`);\n      }\n    }\n\n    if (options.decompress && is.undefined(headers['accept-encoding'])) {\n      headers['accept-encoding'] = supportsBrotli ? 'gzip, deflate, br' : 'gzip, deflate';\n    }\n\n    if (username || password) {\n      const credentials = Buffer.from(`${username}:${password}`).toString('base64');\n      headers.authorization = `Basic ${credentials}`;\n    } // Set cookies\n\n\n    if (cookieJar) {\n      const cookieString = await cookieJar.getCookieString(options.url.toString());\n\n      if (is.nonEmptyString(cookieString)) {\n        headers.cookie = cookieString;\n      }\n    } // Reset `prefixUrl`\n\n\n    options.prefixUrl = '';\n    let request;\n\n    for (const hook of options.hooks.beforeRequest) {\n      // eslint-disable-next-line no-await-in-loop\n      const result = await hook(options);\n\n      if (!is.undefined(result)) {\n        // @ts-expect-error Skip the type mismatch to support abstract responses\n        request = () => result;\n\n        break;\n      }\n    }\n\n    if (!request) {\n      request = options.getRequestFunction();\n    }\n\n    const url = options.url;\n    this._requestOptions = options.createNativeRequestOptions();\n\n    if (options.cache) {\n      this._requestOptions._request = request;\n      this._requestOptions.cache = options.cache;\n\n      this._prepareCache(options.cache);\n    } // Cache support\n\n\n    const fn = options.cache ? this._createCacheableRequest : request;\n\n    try {\n      // We can't do `await fn(...)`,\n      // because stream `error` event can be emitted before `Promise.resolve()`.\n      let requestOrResponse = fn(url, this._requestOptions);\n\n      if (is.promise(requestOrResponse)) {\n        requestOrResponse = await requestOrResponse;\n      } // Fallback\n\n\n      if (is.undefined(requestOrResponse)) {\n        requestOrResponse = options.getFallbackRequestFunction()(url, this._requestOptions);\n\n        if (is.promise(requestOrResponse)) {\n          requestOrResponse = await requestOrResponse;\n        }\n      }\n\n      if (isClientRequest(requestOrResponse)) {\n        this._onRequest(requestOrResponse);\n      } else if (this.writable) {\n        this.once('finish', () => {\n          void this._onResponse(requestOrResponse);\n        });\n\n        this._sendBody();\n      } else {\n        void this._onResponse(requestOrResponse);\n      }\n    } catch (error) {\n      if (error instanceof CacheableRequest.CacheError) {\n        throw new CacheError(error, this);\n      }\n\n      throw error;\n    }\n  }\n\n  async _error(error) {\n    try {\n      for (const hook of this.options.hooks.beforeError) {\n        // eslint-disable-next-line no-await-in-loop\n        error = await hook(error);\n      }\n    } catch (error_) {\n      error = new RequestError(error_.message, error_, this);\n    }\n\n    this.destroy(error);\n  }\n\n  _writeRequest(chunk, encoding, callback) {\n    if (!this._request || this._request.destroyed) {\n      // Probably the `ClientRequest` instance will throw\n      return;\n    }\n\n    this._request.write(chunk, encoding, error => {\n      if (!error) {\n        this._uploadedSize += Buffer.byteLength(chunk, encoding);\n        const progress = this.uploadProgress;\n\n        if (progress.percent < 1) {\n          this.emit('uploadProgress', progress);\n        }\n      }\n\n      callback(error);\n    });\n  }\n  /**\n  The remote IP address.\n  */\n\n\n  get ip() {\n    return this.socket?.remoteAddress;\n  }\n  /**\n  Indicates whether the request has been aborted or not.\n  */\n\n\n  get isAborted() {\n    return this._aborted;\n  }\n\n  get socket() {\n    return this._request?.socket ?? undefined;\n  }\n  /**\n  Progress event for downloading (receiving a response).\n  */\n\n\n  get downloadProgress() {\n    let percent;\n\n    if (this._responseSize) {\n      percent = this._downloadedSize / this._responseSize;\n    } else if (this._responseSize === this._downloadedSize) {\n      percent = 1;\n    } else {\n      percent = 0;\n    }\n\n    return {\n      percent,\n      transferred: this._downloadedSize,\n      total: this._responseSize\n    };\n  }\n  /**\n  Progress event for uploading (sending a request).\n  */\n\n\n  get uploadProgress() {\n    let percent;\n\n    if (this._bodySize) {\n      percent = this._uploadedSize / this._bodySize;\n    } else if (this._bodySize === this._uploadedSize) {\n      percent = 1;\n    } else {\n      percent = 0;\n    }\n\n    return {\n      percent,\n      transferred: this._uploadedSize,\n      total: this._bodySize\n    };\n  }\n  /**\n  The object contains the following properties:\n   - `start` - Time when the request started.\n  - `socket` - Time when a socket was assigned to the request.\n  - `lookup` - Time when the DNS lookup finished.\n  - `connect` - Time when the socket successfully connected.\n  - `secureConnect` - Time when the socket securely connected.\n  - `upload` - Time when the request finished uploading.\n  - `response` - Time when the request fired `response` event.\n  - `end` - Time when the response fired `end` event.\n  - `error` - Time when the request fired `error` event.\n  - `abort` - Time when the request fired `abort` event.\n  - `phases`\n      - `wait` - `timings.socket - timings.start`\n      - `dns` - `timings.lookup - timings.socket`\n      - `tcp` - `timings.connect - timings.lookup`\n      - `tls` - `timings.secureConnect - timings.connect`\n      - `request` - `timings.upload - (timings.secureConnect || timings.connect)`\n      - `firstByte` - `timings.response - timings.upload`\n      - `download` - `timings.end - timings.response`\n      - `total` - `(timings.end || timings.error || timings.abort) - timings.start`\n   If something has not been measured yet, it will be `undefined`.\n   __Note__: The time is a `number` representing the milliseconds elapsed since the UNIX epoch.\n  */\n\n\n  get timings() {\n    return this._request?.timings;\n  }\n  /**\n  Whether the response was retrieved from the cache.\n  */\n\n\n  get isFromCache() {\n    return this._isFromCache;\n  }\n\n  get reusedSocket() {\n    return this._request?.reusedSocket;\n  }\n\n}","map":{"version":3,"names":["process","Buffer","Duplex","URL","URLSearchParams","http","ServerResponse","timer","CacheableRequest","decompressResponse","is","buffer","getBuffer","FormDataEncoder","isFormDataLike","getBodySize","isFormData","proxyEvents","timedOut","TimeoutError","TimedOutTimeoutError","urlToOptions","WeakableMap","calculateRetryDelay","Options","isResponseOk","isClientRequest","RequestError","ReadError","MaxRedirectsError","HTTPError","UploadError","CacheError","supportsBrotli","string","versions","brotli","methodsWithoutBody","Set","cacheableStore","redirectCodes","proxiedRequestEvents","noop","Request","constructor","url","options","defaults","autoDestroy","highWaterMark","Object","defineProperty","enumerable","configurable","writable","value","_downloadedSize","_uploadedSize","_stopReading","_pipedServerResponses","_cannotHaveBody","_unproxyEvents","_triggerRead","_cancelTimeouts","_jobs","_flushed","_requestInitialized","_aborted","redirectUrls","retryCount","_stopRetry","on","source","headers","assign","event","listenerCount","Error","prefixUrl","TypeError","requestUrl","error","flush","destroy","body","nodeStream","once","_beforeError","_finalizeBody","destroyed","_makeRequest","_request","job","length","response","attemptCount","name","message","typedError","readable","rawBody","socket","setEncoding","readableEncoding","success","_setRawBody","toString","backoff","retryAfter","Number","isNaN","Date","parse","now","retryOptions","retry","calculateDelay","computedValue","maxRetryAfter","timeout","request","POSITIVE_INFINITY","error_","_error","Promise","resolve","setTimeout","clearTimeout","hook","hooks","beforeRetry","emit","updatedOptions","nextTick","_read","readableLength","data","read","progress","downloadProgress","percent","push","_write","chunk","encoding","callback","write","_writeRequest","_final","endRequest","end","_writableState","errored","_bodySize","uploadProgress","_destroy","undefined","pipe","destination","add","unpipe","delete","isForm","form","isJSON","json","isBody","cannotHaveBody","has","method","allowGetBody","noContentType","encoder","encode","getBoundary","stringifyJson","uploadBodySize","String","responseType","accept","_onResponseBase","isAborted","_nativeResponse","decompress","statusCode","typedResponse","statusMessage","STATUS_CODES","isFromCache","fromCache","ip","_isFromCache","_responseSize","code","rawCookies","object","cookieJar","promises","map","rawCookie","setCookie","ignoreInvalidCookies","promise","all","followRedirect","location","resume","maxRedirects","shouldBeGet","methodRewriting","redirectBuffer","from","redirectUrl","hostname","port","host","cookie","authorization","username","password","beforeRedirect","isStream","throwHttpErrors","pause","_noPipe","headersSent","key","isAllowed","setHeader","readableEnded","_onResponse","_onRequest","http2","responseEventName","cache","timings","_sendBody","_asyncWrite","reject","currentRequest","generator","asyncGenerator","_prepareCache","set","requestOptions","handler","result","_createCacheableRequest","cacheRequest","get","_readableState","fix","req","complete","res","prependOnceListener","requestOrPromise","null_","credentials","cookieString","getCookieString","nonEmptyString","beforeRequest","getRequestFunction","_requestOptions","createNativeRequestOptions","fn","requestOrResponse","getFallbackRequestFunction","beforeError","byteLength","remoteAddress","transferred","total","reusedSocket"],"sources":["E:/web/alchemists_vue/alchemists/node_modules/got/dist/source/core/index.js"],"sourcesContent":["import process from 'node:process';\nimport { Buffer } from 'node:buffer';\nimport { Duplex } from 'node:stream';\nimport { URL, URLSearchParams } from 'node:url';\nimport http, { ServerResponse } from 'node:http';\nimport timer from '@szmarczak/http-timer';\nimport CacheableRequest from 'cacheable-request';\nimport decompressResponse from 'decompress-response';\nimport is from '@sindresorhus/is';\nimport { buffer as getBuffer } from 'get-stream';\nimport { FormDataEncoder, isFormDataLike } from 'form-data-encoder';\nimport getBodySize from './utils/get-body-size.js';\nimport isFormData from './utils/is-form-data.js';\nimport proxyEvents from './utils/proxy-events.js';\nimport timedOut, { TimeoutError as TimedOutTimeoutError } from './timed-out.js';\nimport urlToOptions from './utils/url-to-options.js';\nimport WeakableMap from './utils/weakable-map.js';\nimport calculateRetryDelay from './calculate-retry-delay.js';\nimport Options from './options.js';\nimport { isResponseOk } from './response.js';\nimport isClientRequest from './utils/is-client-request.js';\nimport { RequestError, ReadError, MaxRedirectsError, HTTPError, TimeoutError, UploadError, CacheError, } from './errors.js';\nconst supportsBrotli = is.string(process.versions.brotli);\nconst methodsWithoutBody = new Set(['GET', 'HEAD']);\nconst cacheableStore = new WeakableMap();\nconst redirectCodes = new Set([300, 301, 302, 303, 304, 307, 308]);\nconst proxiedRequestEvents = [\n    'socket',\n    'connect',\n    'continue',\n    'information',\n    'upgrade',\n];\nconst noop = () => { };\nexport default class Request extends Duplex {\n    constructor(url, options, defaults) {\n        super({\n            // Don't destroy immediately, as the error may be emitted on unsuccessful retry\n            autoDestroy: false,\n            // It needs to be zero because we're just proxying the data to another stream\n            highWaterMark: 0,\n        });\n        Object.defineProperty(this, 'constructor', {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_noPipe\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // @ts-expect-error https://github.com/microsoft/TypeScript/issues/9568\n        Object.defineProperty(this, \"options\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"response\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"requestUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"redirectUrls\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"retryCount\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_stopRetry\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_downloadedSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_uploadedSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_stopReading\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_pipedServerResponses\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_request\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_responseSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_bodySize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_unproxyEvents\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_isFromCache\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_cannotHaveBody\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_triggerRead\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_cancelTimeouts\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_nativeResponse\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_flushed\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_aborted\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // We need this because `this._request` if `undefined` when using cache\n        Object.defineProperty(this, \"_requestInitialized\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this._downloadedSize = 0;\n        this._uploadedSize = 0;\n        this._stopReading = false;\n        this._pipedServerResponses = new Set();\n        this._cannotHaveBody = false;\n        this._unproxyEvents = noop;\n        this._triggerRead = false;\n        this._cancelTimeouts = noop;\n        this._jobs = [];\n        this._flushed = false;\n        this._requestInitialized = false;\n        this._aborted = false;\n        this.redirectUrls = [];\n        this.retryCount = 0;\n        this._stopRetry = noop;\n        this.on('pipe', source => {\n            if (source.headers) {\n                Object.assign(this.options.headers, source.headers);\n            }\n        });\n        this.on('newListener', event => {\n            if (event === 'retry' && this.listenerCount('retry') > 0) {\n                throw new Error('A retry listener has been attached already.');\n            }\n        });\n        try {\n            this.options = new Options(url, options, defaults);\n            if (!this.options.url) {\n                if (this.options.prefixUrl === '') {\n                    throw new TypeError('Missing `url` property');\n                }\n                this.options.url = '';\n            }\n            this.requestUrl = this.options.url;\n        }\n        catch (error) {\n            const { options } = error;\n            if (options) {\n                this.options = options;\n            }\n            this.flush = async () => {\n                this.flush = async () => { };\n                this.destroy(error);\n            };\n            return;\n        }\n        // Important! If you replace `body` in a handler with another stream, make sure it's readable first.\n        // The below is run only once.\n        const { body } = this.options;\n        if (is.nodeStream(body)) {\n            body.once('error', error => {\n                if (this._flushed) {\n                    this._beforeError(new UploadError(error, this));\n                }\n                else {\n                    this.flush = async () => {\n                        this.flush = async () => { };\n                        this._beforeError(new UploadError(error, this));\n                    };\n                }\n            });\n        }\n    }\n    async flush() {\n        if (this._flushed) {\n            return;\n        }\n        this._flushed = true;\n        try {\n            await this._finalizeBody();\n            if (this.destroyed) {\n                return;\n            }\n            await this._makeRequest();\n            if (this.destroyed) {\n                this._request?.destroy();\n                return;\n            }\n            // Queued writes etc.\n            for (const job of this._jobs) {\n                job();\n            }\n            // Prevent memory leak\n            this._jobs.length = 0;\n            this._requestInitialized = true;\n        }\n        catch (error) {\n            this._beforeError(error);\n        }\n    }\n    _beforeError(error) {\n        if (this._stopReading) {\n            return;\n        }\n        const { response, options } = this;\n        const attemptCount = this.retryCount + (error.name === 'RetryError' ? 0 : 1);\n        this._stopReading = true;\n        if (!(error instanceof RequestError)) {\n            error = new RequestError(error.message, error, this);\n        }\n        const typedError = error;\n        void (async () => {\n            // Node.js parser is really weird.\n            // It emits post-request Parse Errors on the same instance as previous request. WTF.\n            // Therefore we need to check if it has been destroyed as well.\n            //\n            // Furthermore, Node.js 16 `response.destroy()` doesn't immediately destroy the socket,\n            // but makes the response unreadable. So we additionally need to check `response.readable`.\n            if (response?.readable && !response.rawBody && !this._request?.socket?.destroyed) {\n                // @types/node has incorrect typings. `setEncoding` accepts `null` as well.\n                response.setEncoding(this.readableEncoding);\n                const success = await this._setRawBody(response);\n                if (success) {\n                    response.body = response.rawBody.toString();\n                }\n            }\n            if (this.listenerCount('retry') !== 0) {\n                let backoff;\n                try {\n                    let retryAfter;\n                    if (response && 'retry-after' in response.headers) {\n                        retryAfter = Number(response.headers['retry-after']);\n                        if (Number.isNaN(retryAfter)) {\n                            retryAfter = Date.parse(response.headers['retry-after']) - Date.now();\n                            if (retryAfter <= 0) {\n                                retryAfter = 1;\n                            }\n                        }\n                        else {\n                            retryAfter *= 1000;\n                        }\n                    }\n                    const retryOptions = options.retry;\n                    backoff = await retryOptions.calculateDelay({\n                        attemptCount,\n                        retryOptions,\n                        error: typedError,\n                        retryAfter,\n                        computedValue: calculateRetryDelay({\n                            attemptCount,\n                            retryOptions,\n                            error: typedError,\n                            retryAfter,\n                            computedValue: retryOptions.maxRetryAfter ?? options.timeout.request ?? Number.POSITIVE_INFINITY,\n                        }),\n                    });\n                }\n                catch (error_) {\n                    void this._error(new RequestError(error_.message, error_, this));\n                    return;\n                }\n                if (backoff) {\n                    await new Promise(resolve => {\n                        const timeout = setTimeout(resolve, backoff);\n                        this._stopRetry = () => {\n                            clearTimeout(timeout);\n                            resolve();\n                        };\n                    });\n                    // Something forced us to abort the retry\n                    if (this.destroyed) {\n                        return;\n                    }\n                    try {\n                        for (const hook of this.options.hooks.beforeRetry) {\n                            // eslint-disable-next-line no-await-in-loop\n                            await hook(typedError, this.retryCount + 1);\n                        }\n                    }\n                    catch (error_) {\n                        void this._error(new RequestError(error_.message, error, this));\n                        return;\n                    }\n                    // Something forced us to abort the retry\n                    if (this.destroyed) {\n                        return;\n                    }\n                    this.destroy();\n                    this.emit('retry', this.retryCount + 1, error, (updatedOptions) => {\n                        const request = new Request(options.url, updatedOptions, options);\n                        request.retryCount = this.retryCount + 1;\n                        process.nextTick(() => {\n                            void request.flush();\n                        });\n                        return request;\n                    });\n                    return;\n                }\n            }\n            void this._error(typedError);\n        })();\n    }\n    _read() {\n        this._triggerRead = true;\n        const { response } = this;\n        if (response && !this._stopReading) {\n            // We cannot put this in the `if` above\n            // because `.read()` also triggers the `end` event\n            if (response.readableLength) {\n                this._triggerRead = false;\n            }\n            let data;\n            while ((data = response.read()) !== null) {\n                this._downloadedSize += data.length; // eslint-disable-line @typescript-eslint/restrict-plus-operands\n                const progress = this.downloadProgress;\n                if (progress.percent < 1) {\n                    this.emit('downloadProgress', progress);\n                }\n                this.push(data);\n            }\n        }\n    }\n    _write(chunk, encoding, callback) {\n        const write = () => {\n            this._writeRequest(chunk, encoding, callback);\n        };\n        if (this._requestInitialized) {\n            write();\n        }\n        else {\n            this._jobs.push(write);\n        }\n    }\n    _final(callback) {\n        const endRequest = () => {\n            // We need to check if `this._request` is present,\n            // because it isn't when we use cache.\n            if (!this._request || this._request.destroyed) {\n                callback();\n                return;\n            }\n            this._request.end((error) => {\n                // The request has been destroyed before `_final` finished.\n                // See https://github.com/nodejs/node/issues/39356\n                if (this._request._writableState?.errored) {\n                    return;\n                }\n                if (!error) {\n                    this._bodySize = this._uploadedSize;\n                    this.emit('uploadProgress', this.uploadProgress);\n                    this._request.emit('upload-complete');\n                }\n                callback(error);\n            });\n        };\n        if (this._requestInitialized) {\n            endRequest();\n        }\n        else {\n            this._jobs.push(endRequest);\n        }\n    }\n    _destroy(error, callback) {\n        this._stopReading = true;\n        this.flush = async () => { };\n        // Prevent further retries\n        this._stopRetry();\n        this._cancelTimeouts();\n        if (this.options) {\n            const { body } = this.options;\n            if (is.nodeStream(body)) {\n                body.destroy();\n            }\n        }\n        if (this._request) {\n            this._request.destroy();\n        }\n        if (error !== null && !is.undefined(error) && !(error instanceof RequestError)) {\n            error = new RequestError(error.message, error, this);\n        }\n        callback(error);\n    }\n    pipe(destination, options) {\n        if (destination instanceof ServerResponse) {\n            this._pipedServerResponses.add(destination);\n        }\n        return super.pipe(destination, options);\n    }\n    unpipe(destination) {\n        if (destination instanceof ServerResponse) {\n            this._pipedServerResponses.delete(destination);\n        }\n        super.unpipe(destination);\n        return this;\n    }\n    async _finalizeBody() {\n        const { options } = this;\n        const { headers } = options;\n        const isForm = !is.undefined(options.form);\n        // eslint-disable-next-line @typescript-eslint/naming-convention\n        const isJSON = !is.undefined(options.json);\n        const isBody = !is.undefined(options.body);\n        const cannotHaveBody = methodsWithoutBody.has(options.method) && !(options.method === 'GET' && options.allowGetBody);\n        this._cannotHaveBody = cannotHaveBody;\n        if (isForm || isJSON || isBody) {\n            if (cannotHaveBody) {\n                throw new TypeError(`The \\`${options.method}\\` method cannot be used with a body`);\n            }\n            // Serialize body\n            const noContentType = !is.string(headers['content-type']);\n            if (isBody) {\n                // Body is spec-compliant FormData\n                if (isFormDataLike(options.body)) {\n                    const encoder = new FormDataEncoder(options.body);\n                    if (noContentType) {\n                        headers['content-type'] = encoder.headers['Content-Type'];\n                    }\n                    headers['content-length'] = encoder.headers['Content-Length'];\n                    options.body = encoder.encode();\n                }\n                // Special case for https://github.com/form-data/form-data\n                if (isFormData(options.body) && noContentType) {\n                    headers['content-type'] = `multipart/form-data; boundary=${options.body.getBoundary()}`;\n                }\n            }\n            else if (isForm) {\n                if (noContentType) {\n                    headers['content-type'] = 'application/x-www-form-urlencoded';\n                }\n                const { form } = options;\n                options.form = undefined;\n                options.body = (new URLSearchParams(form)).toString();\n            }\n            else {\n                if (noContentType) {\n                    headers['content-type'] = 'application/json';\n                }\n                const { json } = options;\n                options.json = undefined;\n                options.body = options.stringifyJson(json);\n            }\n            const uploadBodySize = await getBodySize(options.body, options.headers);\n            // See https://tools.ietf.org/html/rfc7230#section-3.3.2\n            // A user agent SHOULD send a Content-Length in a request message when\n            // no Transfer-Encoding is sent and the request method defines a meaning\n            // for an enclosed payload body.  For example, a Content-Length header\n            // field is normally sent in a POST request even when the value is 0\n            // (indicating an empty payload body).  A user agent SHOULD NOT send a\n            // Content-Length header field when the request message does not contain\n            // a payload body and the method semantics do not anticipate such a\n            // body.\n            if (is.undefined(headers['content-length']) && is.undefined(headers['transfer-encoding']) && !cannotHaveBody && !is.undefined(uploadBodySize)) {\n                headers['content-length'] = String(uploadBodySize);\n            }\n        }\n        if (options.responseType === 'json' && !('accept' in options.headers)) {\n            options.headers.accept = 'application/json';\n        }\n        this._bodySize = Number(headers['content-length']) || undefined;\n    }\n    async _onResponseBase(response) {\n        // This will be called e.g. when using cache so we need to check if this request has been aborted.\n        if (this.isAborted) {\n            return;\n        }\n        const { options } = this;\n        const { url } = options;\n        this._nativeResponse = response;\n        if (options.decompress) {\n            response = decompressResponse(response);\n        }\n        const statusCode = response.statusCode;\n        const typedResponse = response;\n        typedResponse.statusMessage = typedResponse.statusMessage ? typedResponse.statusMessage : http.STATUS_CODES[statusCode];\n        typedResponse.url = options.url.toString();\n        typedResponse.requestUrl = this.requestUrl;\n        typedResponse.redirectUrls = this.redirectUrls;\n        typedResponse.request = this;\n        typedResponse.isFromCache = this._nativeResponse.fromCache ?? false;\n        typedResponse.ip = this.ip;\n        typedResponse.retryCount = this.retryCount;\n        this._isFromCache = typedResponse.isFromCache;\n        this._responseSize = Number(response.headers['content-length']) || undefined;\n        this.response = typedResponse;\n        response.once('end', () => {\n            this._responseSize = this._downloadedSize;\n            this.emit('downloadProgress', this.downloadProgress);\n        });\n        response.once('error', (error) => {\n            this._aborted = true;\n            // Force clean-up, because some packages don't do this.\n            // TODO: Fix decompress-response\n            response.destroy();\n            this._beforeError(new ReadError(error, this));\n        });\n        response.once('aborted', () => {\n            this._aborted = true;\n            this._beforeError(new ReadError({\n                name: 'Error',\n                message: 'The server aborted pending request',\n                code: 'ECONNRESET',\n            }, this));\n        });\n        this.emit('downloadProgress', this.downloadProgress);\n        const rawCookies = response.headers['set-cookie'];\n        if (is.object(options.cookieJar) && rawCookies) {\n            let promises = rawCookies.map(async (rawCookie) => options.cookieJar.setCookie(rawCookie, url.toString()));\n            if (options.ignoreInvalidCookies) {\n                promises = promises.map(async (promise) => {\n                    try {\n                        await promise;\n                    }\n                    catch { }\n                });\n            }\n            try {\n                await Promise.all(promises);\n            }\n            catch (error) {\n                this._beforeError(error);\n                return;\n            }\n        }\n        // The above is running a promise, therefore we need to check if this request has been aborted yet again.\n        if (this.isAborted) {\n            return;\n        }\n        if (options.followRedirect && response.headers.location && redirectCodes.has(statusCode)) {\n            // We're being redirected, we don't care about the response.\n            // It'd be best to abort the request, but we can't because\n            // we would have to sacrifice the TCP connection. We don't want that.\n            response.resume();\n            this._cancelTimeouts();\n            this._unproxyEvents();\n            if (this.redirectUrls.length >= options.maxRedirects) {\n                this._beforeError(new MaxRedirectsError(this));\n                return;\n            }\n            this._request = undefined;\n            const updatedOptions = new Options(undefined, undefined, this.options);\n            const shouldBeGet = statusCode === 303 && updatedOptions.method !== 'GET' && updatedOptions.method !== 'HEAD';\n            if (shouldBeGet || updatedOptions.methodRewriting) {\n                // Server responded with \"see other\", indicating that the resource exists at another location,\n                // and the client should request it from that location via GET or HEAD.\n                updatedOptions.method = 'GET';\n                updatedOptions.body = undefined;\n                updatedOptions.json = undefined;\n                updatedOptions.form = undefined;\n                delete updatedOptions.headers['content-length'];\n            }\n            try {\n                // We need this in order to support UTF-8\n                const redirectBuffer = Buffer.from(response.headers.location, 'binary').toString();\n                const redirectUrl = new URL(redirectBuffer, url);\n                // Redirecting to a different site, clear sensitive data.\n                if (redirectUrl.hostname !== url.hostname || redirectUrl.port !== url.port) {\n                    if ('host' in updatedOptions.headers) {\n                        delete updatedOptions.headers.host;\n                    }\n                    if ('cookie' in updatedOptions.headers) {\n                        delete updatedOptions.headers.cookie;\n                    }\n                    if ('authorization' in updatedOptions.headers) {\n                        delete updatedOptions.headers.authorization;\n                    }\n                    if (updatedOptions.username || updatedOptions.password) {\n                        updatedOptions.username = '';\n                        updatedOptions.password = '';\n                    }\n                }\n                else {\n                    redirectUrl.username = updatedOptions.username;\n                    redirectUrl.password = updatedOptions.password;\n                }\n                this.redirectUrls.push(redirectUrl);\n                updatedOptions.prefixUrl = '';\n                updatedOptions.url = redirectUrl;\n                for (const hook of updatedOptions.hooks.beforeRedirect) {\n                    // eslint-disable-next-line no-await-in-loop\n                    await hook(updatedOptions, typedResponse);\n                }\n                this.emit('redirect', updatedOptions, typedResponse);\n                this.options = updatedOptions;\n                await this._makeRequest();\n            }\n            catch (error) {\n                this._beforeError(error);\n                return;\n            }\n            return;\n        }\n        if (options.isStream && options.throwHttpErrors && !isResponseOk(typedResponse)) {\n            this._beforeError(new HTTPError(typedResponse));\n            return;\n        }\n        response.on('readable', () => {\n            if (this._triggerRead) {\n                this._read();\n            }\n        });\n        this.on('resume', () => {\n            response.resume();\n        });\n        this.on('pause', () => {\n            response.pause();\n        });\n        response.once('end', () => {\n            this.push(null);\n        });\n        if (this._noPipe) {\n            const success = await this._setRawBody();\n            if (success) {\n                this.emit('response', response);\n            }\n            return;\n        }\n        this.emit('response', response);\n        for (const destination of this._pipedServerResponses) {\n            if (destination.headersSent) {\n                continue;\n            }\n            // eslint-disable-next-line guard-for-in\n            for (const key in response.headers) {\n                const isAllowed = options.decompress ? key !== 'content-encoding' : true;\n                const value = response.headers[key];\n                if (isAllowed) {\n                    destination.setHeader(key, value);\n                }\n            }\n            destination.statusCode = statusCode;\n        }\n    }\n    async _setRawBody(from = this) {\n        if (from.readableEnded) {\n            return false;\n        }\n        try {\n            // Errors are emitted via the `error` event\n            const rawBody = await getBuffer(from);\n            // On retry Request is destroyed with no error, therefore the above will successfully resolve.\n            // So in order to check if this was really successfull, we need to check if it has been properly ended.\n            if (!this.isAborted) {\n                this.response.rawBody = rawBody;\n                return true;\n            }\n        }\n        catch { }\n        return false;\n    }\n    async _onResponse(response) {\n        try {\n            await this._onResponseBase(response);\n        }\n        catch (error) {\n            /* istanbul ignore next: better safe than sorry */\n            this._beforeError(error);\n        }\n    }\n    _onRequest(request) {\n        const { options } = this;\n        const { timeout, url } = options;\n        timer(request);\n        if (this.options.http2) {\n            // Unset stream timeout, as the `timeout` option was used only for connection timeout.\n            request.setTimeout(0);\n        }\n        this._cancelTimeouts = timedOut(request, timeout, url);\n        const responseEventName = options.cache ? 'cacheableResponse' : 'response';\n        request.once(responseEventName, (response) => {\n            void this._onResponse(response);\n        });\n        request.once('error', (error) => {\n            this._aborted = true;\n            // Force clean-up, because some packages (e.g. nock) don't do this.\n            request.destroy();\n            error = error instanceof TimedOutTimeoutError ? new TimeoutError(error, this.timings, this) : new RequestError(error.message, error, this);\n            this._beforeError(error);\n        });\n        this._unproxyEvents = proxyEvents(request, this, proxiedRequestEvents);\n        this._request = request;\n        this.emit('uploadProgress', this.uploadProgress);\n        this._sendBody();\n        this.emit('request', request);\n    }\n    async _asyncWrite(chunk) {\n        return new Promise((resolve, reject) => {\n            super.write(chunk, error => {\n                if (error) {\n                    reject(error);\n                    return;\n                }\n                resolve();\n            });\n        });\n    }\n    _sendBody() {\n        // Send body\n        const { body } = this.options;\n        const currentRequest = this.redirectUrls.length === 0 ? this : this._request ?? this;\n        if (is.nodeStream(body)) {\n            body.pipe(currentRequest);\n        }\n        else if (is.generator(body) || is.asyncGenerator(body)) {\n            (async () => {\n                try {\n                    for await (const chunk of body) {\n                        await this._asyncWrite(chunk);\n                    }\n                    super.end();\n                }\n                catch (error) {\n                    this._beforeError(error);\n                }\n            })();\n        }\n        else if (!is.undefined(body)) {\n            this._writeRequest(body, undefined, () => { });\n            currentRequest.end();\n        }\n        else if (this._cannotHaveBody || this._noPipe) {\n            currentRequest.end();\n        }\n    }\n    _prepareCache(cache) {\n        if (!cacheableStore.has(cache)) {\n            cacheableStore.set(cache, new CacheableRequest(((requestOptions, handler) => {\n                const result = requestOptions._request(requestOptions, handler);\n                // TODO: remove this when `cacheable-request` supports async request functions.\n                if (is.promise(result)) {\n                    // We only need to implement the error handler in order to support HTTP2 caching.\n                    // The result will be a promise anyway.\n                    // @ts-expect-error ignore\n                    // eslint-disable-next-line @typescript-eslint/promise-function-async\n                    result.once = (event, handler) => {\n                        if (event === 'error') {\n                            (async () => {\n                                try {\n                                    await result;\n                                }\n                                catch (error) {\n                                    handler(error);\n                                }\n                            })();\n                        }\n                        else if (event === 'abort') {\n                            // The empty catch is needed here in case when\n                            // it rejects before it's `await`ed in `_makeRequest`.\n                            (async () => {\n                                try {\n                                    const request = (await result);\n                                    request.once('abort', handler);\n                                }\n                                catch { }\n                            })();\n                        }\n                        else {\n                            /* istanbul ignore next: safety check */\n                            throw new Error(`Unknown HTTP2 promise event: ${event}`);\n                        }\n                        return result;\n                    };\n                }\n                return result;\n            }), cache));\n        }\n    }\n    async _createCacheableRequest(url, options) {\n        return new Promise((resolve, reject) => {\n            // TODO: Remove `utils/url-to-options.ts` when `cacheable-request` is fixed\n            Object.assign(options, urlToOptions(url));\n            let request;\n            // TODO: Fix `cacheable-response`. This is ugly.\n            const cacheRequest = cacheableStore.get(options.cache)(options, async (response) => {\n                response._readableState.autoDestroy = false;\n                if (request) {\n                    const fix = () => {\n                        if (response.req) {\n                            response.complete = response.req.res.complete;\n                        }\n                    };\n                    response.prependOnceListener('end', fix);\n                    fix();\n                    (await request).emit('cacheableResponse', response);\n                }\n                resolve(response);\n            });\n            cacheRequest.once('error', reject);\n            cacheRequest.once('request', async (requestOrPromise) => {\n                request = requestOrPromise;\n                resolve(request);\n            });\n        });\n    }\n    async _makeRequest() {\n        const { options } = this;\n        const { headers, username, password } = options;\n        const cookieJar = options.cookieJar;\n        for (const key in headers) {\n            if (is.undefined(headers[key])) {\n                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n                delete headers[key];\n            }\n            else if (is.null_(headers[key])) {\n                throw new TypeError(`Use \\`undefined\\` instead of \\`null\\` to delete the \\`${key}\\` header`);\n            }\n        }\n        if (options.decompress && is.undefined(headers['accept-encoding'])) {\n            headers['accept-encoding'] = supportsBrotli ? 'gzip, deflate, br' : 'gzip, deflate';\n        }\n        if (username || password) {\n            const credentials = Buffer.from(`${username}:${password}`).toString('base64');\n            headers.authorization = `Basic ${credentials}`;\n        }\n        // Set cookies\n        if (cookieJar) {\n            const cookieString = await cookieJar.getCookieString(options.url.toString());\n            if (is.nonEmptyString(cookieString)) {\n                headers.cookie = cookieString;\n            }\n        }\n        // Reset `prefixUrl`\n        options.prefixUrl = '';\n        let request;\n        for (const hook of options.hooks.beforeRequest) {\n            // eslint-disable-next-line no-await-in-loop\n            const result = await hook(options);\n            if (!is.undefined(result)) {\n                // @ts-expect-error Skip the type mismatch to support abstract responses\n                request = () => result;\n                break;\n            }\n        }\n        if (!request) {\n            request = options.getRequestFunction();\n        }\n        const url = options.url;\n        this._requestOptions = options.createNativeRequestOptions();\n        if (options.cache) {\n            this._requestOptions._request = request;\n            this._requestOptions.cache = options.cache;\n            this._prepareCache(options.cache);\n        }\n        // Cache support\n        const fn = options.cache ? this._createCacheableRequest : request;\n        try {\n            // We can't do `await fn(...)`,\n            // because stream `error` event can be emitted before `Promise.resolve()`.\n            let requestOrResponse = fn(url, this._requestOptions);\n            if (is.promise(requestOrResponse)) {\n                requestOrResponse = await requestOrResponse;\n            }\n            // Fallback\n            if (is.undefined(requestOrResponse)) {\n                requestOrResponse = options.getFallbackRequestFunction()(url, this._requestOptions);\n                if (is.promise(requestOrResponse)) {\n                    requestOrResponse = await requestOrResponse;\n                }\n            }\n            if (isClientRequest(requestOrResponse)) {\n                this._onRequest(requestOrResponse);\n            }\n            else if (this.writable) {\n                this.once('finish', () => {\n                    void this._onResponse(requestOrResponse);\n                });\n                this._sendBody();\n            }\n            else {\n                void this._onResponse(requestOrResponse);\n            }\n        }\n        catch (error) {\n            if (error instanceof CacheableRequest.CacheError) {\n                throw new CacheError(error, this);\n            }\n            throw error;\n        }\n    }\n    async _error(error) {\n        try {\n            for (const hook of this.options.hooks.beforeError) {\n                // eslint-disable-next-line no-await-in-loop\n                error = await hook(error);\n            }\n        }\n        catch (error_) {\n            error = new RequestError(error_.message, error_, this);\n        }\n        this.destroy(error);\n    }\n    _writeRequest(chunk, encoding, callback) {\n        if (!this._request || this._request.destroyed) {\n            // Probably the `ClientRequest` instance will throw\n            return;\n        }\n        this._request.write(chunk, encoding, (error) => {\n            if (!error) {\n                this._uploadedSize += Buffer.byteLength(chunk, encoding);\n                const progress = this.uploadProgress;\n                if (progress.percent < 1) {\n                    this.emit('uploadProgress', progress);\n                }\n            }\n            callback(error);\n        });\n    }\n    /**\n    The remote IP address.\n    */\n    get ip() {\n        return this.socket?.remoteAddress;\n    }\n    /**\n    Indicates whether the request has been aborted or not.\n    */\n    get isAborted() {\n        return this._aborted;\n    }\n    get socket() {\n        return this._request?.socket ?? undefined;\n    }\n    /**\n    Progress event for downloading (receiving a response).\n    */\n    get downloadProgress() {\n        let percent;\n        if (this._responseSize) {\n            percent = this._downloadedSize / this._responseSize;\n        }\n        else if (this._responseSize === this._downloadedSize) {\n            percent = 1;\n        }\n        else {\n            percent = 0;\n        }\n        return {\n            percent,\n            transferred: this._downloadedSize,\n            total: this._responseSize,\n        };\n    }\n    /**\n    Progress event for uploading (sending a request).\n    */\n    get uploadProgress() {\n        let percent;\n        if (this._bodySize) {\n            percent = this._uploadedSize / this._bodySize;\n        }\n        else if (this._bodySize === this._uploadedSize) {\n            percent = 1;\n        }\n        else {\n            percent = 0;\n        }\n        return {\n            percent,\n            transferred: this._uploadedSize,\n            total: this._bodySize,\n        };\n    }\n    /**\n    The object contains the following properties:\n\n    - `start` - Time when the request started.\n    - `socket` - Time when a socket was assigned to the request.\n    - `lookup` - Time when the DNS lookup finished.\n    - `connect` - Time when the socket successfully connected.\n    - `secureConnect` - Time when the socket securely connected.\n    - `upload` - Time when the request finished uploading.\n    - `response` - Time when the request fired `response` event.\n    - `end` - Time when the response fired `end` event.\n    - `error` - Time when the request fired `error` event.\n    - `abort` - Time when the request fired `abort` event.\n    - `phases`\n        - `wait` - `timings.socket - timings.start`\n        - `dns` - `timings.lookup - timings.socket`\n        - `tcp` - `timings.connect - timings.lookup`\n        - `tls` - `timings.secureConnect - timings.connect`\n        - `request` - `timings.upload - (timings.secureConnect || timings.connect)`\n        - `firstByte` - `timings.response - timings.upload`\n        - `download` - `timings.end - timings.response`\n        - `total` - `(timings.end || timings.error || timings.abort) - timings.start`\n\n    If something has not been measured yet, it will be `undefined`.\n\n    __Note__: The time is a `number` representing the milliseconds elapsed since the UNIX epoch.\n    */\n    get timings() {\n        return this._request?.timings;\n    }\n    /**\n    Whether the response was retrieved from the cache.\n    */\n    get isFromCache() {\n        return this._isFromCache;\n    }\n    get reusedSocket() {\n        return this._request?.reusedSocket;\n    }\n}\n"],"mappings":";AAAA,OAAOA,OAAP,MAAoB,cAApB;AACA,SAASC,MAAT,QAAuB,aAAvB;AACA,SAASC,MAAT,QAAuB,aAAvB;AACA,SAASC,GAAT,EAAcC,eAAd,QAAqC,UAArC;AACA,OAAOC,IAAP,IAAeC,cAAf,QAAqC,WAArC;AACA,OAAOC,KAAP,MAAkB,uBAAlB;AACA,OAAOC,gBAAP,MAA6B,mBAA7B;AACA,OAAOC,kBAAP,MAA+B,qBAA/B;AACA,OAAOC,EAAP,MAAe,kBAAf;AACA,SAASC,MAAM,IAAIC,SAAnB,QAAoC,YAApC;AACA,SAASC,eAAT,EAA0BC,cAA1B,QAAgD,mBAAhD;AACA,OAAOC,WAAP,MAAwB,0BAAxB;AACA,OAAOC,UAAP,MAAuB,yBAAvB;AACA,OAAOC,WAAP,MAAwB,yBAAxB;AACA,OAAOC,QAAP,IAAmBC,YAAY,IAAIC,oBAAnC,QAA+D,gBAA/D;AACA,OAAOC,YAAP,MAAyB,2BAAzB;AACA,OAAOC,WAAP,MAAwB,yBAAxB;AACA,OAAOC,mBAAP,MAAgC,4BAAhC;AACA,OAAOC,OAAP,MAAoB,cAApB;AACA,SAASC,YAAT,QAA6B,eAA7B;AACA,OAAOC,eAAP,MAA4B,8BAA5B;AACA,SAASC,YAAT,EAAuBC,SAAvB,EAAkCC,iBAAlC,EAAqDC,SAArD,EAAgEX,YAAhE,EAA8EY,WAA9E,EAA2FC,UAA3F,QAA8G,aAA9G;AACA,MAAMC,cAAc,GAAGvB,EAAE,CAACwB,MAAH,CAAUlC,OAAO,CAACmC,QAAR,CAAiBC,MAA3B,CAAvB;AACA,MAAMC,kBAAkB,GAAG,IAAIC,GAAJ,CAAQ,CAAC,KAAD,EAAQ,MAAR,CAAR,CAA3B;AACA,MAAMC,cAAc,GAAG,IAAIjB,WAAJ,EAAvB;AACA,MAAMkB,aAAa,GAAG,IAAIF,GAAJ,CAAQ,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,EAAgB,GAAhB,EAAqB,GAArB,EAA0B,GAA1B,EAA+B,GAA/B,CAAR,CAAtB;AACA,MAAMG,oBAAoB,GAAG,CACzB,QADyB,EAEzB,SAFyB,EAGzB,UAHyB,EAIzB,aAJyB,EAKzB,SALyB,CAA7B;;AAOA,MAAMC,IAAI,GAAG,MAAM,CAAG,CAAtB;;AACA,eAAe,MAAMC,OAAN,SAAsBzC,MAAtB,CAA6B;EACxC0C,WAAW,CAACC,GAAD,EAAMC,OAAN,EAAeC,QAAf,EAAyB;IAChC,MAAM;MACF;MACAC,WAAW,EAAE,KAFX;MAGF;MACAC,aAAa,EAAE;IAJb,CAAN;IAMAC,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,aAA5B,EAA2C;MACvCC,UAAU,EAAE,IAD2B;MAEvCC,YAAY,EAAE,IAFyB;MAGvCC,QAAQ,EAAE,IAH6B;MAIvCC,KAAK,EAAE,KAAK;IAJ2B,CAA3C;IAMAL,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,SAA5B,EAAuC;MACnCC,UAAU,EAAE,IADuB;MAEnCC,YAAY,EAAE,IAFqB;MAGnCC,QAAQ,EAAE,IAHyB;MAInCC,KAAK,EAAE,KAAK;IAJuB,CAAvC,EAbgC,CAmBhC;;IACAL,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,SAA5B,EAAuC;MACnCC,UAAU,EAAE,IADuB;MAEnCC,YAAY,EAAE,IAFqB;MAGnCC,QAAQ,EAAE,IAHyB;MAInCC,KAAK,EAAE,KAAK;IAJuB,CAAvC;IAMAL,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,UAA5B,EAAwC;MACpCC,UAAU,EAAE,IADwB;MAEpCC,YAAY,EAAE,IAFsB;MAGpCC,QAAQ,EAAE,IAH0B;MAIpCC,KAAK,EAAE,KAAK;IAJwB,CAAxC;IAMAL,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,YAA5B,EAA0C;MACtCC,UAAU,EAAE,IAD0B;MAEtCC,YAAY,EAAE,IAFwB;MAGtCC,QAAQ,EAAE,IAH4B;MAItCC,KAAK,EAAE,KAAK;IAJ0B,CAA1C;IAMAL,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,cAA5B,EAA4C;MACxCC,UAAU,EAAE,IAD4B;MAExCC,YAAY,EAAE,IAF0B;MAGxCC,QAAQ,EAAE,IAH8B;MAIxCC,KAAK,EAAE,KAAK;IAJ4B,CAA5C;IAMAL,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,YAA5B,EAA0C;MACtCC,UAAU,EAAE,IAD0B;MAEtCC,YAAY,EAAE,IAFwB;MAGtCC,QAAQ,EAAE,IAH4B;MAItCC,KAAK,EAAE,KAAK;IAJ0B,CAA1C;IAMAL,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,YAA5B,EAA0C;MACtCC,UAAU,EAAE,IAD0B;MAEtCC,YAAY,EAAE,IAFwB;MAGtCC,QAAQ,EAAE,IAH4B;MAItCC,KAAK,EAAE,KAAK;IAJ0B,CAA1C;IAMAL,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,iBAA5B,EAA+C;MAC3CC,UAAU,EAAE,IAD+B;MAE3CC,YAAY,EAAE,IAF6B;MAG3CC,QAAQ,EAAE,IAHiC;MAI3CC,KAAK,EAAE,KAAK;IAJ+B,CAA/C;IAMAL,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,eAA5B,EAA6C;MACzCC,UAAU,EAAE,IAD6B;MAEzCC,YAAY,EAAE,IAF2B;MAGzCC,QAAQ,EAAE,IAH+B;MAIzCC,KAAK,EAAE,KAAK;IAJ6B,CAA7C;IAMAL,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,cAA5B,EAA4C;MACxCC,UAAU,EAAE,IAD4B;MAExCC,YAAY,EAAE,IAF0B;MAGxCC,QAAQ,EAAE,IAH8B;MAIxCC,KAAK,EAAE,KAAK;IAJ4B,CAA5C;IAMAL,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,uBAA5B,EAAqD;MACjDC,UAAU,EAAE,IADqC;MAEjDC,YAAY,EAAE,IAFmC;MAGjDC,QAAQ,EAAE,IAHuC;MAIjDC,KAAK,EAAE,KAAK;IAJqC,CAArD;IAMAL,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,UAA5B,EAAwC;MACpCC,UAAU,EAAE,IADwB;MAEpCC,YAAY,EAAE,IAFsB;MAGpCC,QAAQ,EAAE,IAH0B;MAIpCC,KAAK,EAAE,KAAK;IAJwB,CAAxC;IAMAL,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,eAA5B,EAA6C;MACzCC,UAAU,EAAE,IAD6B;MAEzCC,YAAY,EAAE,IAF2B;MAGzCC,QAAQ,EAAE,IAH+B;MAIzCC,KAAK,EAAE,KAAK;IAJ6B,CAA7C;IAMAL,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,WAA5B,EAAyC;MACrCC,UAAU,EAAE,IADyB;MAErCC,YAAY,EAAE,IAFuB;MAGrCC,QAAQ,EAAE,IAH2B;MAIrCC,KAAK,EAAE,KAAK;IAJyB,CAAzC;IAMAL,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,gBAA5B,EAA8C;MAC1CC,UAAU,EAAE,IAD8B;MAE1CC,YAAY,EAAE,IAF4B;MAG1CC,QAAQ,EAAE,IAHgC;MAI1CC,KAAK,EAAE,KAAK;IAJ8B,CAA9C;IAMAL,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,cAA5B,EAA4C;MACxCC,UAAU,EAAE,IAD4B;MAExCC,YAAY,EAAE,IAF0B;MAGxCC,QAAQ,EAAE,IAH8B;MAIxCC,KAAK,EAAE,KAAK;IAJ4B,CAA5C;IAMAL,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,iBAA5B,EAA+C;MAC3CC,UAAU,EAAE,IAD+B;MAE3CC,YAAY,EAAE,IAF6B;MAG3CC,QAAQ,EAAE,IAHiC;MAI3CC,KAAK,EAAE,KAAK;IAJ+B,CAA/C;IAMAL,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,cAA5B,EAA4C;MACxCC,UAAU,EAAE,IAD4B;MAExCC,YAAY,EAAE,IAF0B;MAGxCC,QAAQ,EAAE,IAH8B;MAIxCC,KAAK,EAAE,KAAK;IAJ4B,CAA5C;IAMAL,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,iBAA5B,EAA+C;MAC3CC,UAAU,EAAE,IAD+B;MAE3CC,YAAY,EAAE,IAF6B;MAG3CC,QAAQ,EAAE,IAHiC;MAI3CC,KAAK,EAAE,KAAK;IAJ+B,CAA/C;IAMAL,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,iBAA5B,EAA+C;MAC3CC,UAAU,EAAE,IAD+B;MAE3CC,YAAY,EAAE,IAF6B;MAG3CC,QAAQ,EAAE,IAHiC;MAI3CC,KAAK,EAAE,KAAK;IAJ+B,CAA/C;IAMAL,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,UAA5B,EAAwC;MACpCC,UAAU,EAAE,IADwB;MAEpCC,YAAY,EAAE,IAFsB;MAGpCC,QAAQ,EAAE,IAH0B;MAIpCC,KAAK,EAAE,KAAK;IAJwB,CAAxC;IAMAL,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,UAA5B,EAAwC;MACpCC,UAAU,EAAE,IADwB;MAEpCC,YAAY,EAAE,IAFsB;MAGpCC,QAAQ,EAAE,IAH0B;MAIpCC,KAAK,EAAE,KAAK;IAJwB,CAAxC,EA5IgC,CAkJhC;;IACAL,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,qBAA5B,EAAmD;MAC/CC,UAAU,EAAE,IADmC;MAE/CC,YAAY,EAAE,IAFiC;MAG/CC,QAAQ,EAAE,IAHqC;MAI/CC,KAAK,EAAE,KAAK;IAJmC,CAAnD;IAMA,KAAKC,eAAL,GAAuB,CAAvB;IACA,KAAKC,aAAL,GAAqB,CAArB;IACA,KAAKC,YAAL,GAAoB,KAApB;IACA,KAAKC,qBAAL,GAA6B,IAAIrB,GAAJ,EAA7B;IACA,KAAKsB,eAAL,GAAuB,KAAvB;IACA,KAAKC,cAAL,GAAsBnB,IAAtB;IACA,KAAKoB,YAAL,GAAoB,KAApB;IACA,KAAKC,eAAL,GAAuBrB,IAAvB;IACA,KAAKsB,KAAL,GAAa,EAAb;IACA,KAAKC,QAAL,GAAgB,KAAhB;IACA,KAAKC,mBAAL,GAA2B,KAA3B;IACA,KAAKC,QAAL,GAAgB,KAAhB;IACA,KAAKC,YAAL,GAAoB,EAApB;IACA,KAAKC,UAAL,GAAkB,CAAlB;IACA,KAAKC,UAAL,GAAkB5B,IAAlB;IACA,KAAK6B,EAAL,CAAQ,MAAR,EAAgBC,MAAM,IAAI;MACtB,IAAIA,MAAM,CAACC,OAAX,EAAoB;QAChBvB,MAAM,CAACwB,MAAP,CAAc,KAAK5B,OAAL,CAAa2B,OAA3B,EAAoCD,MAAM,CAACC,OAA3C;MACH;IACJ,CAJD;IAKA,KAAKF,EAAL,CAAQ,aAAR,EAAuBI,KAAK,IAAI;MAC5B,IAAIA,KAAK,KAAK,OAAV,IAAqB,KAAKC,aAAL,CAAmB,OAAnB,IAA8B,CAAvD,EAA0D;QACtD,MAAM,IAAIC,KAAJ,CAAU,6CAAV,CAAN;MACH;IACJ,CAJD;;IAKA,IAAI;MACA,KAAK/B,OAAL,GAAe,IAAItB,OAAJ,CAAYqB,GAAZ,EAAiBC,OAAjB,EAA0BC,QAA1B,CAAf;;MACA,IAAI,CAAC,KAAKD,OAAL,CAAaD,GAAlB,EAAuB;QACnB,IAAI,KAAKC,OAAL,CAAagC,SAAb,KAA2B,EAA/B,EAAmC;UAC/B,MAAM,IAAIC,SAAJ,CAAc,wBAAd,CAAN;QACH;;QACD,KAAKjC,OAAL,CAAaD,GAAb,GAAmB,EAAnB;MACH;;MACD,KAAKmC,UAAL,GAAkB,KAAKlC,OAAL,CAAaD,GAA/B;IACH,CATD,CAUA,OAAOoC,KAAP,EAAc;MACV,MAAM;QAAEnC;MAAF,IAAcmC,KAApB;;MACA,IAAInC,OAAJ,EAAa;QACT,KAAKA,OAAL,GAAeA,OAAf;MACH;;MACD,KAAKoC,KAAL,GAAa,YAAY;QACrB,KAAKA,KAAL,GAAa,YAAY,CAAG,CAA5B;;QACA,KAAKC,OAAL,CAAaF,KAAb;MACH,CAHD;;MAIA;IACH,CAtM+B,CAuMhC;IACA;;;IACA,MAAM;MAAEG;IAAF,IAAW,KAAKtC,OAAtB;;IACA,IAAIpC,EAAE,CAAC2E,UAAH,CAAcD,IAAd,CAAJ,EAAyB;MACrBA,IAAI,CAACE,IAAL,CAAU,OAAV,EAAmBL,KAAK,IAAI;QACxB,IAAI,KAAKhB,QAAT,EAAmB;UACf,KAAKsB,YAAL,CAAkB,IAAIxD,WAAJ,CAAgBkD,KAAhB,EAAuB,IAAvB,CAAlB;QACH,CAFD,MAGK;UACD,KAAKC,KAAL,GAAa,YAAY;YACrB,KAAKA,KAAL,GAAa,YAAY,CAAG,CAA5B;;YACA,KAAKK,YAAL,CAAkB,IAAIxD,WAAJ,CAAgBkD,KAAhB,EAAuB,IAAvB,CAAlB;UACH,CAHD;QAIH;MACJ,CAVD;IAWH;EACJ;;EACU,MAALC,KAAK,GAAG;IACV,IAAI,KAAKjB,QAAT,EAAmB;MACf;IACH;;IACD,KAAKA,QAAL,GAAgB,IAAhB;;IACA,IAAI;MACA,MAAM,KAAKuB,aAAL,EAAN;;MACA,IAAI,KAAKC,SAAT,EAAoB;QAChB;MACH;;MACD,MAAM,KAAKC,YAAL,EAAN;;MACA,IAAI,KAAKD,SAAT,EAAoB;QAChB,KAAKE,QAAL,EAAeR,OAAf;QACA;MACH,CATD,CAUA;;;MACA,KAAK,MAAMS,GAAX,IAAkB,KAAK5B,KAAvB,EAA8B;QAC1B4B,GAAG;MACN,CAbD,CAcA;;;MACA,KAAK5B,KAAL,CAAW6B,MAAX,GAAoB,CAApB;MACA,KAAK3B,mBAAL,GAA2B,IAA3B;IACH,CAjBD,CAkBA,OAAOe,KAAP,EAAc;MACV,KAAKM,YAAL,CAAkBN,KAAlB;IACH;EACJ;;EACDM,YAAY,CAACN,KAAD,EAAQ;IAChB,IAAI,KAAKvB,YAAT,EAAuB;MACnB;IACH;;IACD,MAAM;MAAEoC,QAAF;MAAYhD;IAAZ,IAAwB,IAA9B;IACA,MAAMiD,YAAY,GAAG,KAAK1B,UAAL,IAAmBY,KAAK,CAACe,IAAN,KAAe,YAAf,GAA8B,CAA9B,GAAkC,CAArD,CAArB;IACA,KAAKtC,YAAL,GAAoB,IAApB;;IACA,IAAI,EAAEuB,KAAK,YAAYtD,YAAnB,CAAJ,EAAsC;MAClCsD,KAAK,GAAG,IAAItD,YAAJ,CAAiBsD,KAAK,CAACgB,OAAvB,EAAgChB,KAAhC,EAAuC,IAAvC,CAAR;IACH;;IACD,MAAMiB,UAAU,GAAGjB,KAAnB;IACA,KAAK,CAAC,YAAY;MACd;MACA;MACA;MACA;MACA;MACA;MACA,IAAIa,QAAQ,EAAEK,QAAV,IAAsB,CAACL,QAAQ,CAACM,OAAhC,IAA2C,CAAC,KAAKT,QAAL,EAAeU,MAAf,EAAuBZ,SAAvE,EAAkF;QAC9E;QACAK,QAAQ,CAACQ,WAAT,CAAqB,KAAKC,gBAA1B;QACA,MAAMC,OAAO,GAAG,MAAM,KAAKC,WAAL,CAAiBX,QAAjB,CAAtB;;QACA,IAAIU,OAAJ,EAAa;UACTV,QAAQ,CAACV,IAAT,GAAgBU,QAAQ,CAACM,OAAT,CAAiBM,QAAjB,EAAhB;QACH;MACJ;;MACD,IAAI,KAAK9B,aAAL,CAAmB,OAAnB,MAAgC,CAApC,EAAuC;QACnC,IAAI+B,OAAJ;;QACA,IAAI;UACA,IAAIC,UAAJ;;UACA,IAAId,QAAQ,IAAI,iBAAiBA,QAAQ,CAACrB,OAA1C,EAAmD;YAC/CmC,UAAU,GAAGC,MAAM,CAACf,QAAQ,CAACrB,OAAT,CAAiB,aAAjB,CAAD,CAAnB;;YACA,IAAIoC,MAAM,CAACC,KAAP,CAAaF,UAAb,CAAJ,EAA8B;cAC1BA,UAAU,GAAGG,IAAI,CAACC,KAAL,CAAWlB,QAAQ,CAACrB,OAAT,CAAiB,aAAjB,CAAX,IAA8CsC,IAAI,CAACE,GAAL,EAA3D;;cACA,IAAIL,UAAU,IAAI,CAAlB,EAAqB;gBACjBA,UAAU,GAAG,CAAb;cACH;YACJ,CALD,MAMK;cACDA,UAAU,IAAI,IAAd;YACH;UACJ;;UACD,MAAMM,YAAY,GAAGpE,OAAO,CAACqE,KAA7B;UACAR,OAAO,GAAG,MAAMO,YAAY,CAACE,cAAb,CAA4B;YACxCrB,YADwC;YAExCmB,YAFwC;YAGxCjC,KAAK,EAAEiB,UAHiC;YAIxCU,UAJwC;YAKxCS,aAAa,EAAE9F,mBAAmB,CAAC;cAC/BwE,YAD+B;cAE/BmB,YAF+B;cAG/BjC,KAAK,EAAEiB,UAHwB;cAI/BU,UAJ+B;cAK/BS,aAAa,EAAEH,YAAY,CAACI,aAAb,IAA8BxE,OAAO,CAACyE,OAAR,CAAgBC,OAA9C,IAAyDX,MAAM,CAACY;YALhD,CAAD;UALM,CAA5B,CAAhB;QAaH,CA5BD,CA6BA,OAAOC,MAAP,EAAe;UACX,KAAK,KAAKC,MAAL,CAAY,IAAIhG,YAAJ,CAAiB+F,MAAM,CAACzB,OAAxB,EAAiCyB,MAAjC,EAAyC,IAAzC,CAAZ,CAAL;UACA;QACH;;QACD,IAAIf,OAAJ,EAAa;UACT,MAAM,IAAIiB,OAAJ,CAAYC,OAAO,IAAI;YACzB,MAAMN,OAAO,GAAGO,UAAU,CAACD,OAAD,EAAUlB,OAAV,CAA1B;;YACA,KAAKrC,UAAL,GAAkB,MAAM;cACpByD,YAAY,CAACR,OAAD,CAAZ;cACAM,OAAO;YACV,CAHD;UAIH,CANK,CAAN,CADS,CAQT;;UACA,IAAI,KAAKpC,SAAT,EAAoB;YAChB;UACH;;UACD,IAAI;YACA,KAAK,MAAMuC,IAAX,IAAmB,KAAKlF,OAAL,CAAamF,KAAb,CAAmBC,WAAtC,EAAmD;cAC/C;cACA,MAAMF,IAAI,CAAC9B,UAAD,EAAa,KAAK7B,UAAL,GAAkB,CAA/B,CAAV;YACH;UACJ,CALD,CAMA,OAAOqD,MAAP,EAAe;YACX,KAAK,KAAKC,MAAL,CAAY,IAAIhG,YAAJ,CAAiB+F,MAAM,CAACzB,OAAxB,EAAiChB,KAAjC,EAAwC,IAAxC,CAAZ,CAAL;YACA;UACH,CArBQ,CAsBT;;;UACA,IAAI,KAAKQ,SAAT,EAAoB;YAChB;UACH;;UACD,KAAKN,OAAL;UACA,KAAKgD,IAAL,CAAU,OAAV,EAAmB,KAAK9D,UAAL,GAAkB,CAArC,EAAwCY,KAAxC,EAAgDmD,cAAD,IAAoB;YAC/D,MAAMZ,OAAO,GAAG,IAAI7E,OAAJ,CAAYG,OAAO,CAACD,GAApB,EAAyBuF,cAAzB,EAAyCtF,OAAzC,CAAhB;YACA0E,OAAO,CAACnD,UAAR,GAAqB,KAAKA,UAAL,GAAkB,CAAvC;YACArE,OAAO,CAACqI,QAAR,CAAiB,MAAM;cACnB,KAAKb,OAAO,CAACtC,KAAR,EAAL;YACH,CAFD;YAGA,OAAOsC,OAAP;UACH,CAPD;UAQA;QACH;MACJ;;MACD,KAAK,KAAKG,MAAL,CAAYzB,UAAZ,CAAL;IACH,CAzFI,GAAL;EA0FH;;EACDoC,KAAK,GAAG;IACJ,KAAKxE,YAAL,GAAoB,IAApB;IACA,MAAM;MAAEgC;IAAF,IAAe,IAArB;;IACA,IAAIA,QAAQ,IAAI,CAAC,KAAKpC,YAAtB,EAAoC;MAChC;MACA;MACA,IAAIoC,QAAQ,CAACyC,cAAb,EAA6B;QACzB,KAAKzE,YAAL,GAAoB,KAApB;MACH;;MACD,IAAI0E,IAAJ;;MACA,OAAO,CAACA,IAAI,GAAG1C,QAAQ,CAAC2C,IAAT,EAAR,MAA6B,IAApC,EAA0C;QACtC,KAAKjF,eAAL,IAAwBgF,IAAI,CAAC3C,MAA7B,CADsC,CACD;;QACrC,MAAM6C,QAAQ,GAAG,KAAKC,gBAAtB;;QACA,IAAID,QAAQ,CAACE,OAAT,GAAmB,CAAvB,EAA0B;UACtB,KAAKT,IAAL,CAAU,kBAAV,EAA8BO,QAA9B;QACH;;QACD,KAAKG,IAAL,CAAUL,IAAV;MACH;IACJ;EACJ;;EACDM,MAAM,CAACC,KAAD,EAAQC,QAAR,EAAkBC,QAAlB,EAA4B;IAC9B,MAAMC,KAAK,GAAG,MAAM;MAChB,KAAKC,aAAL,CAAmBJ,KAAnB,EAA0BC,QAA1B,EAAoCC,QAApC;IACH,CAFD;;IAGA,IAAI,KAAK/E,mBAAT,EAA8B;MAC1BgF,KAAK;IACR,CAFD,MAGK;MACD,KAAKlF,KAAL,CAAW6E,IAAX,CAAgBK,KAAhB;IACH;EACJ;;EACDE,MAAM,CAACH,QAAD,EAAW;IACb,MAAMI,UAAU,GAAG,MAAM;MACrB;MACA;MACA,IAAI,CAAC,KAAK1D,QAAN,IAAkB,KAAKA,QAAL,CAAcF,SAApC,EAA+C;QAC3CwD,QAAQ;QACR;MACH;;MACD,KAAKtD,QAAL,CAAc2D,GAAd,CAAmBrE,KAAD,IAAW;QACzB;QACA;QACA,IAAI,KAAKU,QAAL,CAAc4D,cAAd,EAA8BC,OAAlC,EAA2C;UACvC;QACH;;QACD,IAAI,CAACvE,KAAL,EAAY;UACR,KAAKwE,SAAL,GAAiB,KAAKhG,aAAtB;UACA,KAAK0E,IAAL,CAAU,gBAAV,EAA4B,KAAKuB,cAAjC;;UACA,KAAK/D,QAAL,CAAcwC,IAAd,CAAmB,iBAAnB;QACH;;QACDc,QAAQ,CAAChE,KAAD,CAAR;MACH,CAZD;IAaH,CApBD;;IAqBA,IAAI,KAAKf,mBAAT,EAA8B;MAC1BmF,UAAU;IACb,CAFD,MAGK;MACD,KAAKrF,KAAL,CAAW6E,IAAX,CAAgBQ,UAAhB;IACH;EACJ;;EACDM,QAAQ,CAAC1E,KAAD,EAAQgE,QAAR,EAAkB;IACtB,KAAKvF,YAAL,GAAoB,IAApB;;IACA,KAAKwB,KAAL,GAAa,YAAY,CAAG,CAA5B,CAFsB,CAGtB;;;IACA,KAAKZ,UAAL;;IACA,KAAKP,eAAL;;IACA,IAAI,KAAKjB,OAAT,EAAkB;MACd,MAAM;QAAEsC;MAAF,IAAW,KAAKtC,OAAtB;;MACA,IAAIpC,EAAE,CAAC2E,UAAH,CAAcD,IAAd,CAAJ,EAAyB;QACrBA,IAAI,CAACD,OAAL;MACH;IACJ;;IACD,IAAI,KAAKQ,QAAT,EAAmB;MACf,KAAKA,QAAL,CAAcR,OAAd;IACH;;IACD,IAAIF,KAAK,KAAK,IAAV,IAAkB,CAACvE,EAAE,CAACkJ,SAAH,CAAa3E,KAAb,CAAnB,IAA0C,EAAEA,KAAK,YAAYtD,YAAnB,CAA9C,EAAgF;MAC5EsD,KAAK,GAAG,IAAItD,YAAJ,CAAiBsD,KAAK,CAACgB,OAAvB,EAAgChB,KAAhC,EAAuC,IAAvC,CAAR;IACH;;IACDgE,QAAQ,CAAChE,KAAD,CAAR;EACH;;EACD4E,IAAI,CAACC,WAAD,EAAchH,OAAd,EAAuB;IACvB,IAAIgH,WAAW,YAAYxJ,cAA3B,EAA2C;MACvC,KAAKqD,qBAAL,CAA2BoG,GAA3B,CAA+BD,WAA/B;IACH;;IACD,OAAO,MAAMD,IAAN,CAAWC,WAAX,EAAwBhH,OAAxB,CAAP;EACH;;EACDkH,MAAM,CAACF,WAAD,EAAc;IAChB,IAAIA,WAAW,YAAYxJ,cAA3B,EAA2C;MACvC,KAAKqD,qBAAL,CAA2BsG,MAA3B,CAAkCH,WAAlC;IACH;;IACD,MAAME,MAAN,CAAaF,WAAb;IACA,OAAO,IAAP;EACH;;EACkB,MAAbtE,aAAa,GAAG;IAClB,MAAM;MAAE1C;IAAF,IAAc,IAApB;IACA,MAAM;MAAE2B;IAAF,IAAc3B,OAApB;IACA,MAAMoH,MAAM,GAAG,CAACxJ,EAAE,CAACkJ,SAAH,CAAa9G,OAAO,CAACqH,IAArB,CAAhB,CAHkB,CAIlB;;IACA,MAAMC,MAAM,GAAG,CAAC1J,EAAE,CAACkJ,SAAH,CAAa9G,OAAO,CAACuH,IAArB,CAAhB;IACA,MAAMC,MAAM,GAAG,CAAC5J,EAAE,CAACkJ,SAAH,CAAa9G,OAAO,CAACsC,IAArB,CAAhB;IACA,MAAMmF,cAAc,GAAGlI,kBAAkB,CAACmI,GAAnB,CAAuB1H,OAAO,CAAC2H,MAA/B,KAA0C,EAAE3H,OAAO,CAAC2H,MAAR,KAAmB,KAAnB,IAA4B3H,OAAO,CAAC4H,YAAtC,CAAjE;IACA,KAAK9G,eAAL,GAAuB2G,cAAvB;;IACA,IAAIL,MAAM,IAAIE,MAAV,IAAoBE,MAAxB,EAAgC;MAC5B,IAAIC,cAAJ,EAAoB;QAChB,MAAM,IAAIxF,SAAJ,CAAe,SAAQjC,OAAO,CAAC2H,MAAO,sCAAtC,CAAN;MACH,CAH2B,CAI5B;;;MACA,MAAME,aAAa,GAAG,CAACjK,EAAE,CAACwB,MAAH,CAAUuC,OAAO,CAAC,cAAD,CAAjB,CAAvB;;MACA,IAAI6F,MAAJ,EAAY;QACR;QACA,IAAIxJ,cAAc,CAACgC,OAAO,CAACsC,IAAT,CAAlB,EAAkC;UAC9B,MAAMwF,OAAO,GAAG,IAAI/J,eAAJ,CAAoBiC,OAAO,CAACsC,IAA5B,CAAhB;;UACA,IAAIuF,aAAJ,EAAmB;YACflG,OAAO,CAAC,cAAD,CAAP,GAA0BmG,OAAO,CAACnG,OAAR,CAAgB,cAAhB,CAA1B;UACH;;UACDA,OAAO,CAAC,gBAAD,CAAP,GAA4BmG,OAAO,CAACnG,OAAR,CAAgB,gBAAhB,CAA5B;UACA3B,OAAO,CAACsC,IAAR,GAAewF,OAAO,CAACC,MAAR,EAAf;QACH,CATO,CAUR;;;QACA,IAAI7J,UAAU,CAAC8B,OAAO,CAACsC,IAAT,CAAV,IAA4BuF,aAAhC,EAA+C;UAC3ClG,OAAO,CAAC,cAAD,CAAP,GAA2B,iCAAgC3B,OAAO,CAACsC,IAAR,CAAa0F,WAAb,EAA2B,EAAtF;QACH;MACJ,CAdD,MAeK,IAAIZ,MAAJ,EAAY;QACb,IAAIS,aAAJ,EAAmB;UACflG,OAAO,CAAC,cAAD,CAAP,GAA0B,mCAA1B;QACH;;QACD,MAAM;UAAE0F;QAAF,IAAWrH,OAAjB;QACAA,OAAO,CAACqH,IAAR,GAAeP,SAAf;QACA9G,OAAO,CAACsC,IAAR,GAAgB,IAAIhF,eAAJ,CAAoB+J,IAApB,CAAD,CAA4BzD,QAA5B,EAAf;MACH,CAPI,MAQA;QACD,IAAIiE,aAAJ,EAAmB;UACflG,OAAO,CAAC,cAAD,CAAP,GAA0B,kBAA1B;QACH;;QACD,MAAM;UAAE4F;QAAF,IAAWvH,OAAjB;QACAA,OAAO,CAACuH,IAAR,GAAeT,SAAf;QACA9G,OAAO,CAACsC,IAAR,GAAetC,OAAO,CAACiI,aAAR,CAAsBV,IAAtB,CAAf;MACH;;MACD,MAAMW,cAAc,GAAG,MAAMjK,WAAW,CAAC+B,OAAO,CAACsC,IAAT,EAAetC,OAAO,CAAC2B,OAAvB,CAAxC,CArC4B,CAsC5B;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;;MACA,IAAI/D,EAAE,CAACkJ,SAAH,CAAanF,OAAO,CAAC,gBAAD,CAApB,KAA2C/D,EAAE,CAACkJ,SAAH,CAAanF,OAAO,CAAC,mBAAD,CAApB,CAA3C,IAAyF,CAAC8F,cAA1F,IAA4G,CAAC7J,EAAE,CAACkJ,SAAH,CAAaoB,cAAb,CAAjH,EAA+I;QAC3IvG,OAAO,CAAC,gBAAD,CAAP,GAA4BwG,MAAM,CAACD,cAAD,CAAlC;MACH;IACJ;;IACD,IAAIlI,OAAO,CAACoI,YAAR,KAAyB,MAAzB,IAAmC,EAAE,YAAYpI,OAAO,CAAC2B,OAAtB,CAAvC,EAAuE;MACnE3B,OAAO,CAAC2B,OAAR,CAAgB0G,MAAhB,GAAyB,kBAAzB;IACH;;IACD,KAAK1B,SAAL,GAAiB5C,MAAM,CAACpC,OAAO,CAAC,gBAAD,CAAR,CAAN,IAAqCmF,SAAtD;EACH;;EACoB,MAAfwB,eAAe,CAACtF,QAAD,EAAW;IAC5B;IACA,IAAI,KAAKuF,SAAT,EAAoB;MAChB;IACH;;IACD,MAAM;MAAEvI;IAAF,IAAc,IAApB;IACA,MAAM;MAAED;IAAF,IAAUC,OAAhB;IACA,KAAKwI,eAAL,GAAuBxF,QAAvB;;IACA,IAAIhD,OAAO,CAACyI,UAAZ,EAAwB;MACpBzF,QAAQ,GAAGrF,kBAAkB,CAACqF,QAAD,CAA7B;IACH;;IACD,MAAM0F,UAAU,GAAG1F,QAAQ,CAAC0F,UAA5B;IACA,MAAMC,aAAa,GAAG3F,QAAtB;IACA2F,aAAa,CAACC,aAAd,GAA8BD,aAAa,CAACC,aAAd,GAA8BD,aAAa,CAACC,aAA5C,GAA4DrL,IAAI,CAACsL,YAAL,CAAkBH,UAAlB,CAA1F;IACAC,aAAa,CAAC5I,GAAd,GAAoBC,OAAO,CAACD,GAAR,CAAY6D,QAAZ,EAApB;IACA+E,aAAa,CAACzG,UAAd,GAA2B,KAAKA,UAAhC;IACAyG,aAAa,CAACrH,YAAd,GAA6B,KAAKA,YAAlC;IACAqH,aAAa,CAACjE,OAAd,GAAwB,IAAxB;IACAiE,aAAa,CAACG,WAAd,GAA4B,KAAKN,eAAL,CAAqBO,SAArB,IAAkC,KAA9D;IACAJ,aAAa,CAACK,EAAd,GAAmB,KAAKA,EAAxB;IACAL,aAAa,CAACpH,UAAd,GAA2B,KAAKA,UAAhC;IACA,KAAK0H,YAAL,GAAoBN,aAAa,CAACG,WAAlC;IACA,KAAKI,aAAL,GAAqBnF,MAAM,CAACf,QAAQ,CAACrB,OAAT,CAAiB,gBAAjB,CAAD,CAAN,IAA8CmF,SAAnE;IACA,KAAK9D,QAAL,GAAgB2F,aAAhB;IACA3F,QAAQ,CAACR,IAAT,CAAc,KAAd,EAAqB,MAAM;MACvB,KAAK0G,aAAL,GAAqB,KAAKxI,eAA1B;MACA,KAAK2E,IAAL,CAAU,kBAAV,EAA8B,KAAKQ,gBAAnC;IACH,CAHD;IAIA7C,QAAQ,CAACR,IAAT,CAAc,OAAd,EAAwBL,KAAD,IAAW;MAC9B,KAAKd,QAAL,GAAgB,IAAhB,CAD8B,CAE9B;MACA;;MACA2B,QAAQ,CAACX,OAAT;;MACA,KAAKI,YAAL,CAAkB,IAAI3D,SAAJ,CAAcqD,KAAd,EAAqB,IAArB,CAAlB;IACH,CAND;IAOAa,QAAQ,CAACR,IAAT,CAAc,SAAd,EAAyB,MAAM;MAC3B,KAAKnB,QAAL,GAAgB,IAAhB;;MACA,KAAKoB,YAAL,CAAkB,IAAI3D,SAAJ,CAAc;QAC5BoE,IAAI,EAAE,OADsB;QAE5BC,OAAO,EAAE,oCAFmB;QAG5BgG,IAAI,EAAE;MAHsB,CAAd,EAIf,IAJe,CAAlB;IAKH,CAPD;IAQA,KAAK9D,IAAL,CAAU,kBAAV,EAA8B,KAAKQ,gBAAnC;IACA,MAAMuD,UAAU,GAAGpG,QAAQ,CAACrB,OAAT,CAAiB,YAAjB,CAAnB;;IACA,IAAI/D,EAAE,CAACyL,MAAH,CAAUrJ,OAAO,CAACsJ,SAAlB,KAAgCF,UAApC,EAAgD;MAC5C,IAAIG,QAAQ,GAAGH,UAAU,CAACI,GAAX,CAAe,MAAOC,SAAP,IAAqBzJ,OAAO,CAACsJ,SAAR,CAAkBI,SAAlB,CAA4BD,SAA5B,EAAuC1J,GAAG,CAAC6D,QAAJ,EAAvC,CAApC,CAAf;;MACA,IAAI5D,OAAO,CAAC2J,oBAAZ,EAAkC;QAC9BJ,QAAQ,GAAGA,QAAQ,CAACC,GAAT,CAAa,MAAOI,OAAP,IAAmB;UACvC,IAAI;YACA,MAAMA,OAAN;UACH,CAFD,CAGA,MAAM,CAAG;QACZ,CALU,CAAX;MAMH;;MACD,IAAI;QACA,MAAM9E,OAAO,CAAC+E,GAAR,CAAYN,QAAZ,CAAN;MACH,CAFD,CAGA,OAAOpH,KAAP,EAAc;QACV,KAAKM,YAAL,CAAkBN,KAAlB;;QACA;MACH;IACJ,CA9D2B,CA+D5B;;;IACA,IAAI,KAAKoG,SAAT,EAAoB;MAChB;IACH;;IACD,IAAIvI,OAAO,CAAC8J,cAAR,IAA0B9G,QAAQ,CAACrB,OAAT,CAAiBoI,QAA3C,IAAuDrK,aAAa,CAACgI,GAAd,CAAkBgB,UAAlB,CAA3D,EAA0F;MACtF;MACA;MACA;MACA1F,QAAQ,CAACgH,MAAT;;MACA,KAAK/I,eAAL;;MACA,KAAKF,cAAL;;MACA,IAAI,KAAKO,YAAL,CAAkByB,MAAlB,IAA4B/C,OAAO,CAACiK,YAAxC,EAAsD;QAClD,KAAKxH,YAAL,CAAkB,IAAI1D,iBAAJ,CAAsB,IAAtB,CAAlB;;QACA;MACH;;MACD,KAAK8D,QAAL,GAAgBiE,SAAhB;MACA,MAAMxB,cAAc,GAAG,IAAI5G,OAAJ,CAAYoI,SAAZ,EAAuBA,SAAvB,EAAkC,KAAK9G,OAAvC,CAAvB;MACA,MAAMkK,WAAW,GAAGxB,UAAU,KAAK,GAAf,IAAsBpD,cAAc,CAACqC,MAAf,KAA0B,KAAhD,IAAyDrC,cAAc,CAACqC,MAAf,KAA0B,MAAvG;;MACA,IAAIuC,WAAW,IAAI5E,cAAc,CAAC6E,eAAlC,EAAmD;QAC/C;QACA;QACA7E,cAAc,CAACqC,MAAf,GAAwB,KAAxB;QACArC,cAAc,CAAChD,IAAf,GAAsBwE,SAAtB;QACAxB,cAAc,CAACiC,IAAf,GAAsBT,SAAtB;QACAxB,cAAc,CAAC+B,IAAf,GAAsBP,SAAtB;QACA,OAAOxB,cAAc,CAAC3D,OAAf,CAAuB,gBAAvB,CAAP;MACH;;MACD,IAAI;QACA;QACA,MAAMyI,cAAc,GAAGjN,MAAM,CAACkN,IAAP,CAAYrH,QAAQ,CAACrB,OAAT,CAAiBoI,QAA7B,EAAuC,QAAvC,EAAiDnG,QAAjD,EAAvB;QACA,MAAM0G,WAAW,GAAG,IAAIjN,GAAJ,CAAQ+M,cAAR,EAAwBrK,GAAxB,CAApB,CAHA,CAIA;;QACA,IAAIuK,WAAW,CAACC,QAAZ,KAAyBxK,GAAG,CAACwK,QAA7B,IAAyCD,WAAW,CAACE,IAAZ,KAAqBzK,GAAG,CAACyK,IAAtE,EAA4E;UACxE,IAAI,UAAUlF,cAAc,CAAC3D,OAA7B,EAAsC;YAClC,OAAO2D,cAAc,CAAC3D,OAAf,CAAuB8I,IAA9B;UACH;;UACD,IAAI,YAAYnF,cAAc,CAAC3D,OAA/B,EAAwC;YACpC,OAAO2D,cAAc,CAAC3D,OAAf,CAAuB+I,MAA9B;UACH;;UACD,IAAI,mBAAmBpF,cAAc,CAAC3D,OAAtC,EAA+C;YAC3C,OAAO2D,cAAc,CAAC3D,OAAf,CAAuBgJ,aAA9B;UACH;;UACD,IAAIrF,cAAc,CAACsF,QAAf,IAA2BtF,cAAc,CAACuF,QAA9C,EAAwD;YACpDvF,cAAc,CAACsF,QAAf,GAA0B,EAA1B;YACAtF,cAAc,CAACuF,QAAf,GAA0B,EAA1B;UACH;QACJ,CAdD,MAeK;UACDP,WAAW,CAACM,QAAZ,GAAuBtF,cAAc,CAACsF,QAAtC;UACAN,WAAW,CAACO,QAAZ,GAAuBvF,cAAc,CAACuF,QAAtC;QACH;;QACD,KAAKvJ,YAAL,CAAkByE,IAAlB,CAAuBuE,WAAvB;QACAhF,cAAc,CAACtD,SAAf,GAA2B,EAA3B;QACAsD,cAAc,CAACvF,GAAf,GAAqBuK,WAArB;;QACA,KAAK,MAAMpF,IAAX,IAAmBI,cAAc,CAACH,KAAf,CAAqB2F,cAAxC,EAAwD;UACpD;UACA,MAAM5F,IAAI,CAACI,cAAD,EAAiBqD,aAAjB,CAAV;QACH;;QACD,KAAKtD,IAAL,CAAU,UAAV,EAAsBC,cAAtB,EAAsCqD,aAAtC;QACA,KAAK3I,OAAL,GAAesF,cAAf;QACA,MAAM,KAAK1C,YAAL,EAAN;MACH,CAlCD,CAmCA,OAAOT,KAAP,EAAc;QACV,KAAKM,YAAL,CAAkBN,KAAlB;;QACA;MACH;;MACD;IACH;;IACD,IAAInC,OAAO,CAAC+K,QAAR,IAAoB/K,OAAO,CAACgL,eAA5B,IAA+C,CAACrM,YAAY,CAACgK,aAAD,CAAhE,EAAiF;MAC7E,KAAKlG,YAAL,CAAkB,IAAIzD,SAAJ,CAAc2J,aAAd,CAAlB;;MACA;IACH;;IACD3F,QAAQ,CAACvB,EAAT,CAAY,UAAZ,EAAwB,MAAM;MAC1B,IAAI,KAAKT,YAAT,EAAuB;QACnB,KAAKwE,KAAL;MACH;IACJ,CAJD;IAKA,KAAK/D,EAAL,CAAQ,QAAR,EAAkB,MAAM;MACpBuB,QAAQ,CAACgH,MAAT;IACH,CAFD;IAGA,KAAKvI,EAAL,CAAQ,OAAR,EAAiB,MAAM;MACnBuB,QAAQ,CAACiI,KAAT;IACH,CAFD;IAGAjI,QAAQ,CAACR,IAAT,CAAc,KAAd,EAAqB,MAAM;MACvB,KAAKuD,IAAL,CAAU,IAAV;IACH,CAFD;;IAGA,IAAI,KAAKmF,OAAT,EAAkB;MACd,MAAMxH,OAAO,GAAG,MAAM,KAAKC,WAAL,EAAtB;;MACA,IAAID,OAAJ,EAAa;QACT,KAAK2B,IAAL,CAAU,UAAV,EAAsBrC,QAAtB;MACH;;MACD;IACH;;IACD,KAAKqC,IAAL,CAAU,UAAV,EAAsBrC,QAAtB;;IACA,KAAK,MAAMgE,WAAX,IAA0B,KAAKnG,qBAA/B,EAAsD;MAClD,IAAImG,WAAW,CAACmE,WAAhB,EAA6B;QACzB;MACH,CAHiD,CAIlD;;;MACA,KAAK,MAAMC,GAAX,IAAkBpI,QAAQ,CAACrB,OAA3B,EAAoC;QAChC,MAAM0J,SAAS,GAAGrL,OAAO,CAACyI,UAAR,GAAqB2C,GAAG,KAAK,kBAA7B,GAAkD,IAApE;QACA,MAAM3K,KAAK,GAAGuC,QAAQ,CAACrB,OAAT,CAAiByJ,GAAjB,CAAd;;QACA,IAAIC,SAAJ,EAAe;UACXrE,WAAW,CAACsE,SAAZ,CAAsBF,GAAtB,EAA2B3K,KAA3B;QACH;MACJ;;MACDuG,WAAW,CAAC0B,UAAZ,GAAyBA,UAAzB;IACH;EACJ;;EACgB,MAAX/E,WAAW,CAAC0G,IAAI,GAAG,IAAR,EAAc;IAC3B,IAAIA,IAAI,CAACkB,aAAT,EAAwB;MACpB,OAAO,KAAP;IACH;;IACD,IAAI;MACA;MACA,MAAMjI,OAAO,GAAG,MAAMxF,SAAS,CAACuM,IAAD,CAA/B,CAFA,CAGA;MACA;;MACA,IAAI,CAAC,KAAK9B,SAAV,EAAqB;QACjB,KAAKvF,QAAL,CAAcM,OAAd,GAAwBA,OAAxB;QACA,OAAO,IAAP;MACH;IACJ,CATD,CAUA,MAAM,CAAG;;IACT,OAAO,KAAP;EACH;;EACgB,MAAXkI,WAAW,CAACxI,QAAD,EAAW;IACxB,IAAI;MACA,MAAM,KAAKsF,eAAL,CAAqBtF,QAArB,CAAN;IACH,CAFD,CAGA,OAAOb,KAAP,EAAc;MACV;MACA,KAAKM,YAAL,CAAkBN,KAAlB;IACH;EACJ;;EACDsJ,UAAU,CAAC/G,OAAD,EAAU;IAChB,MAAM;MAAE1E;IAAF,IAAc,IAApB;IACA,MAAM;MAAEyE,OAAF;MAAW1E;IAAX,IAAmBC,OAAzB;IACAvC,KAAK,CAACiH,OAAD,CAAL;;IACA,IAAI,KAAK1E,OAAL,CAAa0L,KAAjB,EAAwB;MACpB;MACAhH,OAAO,CAACM,UAAR,CAAmB,CAAnB;IACH;;IACD,KAAK/D,eAAL,GAAuB7C,QAAQ,CAACsG,OAAD,EAAUD,OAAV,EAAmB1E,GAAnB,CAA/B;IACA,MAAM4L,iBAAiB,GAAG3L,OAAO,CAAC4L,KAAR,GAAgB,mBAAhB,GAAsC,UAAhE;IACAlH,OAAO,CAAClC,IAAR,CAAamJ,iBAAb,EAAiC3I,QAAD,IAAc;MAC1C,KAAK,KAAKwI,WAAL,CAAiBxI,QAAjB,CAAL;IACH,CAFD;IAGA0B,OAAO,CAAClC,IAAR,CAAa,OAAb,EAAuBL,KAAD,IAAW;MAC7B,KAAKd,QAAL,GAAgB,IAAhB,CAD6B,CAE7B;;MACAqD,OAAO,CAACrC,OAAR;MACAF,KAAK,GAAGA,KAAK,YAAY7D,oBAAjB,GAAwC,IAAID,YAAJ,CAAiB8D,KAAjB,EAAwB,KAAK0J,OAA7B,EAAsC,IAAtC,CAAxC,GAAsF,IAAIhN,YAAJ,CAAiBsD,KAAK,CAACgB,OAAvB,EAAgChB,KAAhC,EAAuC,IAAvC,CAA9F;;MACA,KAAKM,YAAL,CAAkBN,KAAlB;IACH,CAND;IAOA,KAAKpB,cAAL,GAAsB5C,WAAW,CAACuG,OAAD,EAAU,IAAV,EAAgB/E,oBAAhB,CAAjC;IACA,KAAKkD,QAAL,GAAgB6B,OAAhB;IACA,KAAKW,IAAL,CAAU,gBAAV,EAA4B,KAAKuB,cAAjC;;IACA,KAAKkF,SAAL;;IACA,KAAKzG,IAAL,CAAU,SAAV,EAAqBX,OAArB;EACH;;EACgB,MAAXqH,WAAW,CAAC9F,KAAD,EAAQ;IACrB,OAAO,IAAInB,OAAJ,CAAY,CAACC,OAAD,EAAUiH,MAAV,KAAqB;MACpC,MAAM5F,KAAN,CAAYH,KAAZ,EAAmB9D,KAAK,IAAI;QACxB,IAAIA,KAAJ,EAAW;UACP6J,MAAM,CAAC7J,KAAD,CAAN;UACA;QACH;;QACD4C,OAAO;MACV,CAND;IAOH,CARM,CAAP;EASH;;EACD+G,SAAS,GAAG;IACR;IACA,MAAM;MAAExJ;IAAF,IAAW,KAAKtC,OAAtB;IACA,MAAMiM,cAAc,GAAG,KAAK3K,YAAL,CAAkByB,MAAlB,KAA6B,CAA7B,GAAiC,IAAjC,GAAwC,KAAKF,QAAL,IAAiB,IAAhF;;IACA,IAAIjF,EAAE,CAAC2E,UAAH,CAAcD,IAAd,CAAJ,EAAyB;MACrBA,IAAI,CAACyE,IAAL,CAAUkF,cAAV;IACH,CAFD,MAGK,IAAIrO,EAAE,CAACsO,SAAH,CAAa5J,IAAb,KAAsB1E,EAAE,CAACuO,cAAH,CAAkB7J,IAAlB,CAA1B,EAAmD;MACpD,CAAC,YAAY;QACT,IAAI;UACA,WAAW,MAAM2D,KAAjB,IAA0B3D,IAA1B,EAAgC;YAC5B,MAAM,KAAKyJ,WAAL,CAAiB9F,KAAjB,CAAN;UACH;;UACD,MAAMO,GAAN;QACH,CALD,CAMA,OAAOrE,KAAP,EAAc;UACV,KAAKM,YAAL,CAAkBN,KAAlB;QACH;MACJ,CAVD;IAWH,CAZI,MAaA,IAAI,CAACvE,EAAE,CAACkJ,SAAH,CAAaxE,IAAb,CAAL,EAAyB;MAC1B,KAAK+D,aAAL,CAAmB/D,IAAnB,EAAyBwE,SAAzB,EAAoC,MAAM,CAAG,CAA7C;;MACAmF,cAAc,CAACzF,GAAf;IACH,CAHI,MAIA,IAAI,KAAK1F,eAAL,IAAwB,KAAKoK,OAAjC,EAA0C;MAC3Ce,cAAc,CAACzF,GAAf;IACH;EACJ;;EACD4F,aAAa,CAACR,KAAD,EAAQ;IACjB,IAAI,CAACnM,cAAc,CAACiI,GAAf,CAAmBkE,KAAnB,CAAL,EAAgC;MAC5BnM,cAAc,CAAC4M,GAAf,CAAmBT,KAAnB,EAA0B,IAAIlO,gBAAJ,CAAsB,CAAC4O,cAAD,EAAiBC,OAAjB,KAA6B;QACzE,MAAMC,MAAM,GAAGF,cAAc,CAACzJ,QAAf,CAAwByJ,cAAxB,EAAwCC,OAAxC,CAAf,CADyE,CAEzE;;;QACA,IAAI3O,EAAE,CAACgM,OAAH,CAAW4C,MAAX,CAAJ,EAAwB;UACpB;UACA;UACA;UACA;UACAA,MAAM,CAAChK,IAAP,GAAc,CAACX,KAAD,EAAQ0K,OAAR,KAAoB;YAC9B,IAAI1K,KAAK,KAAK,OAAd,EAAuB;cACnB,CAAC,YAAY;gBACT,IAAI;kBACA,MAAM2K,MAAN;gBACH,CAFD,CAGA,OAAOrK,KAAP,EAAc;kBACVoK,OAAO,CAACpK,KAAD,CAAP;gBACH;cACJ,CAPD;YAQH,CATD,MAUK,IAAIN,KAAK,KAAK,OAAd,EAAuB;cACxB;cACA;cACA,CAAC,YAAY;gBACT,IAAI;kBACA,MAAM6C,OAAO,GAAI,MAAM8H,MAAvB;kBACA9H,OAAO,CAAClC,IAAR,CAAa,OAAb,EAAsB+J,OAAtB;gBACH,CAHD,CAIA,MAAM,CAAG;cACZ,CAND;YAOH,CAVI,MAWA;cACD;cACA,MAAM,IAAIxK,KAAJ,CAAW,gCAA+BF,KAAM,EAAhD,CAAN;YACH;;YACD,OAAO2K,MAAP;UACH,CA3BD;QA4BH;;QACD,OAAOA,MAAP;MACH,CAtCyB,EAsCtBZ,KAtCsB,CAA1B;IAuCH;EACJ;;EAC4B,MAAvBa,uBAAuB,CAAC1M,GAAD,EAAMC,OAAN,EAAe;IACxC,OAAO,IAAI8E,OAAJ,CAAY,CAACC,OAAD,EAAUiH,MAAV,KAAqB;MACpC;MACA5L,MAAM,CAACwB,MAAP,CAAc5B,OAAd,EAAuBzB,YAAY,CAACwB,GAAD,CAAnC;MACA,IAAI2E,OAAJ,CAHoC,CAIpC;;MACA,MAAMgI,YAAY,GAAGjN,cAAc,CAACkN,GAAf,CAAmB3M,OAAO,CAAC4L,KAA3B,EAAkC5L,OAAlC,EAA2C,MAAOgD,QAAP,IAAoB;QAChFA,QAAQ,CAAC4J,cAAT,CAAwB1M,WAAxB,GAAsC,KAAtC;;QACA,IAAIwE,OAAJ,EAAa;UACT,MAAMmI,GAAG,GAAG,MAAM;YACd,IAAI7J,QAAQ,CAAC8J,GAAb,EAAkB;cACd9J,QAAQ,CAAC+J,QAAT,GAAoB/J,QAAQ,CAAC8J,GAAT,CAAaE,GAAb,CAAiBD,QAArC;YACH;UACJ,CAJD;;UAKA/J,QAAQ,CAACiK,mBAAT,CAA6B,KAA7B,EAAoCJ,GAApC;UACAA,GAAG;UACH,CAAC,MAAMnI,OAAP,EAAgBW,IAAhB,CAAqB,mBAArB,EAA0CrC,QAA1C;QACH;;QACD+B,OAAO,CAAC/B,QAAD,CAAP;MACH,CAboB,CAArB;MAcA0J,YAAY,CAAClK,IAAb,CAAkB,OAAlB,EAA2BwJ,MAA3B;MACAU,YAAY,CAAClK,IAAb,CAAkB,SAAlB,EAA6B,MAAO0K,gBAAP,IAA4B;QACrDxI,OAAO,GAAGwI,gBAAV;QACAnI,OAAO,CAACL,OAAD,CAAP;MACH,CAHD;IAIH,CAxBM,CAAP;EAyBH;;EACiB,MAAZ9B,YAAY,GAAG;IACjB,MAAM;MAAE5C;IAAF,IAAc,IAApB;IACA,MAAM;MAAE2B,OAAF;MAAWiJ,QAAX;MAAqBC;IAArB,IAAkC7K,OAAxC;IACA,MAAMsJ,SAAS,GAAGtJ,OAAO,CAACsJ,SAA1B;;IACA,KAAK,MAAM8B,GAAX,IAAkBzJ,OAAlB,EAA2B;MACvB,IAAI/D,EAAE,CAACkJ,SAAH,CAAanF,OAAO,CAACyJ,GAAD,CAApB,CAAJ,EAAgC;QAC5B;QACA,OAAOzJ,OAAO,CAACyJ,GAAD,CAAd;MACH,CAHD,MAIK,IAAIxN,EAAE,CAACuP,KAAH,CAASxL,OAAO,CAACyJ,GAAD,CAAhB,CAAJ,EAA4B;QAC7B,MAAM,IAAInJ,SAAJ,CAAe,yDAAwDmJ,GAAI,WAA3E,CAAN;MACH;IACJ;;IACD,IAAIpL,OAAO,CAACyI,UAAR,IAAsB7K,EAAE,CAACkJ,SAAH,CAAanF,OAAO,CAAC,iBAAD,CAApB,CAA1B,EAAoE;MAChEA,OAAO,CAAC,iBAAD,CAAP,GAA6BxC,cAAc,GAAG,mBAAH,GAAyB,eAApE;IACH;;IACD,IAAIyL,QAAQ,IAAIC,QAAhB,EAA0B;MACtB,MAAMuC,WAAW,GAAGjQ,MAAM,CAACkN,IAAP,CAAa,GAAEO,QAAS,IAAGC,QAAS,EAApC,EAAuCjH,QAAvC,CAAgD,QAAhD,CAApB;MACAjC,OAAO,CAACgJ,aAAR,GAAyB,SAAQyC,WAAY,EAA7C;IACH,CAnBgB,CAoBjB;;;IACA,IAAI9D,SAAJ,EAAe;MACX,MAAM+D,YAAY,GAAG,MAAM/D,SAAS,CAACgE,eAAV,CAA0BtN,OAAO,CAACD,GAAR,CAAY6D,QAAZ,EAA1B,CAA3B;;MACA,IAAIhG,EAAE,CAAC2P,cAAH,CAAkBF,YAAlB,CAAJ,EAAqC;QACjC1L,OAAO,CAAC+I,MAAR,GAAiB2C,YAAjB;MACH;IACJ,CA1BgB,CA2BjB;;;IACArN,OAAO,CAACgC,SAAR,GAAoB,EAApB;IACA,IAAI0C,OAAJ;;IACA,KAAK,MAAMQ,IAAX,IAAmBlF,OAAO,CAACmF,KAAR,CAAcqI,aAAjC,EAAgD;MAC5C;MACA,MAAMhB,MAAM,GAAG,MAAMtH,IAAI,CAAClF,OAAD,CAAzB;;MACA,IAAI,CAACpC,EAAE,CAACkJ,SAAH,CAAa0F,MAAb,CAAL,EAA2B;QACvB;QACA9H,OAAO,GAAG,MAAM8H,MAAhB;;QACA;MACH;IACJ;;IACD,IAAI,CAAC9H,OAAL,EAAc;MACVA,OAAO,GAAG1E,OAAO,CAACyN,kBAAR,EAAV;IACH;;IACD,MAAM1N,GAAG,GAAGC,OAAO,CAACD,GAApB;IACA,KAAK2N,eAAL,GAAuB1N,OAAO,CAAC2N,0BAAR,EAAvB;;IACA,IAAI3N,OAAO,CAAC4L,KAAZ,EAAmB;MACf,KAAK8B,eAAL,CAAqB7K,QAArB,GAAgC6B,OAAhC;MACA,KAAKgJ,eAAL,CAAqB9B,KAArB,GAA6B5L,OAAO,CAAC4L,KAArC;;MACA,KAAKQ,aAAL,CAAmBpM,OAAO,CAAC4L,KAA3B;IACH,CAhDgB,CAiDjB;;;IACA,MAAMgC,EAAE,GAAG5N,OAAO,CAAC4L,KAAR,GAAgB,KAAKa,uBAArB,GAA+C/H,OAA1D;;IACA,IAAI;MACA;MACA;MACA,IAAImJ,iBAAiB,GAAGD,EAAE,CAAC7N,GAAD,EAAM,KAAK2N,eAAX,CAA1B;;MACA,IAAI9P,EAAE,CAACgM,OAAH,CAAWiE,iBAAX,CAAJ,EAAmC;QAC/BA,iBAAiB,GAAG,MAAMA,iBAA1B;MACH,CAND,CAOA;;;MACA,IAAIjQ,EAAE,CAACkJ,SAAH,CAAa+G,iBAAb,CAAJ,EAAqC;QACjCA,iBAAiB,GAAG7N,OAAO,CAAC8N,0BAAR,GAAqC/N,GAArC,EAA0C,KAAK2N,eAA/C,CAApB;;QACA,IAAI9P,EAAE,CAACgM,OAAH,CAAWiE,iBAAX,CAAJ,EAAmC;UAC/BA,iBAAiB,GAAG,MAAMA,iBAA1B;QACH;MACJ;;MACD,IAAIjP,eAAe,CAACiP,iBAAD,CAAnB,EAAwC;QACpC,KAAKpC,UAAL,CAAgBoC,iBAAhB;MACH,CAFD,MAGK,IAAI,KAAKrN,QAAT,EAAmB;QACpB,KAAKgC,IAAL,CAAU,QAAV,EAAoB,MAAM;UACtB,KAAK,KAAKgJ,WAAL,CAAiBqC,iBAAjB,CAAL;QACH,CAFD;;QAGA,KAAK/B,SAAL;MACH,CALI,MAMA;QACD,KAAK,KAAKN,WAAL,CAAiBqC,iBAAjB,CAAL;MACH;IACJ,CA1BD,CA2BA,OAAO1L,KAAP,EAAc;MACV,IAAIA,KAAK,YAAYzE,gBAAgB,CAACwB,UAAtC,EAAkD;QAC9C,MAAM,IAAIA,UAAJ,CAAeiD,KAAf,EAAsB,IAAtB,CAAN;MACH;;MACD,MAAMA,KAAN;IACH;EACJ;;EACW,MAAN0C,MAAM,CAAC1C,KAAD,EAAQ;IAChB,IAAI;MACA,KAAK,MAAM+C,IAAX,IAAmB,KAAKlF,OAAL,CAAamF,KAAb,CAAmB4I,WAAtC,EAAmD;QAC/C;QACA5L,KAAK,GAAG,MAAM+C,IAAI,CAAC/C,KAAD,CAAlB;MACH;IACJ,CALD,CAMA,OAAOyC,MAAP,EAAe;MACXzC,KAAK,GAAG,IAAItD,YAAJ,CAAiB+F,MAAM,CAACzB,OAAxB,EAAiCyB,MAAjC,EAAyC,IAAzC,CAAR;IACH;;IACD,KAAKvC,OAAL,CAAaF,KAAb;EACH;;EACDkE,aAAa,CAACJ,KAAD,EAAQC,QAAR,EAAkBC,QAAlB,EAA4B;IACrC,IAAI,CAAC,KAAKtD,QAAN,IAAkB,KAAKA,QAAL,CAAcF,SAApC,EAA+C;MAC3C;MACA;IACH;;IACD,KAAKE,QAAL,CAAcuD,KAAd,CAAoBH,KAApB,EAA2BC,QAA3B,EAAsC/D,KAAD,IAAW;MAC5C,IAAI,CAACA,KAAL,EAAY;QACR,KAAKxB,aAAL,IAAsBxD,MAAM,CAAC6Q,UAAP,CAAkB/H,KAAlB,EAAyBC,QAAzB,CAAtB;QACA,MAAMN,QAAQ,GAAG,KAAKgB,cAAtB;;QACA,IAAIhB,QAAQ,CAACE,OAAT,GAAmB,CAAvB,EAA0B;UACtB,KAAKT,IAAL,CAAU,gBAAV,EAA4BO,QAA5B;QACH;MACJ;;MACDO,QAAQ,CAAChE,KAAD,CAAR;IACH,CATD;EAUH;EACD;AACJ;AACA;;;EACU,IAAF6G,EAAE,GAAG;IACL,OAAO,KAAKzF,MAAL,EAAa0K,aAApB;EACH;EACD;AACJ;AACA;;;EACiB,IAAT1F,SAAS,GAAG;IACZ,OAAO,KAAKlH,QAAZ;EACH;;EACS,IAANkC,MAAM,GAAG;IACT,OAAO,KAAKV,QAAL,EAAeU,MAAf,IAAyBuD,SAAhC;EACH;EACD;AACJ;AACA;;;EACwB,IAAhBjB,gBAAgB,GAAG;IACnB,IAAIC,OAAJ;;IACA,IAAI,KAAKoD,aAAT,EAAwB;MACpBpD,OAAO,GAAG,KAAKpF,eAAL,GAAuB,KAAKwI,aAAtC;IACH,CAFD,MAGK,IAAI,KAAKA,aAAL,KAAuB,KAAKxI,eAAhC,EAAiD;MAClDoF,OAAO,GAAG,CAAV;IACH,CAFI,MAGA;MACDA,OAAO,GAAG,CAAV;IACH;;IACD,OAAO;MACHA,OADG;MAEHoI,WAAW,EAAE,KAAKxN,eAFf;MAGHyN,KAAK,EAAE,KAAKjF;IAHT,CAAP;EAKH;EACD;AACJ;AACA;;;EACsB,IAAdtC,cAAc,GAAG;IACjB,IAAId,OAAJ;;IACA,IAAI,KAAKa,SAAT,EAAoB;MAChBb,OAAO,GAAG,KAAKnF,aAAL,GAAqB,KAAKgG,SAApC;IACH,CAFD,MAGK,IAAI,KAAKA,SAAL,KAAmB,KAAKhG,aAA5B,EAA2C;MAC5CmF,OAAO,GAAG,CAAV;IACH,CAFI,MAGA;MACDA,OAAO,GAAG,CAAV;IACH;;IACD,OAAO;MACHA,OADG;MAEHoI,WAAW,EAAE,KAAKvN,aAFf;MAGHwN,KAAK,EAAE,KAAKxH;IAHT,CAAP;EAKH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EAIe,IAAPkF,OAAO,GAAG;IACV,OAAO,KAAKhJ,QAAL,EAAegJ,OAAtB;EACH;EACD;AACJ;AACA;;;EACmB,IAAX/C,WAAW,GAAG;IACd,OAAO,KAAKG,YAAZ;EACH;;EACe,IAAZmF,YAAY,GAAG;IACf,OAAO,KAAKvL,QAAL,EAAeuL,YAAtB;EACH;;AAnhCuC"},"metadata":{},"sourceType":"module"}