{"ast":null,"code":"import \"core-js/modules/es.array.includes.js\";\nimport BootstrapIcons from 'bootstrap-icons/bootstrap-icons.svg';\n/**\r\n * Make a map and return a function for checking if a key\r\n * is in that map.\r\n * IMPORTANT: all calls of this function must be prefixed with\r\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\r\n * So that rollup can tree-shake them if necessary.\r\n */\n\nfunction normalizeStyle(value) {\n  if (isArray(value)) {\n    const res = {};\n\n    for (let i = 0; i < value.length; i++) {\n      const item = value[i];\n      const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);\n\n      if (normalized) {\n        for (const key in normalized) {\n          res[key] = normalized[key];\n        }\n      }\n    }\n\n    return res;\n  } else if (isString(value)) {\n    return value;\n  } else if (isObject(value)) {\n    return value;\n  }\n}\n\nconst listDelimiterRE = /;(?![^(]*\\))/g;\nconst propertyDelimiterRE = /:(.+)/;\n\nfunction parseStringStyle(cssText) {\n  const ret = {};\n  cssText.split(listDelimiterRE).forEach(item => {\n    if (item) {\n      const tmp = item.split(propertyDelimiterRE);\n      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return ret;\n}\n\nfunction normalizeClass(value) {\n  let res = '';\n\n  if (isString(value)) {\n    res = value;\n  } else if (isArray(value)) {\n    for (let i = 0; i < value.length; i++) {\n      const normalized = normalizeClass(value[i]);\n\n      if (normalized) {\n        res += normalized + ' ';\n      }\n    }\n  } else if (isObject(value)) {\n    for (const name in value) {\n      if (value[name]) {\n        res += name + ' ';\n      }\n    }\n  }\n\n  return res.trim();\n}\n\nconst EMPTY_OBJ = {};\nconst EMPTY_ARR = [];\n\nconst NOOP = () => {};\n\nconst onRE = /^on[^a-z]/;\n\nconst isOn = key => onRE.test(key);\n\nconst extend = Object.assign;\n\nconst remove = (arr, el) => {\n  const i = arr.indexOf(el);\n\n  if (i > -1) {\n    arr.splice(i, 1);\n  }\n};\n\nconst isArray = Array.isArray;\n\nconst isMap = val => toTypeString(val) === '[object Map]';\n\nconst isSet = val => toTypeString(val) === '[object Set]';\n\nconst isFunction = val => typeof val === 'function';\n\nconst isString = val => typeof val === 'string';\n\nconst isSymbol = val => typeof val === 'symbol';\n\nconst isObject = val => val !== null && typeof val === 'object';\n\nconst isPromise = val => {\n  return isObject(val) && isFunction(val.then) && isFunction(val.catch);\n};\n\nconst objectToString = Object.prototype.toString;\n\nconst toTypeString = value => objectToString.call(value);\n\nconst isPlainObject = val => toTypeString(val) === '[object Object]'; // compare whether a value has changed, accounting for NaN.\n\n\nconst hasChanged = (value, oldValue) => !Object.is(value, oldValue);\n\nconst def = (obj, key, value) => {\n  Object.defineProperty(obj, key, {\n    configurable: true,\n    enumerable: false,\n    value\n  });\n};\n\nlet activeEffectScope;\n\nfunction recordEffectScope(effect, scope = activeEffectScope) {\n  if (scope && scope.active) {\n    scope.effects.push(effect);\n  }\n}\n\nconst wasTracked = dep => (dep.w & trackOpBit) > 0;\n\nconst newTracked = dep => (dep.n & trackOpBit) > 0;\n\nconst initDepMarkers = ({\n  deps\n}) => {\n  if (deps.length) {\n    for (let i = 0; i < deps.length; i++) {\n      deps[i].w |= trackOpBit; // set was tracked\n    }\n  }\n};\n\nconst finalizeDepMarkers = effect => {\n  const {\n    deps\n  } = effect;\n\n  if (deps.length) {\n    let ptr = 0;\n\n    for (let i = 0; i < deps.length; i++) {\n      const dep = deps[i];\n\n      if (wasTracked(dep) && !newTracked(dep)) {\n        dep.delete(effect);\n      } else {\n        deps[ptr++] = dep;\n      } // clear bits\n\n\n      dep.w &= ~trackOpBit;\n      dep.n &= ~trackOpBit;\n    }\n\n    deps.length = ptr;\n  }\n}; // The number of effects currently being tracked recursively.\n\n\nlet effectTrackDepth = 0;\nlet trackOpBit = 1;\n/**\r\n * The bitwise track markers support at most 30 levels of recursion.\r\n * This value is chosen to enable modern JS engines to use a SMI on all platforms.\r\n * When recursion depth is greater, fall back to using a full cleanup.\r\n */\n\nconst maxMarkerBits = 30;\nlet activeEffect;\n\nclass ReactiveEffect {\n  constructor(fn, scheduler = null, scope) {\n    this.fn = fn;\n    this.scheduler = scheduler;\n    this.active = true;\n    this.deps = [];\n    this.parent = undefined;\n    recordEffectScope(this, scope);\n  }\n\n  run() {\n    if (!this.active) {\n      return this.fn();\n    }\n\n    let parent = activeEffect;\n    let lastShouldTrack = shouldTrack;\n\n    while (parent) {\n      if (parent === this) {\n        return;\n      }\n\n      parent = parent.parent;\n    }\n\n    try {\n      this.parent = activeEffect;\n      activeEffect = this;\n      shouldTrack = true;\n      trackOpBit = 1 << ++effectTrackDepth;\n\n      if (effectTrackDepth <= maxMarkerBits) {\n        initDepMarkers(this);\n      } else {\n        cleanupEffect(this);\n      }\n\n      return this.fn();\n    } finally {\n      if (effectTrackDepth <= maxMarkerBits) {\n        finalizeDepMarkers(this);\n      }\n\n      trackOpBit = 1 << --effectTrackDepth;\n      activeEffect = this.parent;\n      shouldTrack = lastShouldTrack;\n      this.parent = undefined;\n    }\n  }\n\n  stop() {\n    if (this.active) {\n      cleanupEffect(this);\n\n      if (this.onStop) {\n        this.onStop();\n      }\n\n      this.active = false;\n    }\n  }\n\n}\n\nfunction cleanupEffect(effect) {\n  const {\n    deps\n  } = effect;\n\n  if (deps.length) {\n    for (let i = 0; i < deps.length; i++) {\n      deps[i].delete(effect);\n    }\n\n    deps.length = 0;\n  }\n}\n\nlet shouldTrack = true;\nnew Set(Object.getOwnPropertyNames(Symbol).map(key => Symbol[key]).filter(isSymbol));\n\nfunction isReactive(value) {\n  if (isReadonly(value)) {\n    return isReactive(value[\"__v_raw\"\n    /* RAW */\n    ]);\n  }\n\n  return !!(value && value[\"__v_isReactive\"\n  /* IS_REACTIVE */\n  ]);\n}\n\nfunction isReadonly(value) {\n  return !!(value && value[\"__v_isReadonly\"\n  /* IS_READONLY */\n  ]);\n}\n\nfunction isShallow(value) {\n  return !!(value && value[\"__v_isShallow\"\n  /* IS_SHALLOW */\n  ]);\n}\n\nfunction isProxy(value) {\n  return isReactive(value) || isReadonly(value);\n}\n\nfunction markRaw(value) {\n  def(value, \"__v_skip\"\n  /* SKIP */\n  , true);\n  return value;\n}\n\nfunction isRef(r) {\n  return !!(r && r.__v_isRef === true);\n}\n\nfunction unref(ref) {\n  return isRef(ref) ? ref.value : ref;\n}\n\nconst shallowUnwrapHandlers = {\n  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\n  set: (target, key, value, receiver) => {\n    const oldValue = target[key];\n\n    if (isRef(oldValue) && !isRef(value)) {\n      oldValue.value = value;\n      return true;\n    } else {\n      return Reflect.set(target, key, value, receiver);\n    }\n  }\n};\n\nfunction proxyRefs(objectWithRefs) {\n  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);\n}\n\nPromise.resolve();\n\nfunction callWithErrorHandling(fn, instance, type, args) {\n  let res;\n\n  try {\n    res = args ? fn(...args) : fn();\n  } catch (err) {\n    handleError(err, instance, type);\n  }\n\n  return res;\n}\n\nfunction callWithAsyncErrorHandling(fn, instance, type, args) {\n  if (isFunction(fn)) {\n    const res = callWithErrorHandling(fn, instance, type, args);\n\n    if (res && isPromise(res)) {\n      res.catch(err => {\n        handleError(err, instance, type);\n      });\n    }\n\n    return res;\n  }\n\n  const values = [];\n\n  for (let i = 0; i < fn.length; i++) {\n    values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));\n  }\n\n  return values;\n}\n\nfunction handleError(err, instance, type, throwInDev = true) {\n  const contextVNode = instance ? instance.vnode : null;\n\n  if (instance) {\n    let cur = instance.parent; // the exposed instance is the render proxy to keep it consistent with 2.x\n\n    const exposedInstance = instance.proxy; // in production the hook receives only the error code\n\n    const errorInfo = type;\n\n    while (cur) {\n      const errorCapturedHooks = cur.ec;\n\n      if (errorCapturedHooks) {\n        for (let i = 0; i < errorCapturedHooks.length; i++) {\n          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {\n            return;\n          }\n        }\n      }\n\n      cur = cur.parent;\n    } // app-level handling\n\n\n    const appErrorHandler = instance.appContext.config.errorHandler;\n\n    if (appErrorHandler) {\n      callWithErrorHandling(appErrorHandler, null, 10\n      /* APP_ERROR_HANDLER */\n      , [err, exposedInstance, errorInfo]);\n      return;\n    }\n  }\n\n  logError(err, type, contextVNode, throwInDev);\n}\n\nfunction logError(err, type, contextVNode, throwInDev = true) {\n  {\n    // recover in prod to reduce the impact on end-user\n    console.error(err);\n  }\n}\n\nlet isFlushing = false;\nlet isFlushPending = false;\nconst queue = [];\nlet flushIndex = 0;\nconst pendingPreFlushCbs = [];\nlet activePreFlushCbs = null;\nlet preFlushIndex = 0;\nconst pendingPostFlushCbs = [];\nlet activePostFlushCbs = null;\nlet postFlushIndex = 0;\nconst resolvedPromise = Promise.resolve();\nlet currentFlushPromise = null;\nlet currentPreFlushParentJob = null;\n\nfunction nextTick(fn) {\n  const p = currentFlushPromise || resolvedPromise;\n  return fn ? p.then(this ? fn.bind(this) : fn) : p;\n} // #2768\n// Use binary-search to find a suitable position in the queue,\n// so that the queue maintains the increasing order of job's id,\n// which can prevent the job from being skipped and also can avoid repeated patching.\n\n\nfunction findInsertionIndex(id) {\n  // the start index should be `flushIndex + 1`\n  let start = flushIndex + 1;\n  let end = queue.length;\n\n  while (start < end) {\n    const middle = start + end >>> 1;\n    const middleJobId = getId(queue[middle]);\n    middleJobId < id ? start = middle + 1 : end = middle;\n  }\n\n  return start;\n}\n\nfunction queueJob(job) {\n  // the dedupe search uses the startIndex argument of Array.includes()\n  // by default the search index includes the current job that is being run\n  // so it cannot recursively trigger itself again.\n  // if the job is a watch() callback, the search will start with a +1 index to\n  // allow it recursively trigger itself - it is the user's responsibility to\n  // ensure it doesn't end up in an infinite loop.\n  if ((!queue.length || !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) && job !== currentPreFlushParentJob) {\n    if (job.id == null) {\n      queue.push(job);\n    } else {\n      queue.splice(findInsertionIndex(job.id), 0, job);\n    }\n\n    queueFlush();\n  }\n}\n\nfunction queueFlush() {\n  if (!isFlushing && !isFlushPending) {\n    isFlushPending = true;\n    currentFlushPromise = resolvedPromise.then(flushJobs);\n  }\n}\n\nfunction queueCb(cb, activeQueue, pendingQueue, index) {\n  if (!isArray(cb)) {\n    if (!activeQueue || !activeQueue.includes(cb, cb.allowRecurse ? index + 1 : index)) {\n      pendingQueue.push(cb);\n    }\n  } else {\n    // if cb is an array, it is a component lifecycle hook which can only be\n    // triggered by a job, which is already deduped in the main queue, so\n    // we can skip duplicate check here to improve perf\n    pendingQueue.push(...cb);\n  }\n\n  queueFlush();\n}\n\nfunction queuePreFlushCb(cb) {\n  queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex);\n}\n\nfunction queuePostFlushCb(cb) {\n  queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex);\n}\n\nfunction flushPreFlushCbs(seen, parentJob = null) {\n  if (pendingPreFlushCbs.length) {\n    currentPreFlushParentJob = parentJob;\n    activePreFlushCbs = [...new Set(pendingPreFlushCbs)];\n    pendingPreFlushCbs.length = 0;\n\n    for (preFlushIndex = 0; preFlushIndex < activePreFlushCbs.length; preFlushIndex++) {\n      activePreFlushCbs[preFlushIndex]();\n    }\n\n    activePreFlushCbs = null;\n    preFlushIndex = 0;\n    currentPreFlushParentJob = null; // recursively flush until it drains\n\n    flushPreFlushCbs(seen, parentJob);\n  }\n}\n\nfunction flushPostFlushCbs(seen) {\n  if (pendingPostFlushCbs.length) {\n    const deduped = [...new Set(pendingPostFlushCbs)];\n    pendingPostFlushCbs.length = 0; // #1947 already has active queue, nested flushPostFlushCbs call\n\n    if (activePostFlushCbs) {\n      activePostFlushCbs.push(...deduped);\n      return;\n    }\n\n    activePostFlushCbs = deduped;\n    activePostFlushCbs.sort((a, b) => getId(a) - getId(b));\n\n    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {\n      activePostFlushCbs[postFlushIndex]();\n    }\n\n    activePostFlushCbs = null;\n    postFlushIndex = 0;\n  }\n}\n\nconst getId = job => job.id == null ? Infinity : job.id;\n\nfunction flushJobs(seen) {\n  isFlushPending = false;\n  isFlushing = true;\n  flushPreFlushCbs(seen); // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child so its render effect will have smaller\n  //    priority number)\n  // 2. If a component is unmounted during a parent component's update,\n  //    its update can be skipped.\n\n  queue.sort((a, b) => getId(a) - getId(b)); // conditional usage of checkRecursiveUpdate must be determined out of\n  // try ... catch block since Rollup by default de-optimizes treeshaking\n  // inside try-catch. This can leave all warning code unshaked. Although\n  // they would get eventually shaken by a minifier like terser, some minifiers\n  // would fail to do that (e.g. https://github.com/evanw/esbuild/issues/1610)\n\n  const check = NOOP;\n\n  try {\n    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {\n      const job = queue[flushIndex];\n\n      if (job && job.active !== false) {\n        if (\"production\" !== 'production' && check(job)) ; // console.log(`running:`, job.id)\n\n        callWithErrorHandling(job, null, 14\n        /* SCHEDULER */\n        );\n      }\n    }\n  } finally {\n    flushIndex = 0;\n    queue.length = 0;\n    flushPostFlushCbs();\n    isFlushing = false;\n    currentFlushPromise = null; // some postFlushCb queued jobs!\n    // keep flushing until it drains.\n\n    if (queue.length || pendingPreFlushCbs.length || pendingPostFlushCbs.length) {\n      flushJobs(seen);\n    }\n  }\n}\n/**\r\n * mark the current rendering instance for asset resolution (e.g.\r\n * resolveComponent, resolveDirective) during render\r\n */\n\n\nlet currentRenderingInstance = null;\nlet currentScopeId = null;\n\nconst isSuspense = type => type.__isSuspense;\n\nfunction queueEffectWithSuspense(fn, suspense) {\n  if (suspense && suspense.pendingBranch) {\n    if (isArray(fn)) {\n      suspense.effects.push(...fn);\n    } else {\n      suspense.effects.push(fn);\n    }\n  } else {\n    queuePostFlushCb(fn);\n  }\n} // initial value for watchers to trigger on undefined initial values\n\n\nconst INITIAL_WATCHER_VALUE = {};\n\nfunction doWatch(source, cb, {\n  immediate,\n  deep,\n  flush,\n  onTrack,\n  onTrigger\n} = EMPTY_OBJ) {\n  const instance = currentInstance;\n  let getter;\n  let forceTrigger = false;\n  let isMultiSource = false;\n\n  if (isRef(source)) {\n    getter = () => source.value;\n\n    forceTrigger = isShallow(source);\n  } else if (isReactive(source)) {\n    getter = () => source;\n\n    deep = true;\n  } else if (isArray(source)) {\n    isMultiSource = true;\n    forceTrigger = source.some(isReactive);\n\n    getter = () => source.map(s => {\n      if (isRef(s)) {\n        return s.value;\n      } else if (isReactive(s)) {\n        return traverse(s);\n      } else if (isFunction(s)) {\n        return callWithErrorHandling(s, instance, 2\n        /* WATCH_GETTER */\n        );\n      } else ;\n    });\n  } else if (isFunction(source)) {\n    if (cb) {\n      // getter with cb\n      getter = () => callWithErrorHandling(source, instance, 2\n      /* WATCH_GETTER */\n      );\n    } else {\n      // no cb -> simple effect\n      getter = () => {\n        if (instance && instance.isUnmounted) {\n          return;\n        }\n\n        if (cleanup) {\n          cleanup();\n        }\n\n        return callWithAsyncErrorHandling(source, instance, 3\n        /* WATCH_CALLBACK */\n        , [onCleanup]);\n      };\n    }\n  } else {\n    getter = NOOP;\n  }\n\n  if (cb && deep) {\n    const baseGetter = getter;\n\n    getter = () => traverse(baseGetter());\n  }\n\n  let cleanup;\n\n  let onCleanup = fn => {\n    cleanup = effect.onStop = () => {\n      callWithErrorHandling(fn, instance, 4\n      /* WATCH_CLEANUP */\n      );\n    };\n  };\n\n  let oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;\n\n  const job = () => {\n    if (!effect.active) {\n      return;\n    }\n\n    if (cb) {\n      // watch(source, cb)\n      const newValue = effect.run();\n\n      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue)) || false) {\n        // cleanup before running cb again\n        if (cleanup) {\n          cleanup();\n        }\n\n        callWithAsyncErrorHandling(cb, instance, 3\n        /* WATCH_CALLBACK */\n        , [newValue, // pass undefined as the old value when it's changed for the first time\n        oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue, onCleanup]);\n        oldValue = newValue;\n      }\n    } else {\n      // watchEffect\n      effect.run();\n    }\n  }; // important: mark the job as a watcher callback so that scheduler knows\n  // it is allowed to self-trigger (#1727)\n\n\n  job.allowRecurse = !!cb;\n  let scheduler;\n\n  if (flush === 'sync') {\n    scheduler = job; // the scheduler function gets called directly\n  } else if (flush === 'post') {\n    scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);\n  } else {\n    // default: 'pre'\n    scheduler = () => {\n      if (!instance || instance.isMounted) {\n        queuePreFlushCb(job);\n      } else {\n        // with 'pre' option, the first call must happen before\n        // the component is mounted so it is called synchronously.\n        job();\n      }\n    };\n  }\n\n  const effect = new ReactiveEffect(getter, scheduler); // initial run\n\n  if (cb) {\n    if (immediate) {\n      job();\n    } else {\n      oldValue = effect.run();\n    }\n  } else if (flush === 'post') {\n    queuePostRenderEffect(effect.run.bind(effect), instance && instance.suspense);\n  } else {\n    effect.run();\n  }\n\n  return () => {\n    effect.stop();\n\n    if (instance && instance.scope) {\n      remove(instance.scope.effects, effect);\n    }\n  };\n} // this.$watch\n\n\nfunction instanceWatch(source, value, options) {\n  const publicThis = this.proxy;\n  const getter = isString(source) ? source.includes('.') ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);\n  let cb;\n\n  if (isFunction(value)) {\n    cb = value;\n  } else {\n    cb = value.handler;\n    options = value;\n  }\n\n  const cur = currentInstance;\n  setCurrentInstance(this);\n  const res = doWatch(getter, cb.bind(publicThis), options);\n\n  if (cur) {\n    setCurrentInstance(cur);\n  } else {\n    unsetCurrentInstance();\n  }\n\n  return res;\n}\n\nfunction createPathGetter(ctx, path) {\n  const segments = path.split('.');\n  return () => {\n    let cur = ctx;\n\n    for (let i = 0; i < segments.length && cur; i++) {\n      cur = cur[segments[i]];\n    }\n\n    return cur;\n  };\n}\n\nfunction traverse(value, seen) {\n  if (!isObject(value) || value[\"__v_skip\"\n  /* SKIP */\n  ]) {\n    return value;\n  }\n\n  seen = seen || new Set();\n\n  if (seen.has(value)) {\n    return value;\n  }\n\n  seen.add(value);\n\n  if (isRef(value)) {\n    traverse(value.value, seen);\n  } else if (isArray(value)) {\n    for (let i = 0; i < value.length; i++) {\n      traverse(value[i], seen);\n    }\n  } else if (isSet(value) || isMap(value)) {\n    value.forEach(v => {\n      traverse(v, seen);\n    });\n  } else if (isPlainObject(value)) {\n    for (const key in value) {\n      traverse(value[key], seen);\n    }\n  }\n\n  return value;\n} // implementation, close to no-op\n\n\nfunction defineComponent(options) {\n  return isFunction(options) ? {\n    setup: options,\n    name: options.name\n  } : options;\n}\n/**\r\n * Resolve merged options and cache it on the component.\r\n * This is done only once per-component since the merging does not involve\r\n * instances.\r\n */\n\n\nfunction resolveMergedOptions(instance) {\n  const base = instance.type;\n  const {\n    mixins,\n    extends: extendsOptions\n  } = base;\n  const {\n    mixins: globalMixins,\n    optionsCache: cache,\n    config: {\n      optionMergeStrategies\n    }\n  } = instance.appContext;\n  const cached = cache.get(base);\n  let resolved;\n\n  if (cached) {\n    resolved = cached;\n  } else if (!globalMixins.length && !mixins && !extendsOptions) {\n    {\n      resolved = base;\n    }\n  } else {\n    resolved = {};\n\n    if (globalMixins.length) {\n      globalMixins.forEach(m => mergeOptions(resolved, m, optionMergeStrategies, true));\n    }\n\n    mergeOptions(resolved, base, optionMergeStrategies);\n  }\n\n  cache.set(base, resolved);\n  return resolved;\n}\n\nfunction mergeOptions(to, from, strats, asMixin = false) {\n  const {\n    mixins,\n    extends: extendsOptions\n  } = from;\n\n  if (extendsOptions) {\n    mergeOptions(to, extendsOptions, strats, true);\n  }\n\n  if (mixins) {\n    mixins.forEach(m => mergeOptions(to, m, strats, true));\n  }\n\n  for (const key in from) {\n    if (asMixin && key === 'expose') ;else {\n      const strat = internalOptionMergeStrats[key] || strats && strats[key];\n      to[key] = strat ? strat(to[key], from[key]) : from[key];\n    }\n  }\n\n  return to;\n}\n\nconst internalOptionMergeStrats = {\n  data: mergeDataFn,\n  props: mergeObjectOptions,\n  emits: mergeObjectOptions,\n  // objects\n  methods: mergeObjectOptions,\n  computed: mergeObjectOptions,\n  // lifecycle\n  beforeCreate: mergeAsArray,\n  created: mergeAsArray,\n  beforeMount: mergeAsArray,\n  mounted: mergeAsArray,\n  beforeUpdate: mergeAsArray,\n  updated: mergeAsArray,\n  beforeDestroy: mergeAsArray,\n  beforeUnmount: mergeAsArray,\n  destroyed: mergeAsArray,\n  unmounted: mergeAsArray,\n  activated: mergeAsArray,\n  deactivated: mergeAsArray,\n  errorCaptured: mergeAsArray,\n  serverPrefetch: mergeAsArray,\n  // assets\n  components: mergeObjectOptions,\n  directives: mergeObjectOptions,\n  // watch\n  watch: mergeWatchOptions,\n  // provide / inject\n  provide: mergeDataFn,\n  inject: mergeInject\n};\n\nfunction mergeDataFn(to, from) {\n  if (!from) {\n    return to;\n  }\n\n  if (!to) {\n    return from;\n  }\n\n  return function mergedDataFn() {\n    return extend(isFunction(to) ? to.call(this, this) : to, isFunction(from) ? from.call(this, this) : from);\n  };\n}\n\nfunction mergeInject(to, from) {\n  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));\n}\n\nfunction normalizeInject(raw) {\n  if (isArray(raw)) {\n    const res = {};\n\n    for (let i = 0; i < raw.length; i++) {\n      res[raw[i]] = raw[i];\n    }\n\n    return res;\n  }\n\n  return raw;\n}\n\nfunction mergeAsArray(to, from) {\n  return to ? [...new Set([].concat(to, from))] : from;\n}\n\nfunction mergeObjectOptions(to, from) {\n  return to ? extend(extend(Object.create(null), to), from) : from;\n}\n\nfunction mergeWatchOptions(to, from) {\n  if (!to) return from;\n  if (!from) return to;\n  const merged = extend(Object.create(null), to);\n\n  for (const key in from) {\n    merged[key] = mergeAsArray(to[key], from[key]);\n  }\n\n  return merged;\n}\n\nconst queuePostRenderEffect = queueEffectWithSuspense;\n\nconst isTeleport = type => type.__isTeleport;\n\nconst NULL_DYNAMIC_COMPONENT = Symbol();\nconst Fragment = Symbol(undefined);\nconst Text = Symbol(undefined);\nconst Comment = Symbol(undefined); // Since v-if and v-for are the two possible ways node structure can dynamically\n// change, once we consider v-if branches and each v-for fragment a block, we\n// can divide a template into nested blocks, and within each block the node\n// structure would be stable. This allows us to skip most children diffing\n// and only worry about the dynamic nodes (indicated by patch flags).\n\nconst blockStack = [];\nlet currentBlock = null;\n/**\r\n * Open a block.\r\n * This must be called before `createBlock`. It cannot be part of `createBlock`\r\n * because the children of the block are evaluated before `createBlock` itself\r\n * is called. The generated code typically looks like this:\r\n *\r\n * ```js\r\n * function render() {\r\n *   return (openBlock(),createBlock('div', null, [...]))\r\n * }\r\n * ```\r\n * disableTracking is true when creating a v-for fragment block, since a v-for\r\n * fragment always diffs its children.\r\n *\r\n * @private\r\n */\n\nfunction openBlock(disableTracking = false) {\n  blockStack.push(currentBlock = disableTracking ? null : []);\n}\n\nfunction closeBlock() {\n  blockStack.pop();\n  currentBlock = blockStack[blockStack.length - 1] || null;\n}\n\nfunction setupBlock(vnode) {\n  // save current block children on the block vnode\n  vnode.dynamicChildren = currentBlock || EMPTY_ARR; // close block\n\n  closeBlock(); // a block is always going to be patched, so track it as a child of its\n  // parent block\n\n  if (currentBlock) {\n    currentBlock.push(vnode);\n  }\n\n  return vnode;\n}\n/**\r\n * @private\r\n */\n\n\nfunction createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {\n  return setupBlock(createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, true\n  /* isBlock */\n  ));\n}\n\nfunction isVNode(value) {\n  return value ? value.__v_isVNode === true : false;\n}\n\nconst InternalObjectKey = `__vInternal`;\n\nconst normalizeKey = ({\n  key\n}) => key != null ? key : null;\n\nconst normalizeRef = ({\n  ref,\n  ref_key,\n  ref_for\n}) => {\n  return ref != null ? isString(ref) || isRef(ref) || isFunction(ref) ? {\n    i: currentRenderingInstance,\n    r: ref,\n    k: ref_key,\n    f: !!ref_for\n  } : ref : null;\n};\n\nfunction createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1\n/* ELEMENT */\n, isBlockNode = false, needFullChildrenNormalization = false) {\n  const vnode = {\n    __v_isVNode: true,\n    __v_skip: true,\n    type,\n    props,\n    key: props && normalizeKey(props),\n    ref: props && normalizeRef(props),\n    scopeId: currentScopeId,\n    slotScopeIds: null,\n    children,\n    component: null,\n    suspense: null,\n    ssContent: null,\n    ssFallback: null,\n    dirs: null,\n    transition: null,\n    el: null,\n    anchor: null,\n    target: null,\n    targetAnchor: null,\n    staticCount: 0,\n    shapeFlag,\n    patchFlag,\n    dynamicProps,\n    dynamicChildren: null,\n    appContext: null\n  };\n\n  if (needFullChildrenNormalization) {\n    normalizeChildren(vnode, children); // normalize suspense children\n\n    if (shapeFlag & 128\n    /* SUSPENSE */\n    ) {\n      type.normalize(vnode);\n    }\n  } else if (children) {\n    // compiled element vnode - if children is passed, only possible types are\n    // string or Array.\n    vnode.shapeFlag |= isString(children) ? 8\n    /* TEXT_CHILDREN */\n    : 16\n    /* ARRAY_CHILDREN */\n    ;\n  } // track vnode for block tree\n\n\n  if ( // avoid a block node from tracking itself\n  !isBlockNode && // has current parent block\n  currentBlock && ( // presence of a patch flag indicates this node needs patching on updates.\n  // component nodes also should always be patched, because even if the\n  // component doesn't need to update, it needs to persist the instance on to\n  // the next vnode so that it can be properly unmounted later.\n  vnode.patchFlag > 0 || shapeFlag & 6\n  /* COMPONENT */\n  ) && // the EVENTS flag is only for hydration and if it is the only flag, the\n  // vnode should not be considered dynamic due to handler caching.\n  vnode.patchFlag !== 32\n  /* HYDRATE_EVENTS */\n  ) {\n    currentBlock.push(vnode);\n  }\n\n  return vnode;\n}\n\nconst createVNode = _createVNode;\n\nfunction _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {\n  if (!type || type === NULL_DYNAMIC_COMPONENT) {\n    type = Comment;\n  }\n\n  if (isVNode(type)) {\n    // createVNode receiving an existing vnode. This happens in cases like\n    // <component :is=\"vnode\"/>\n    // #2078 make sure to merge refs during the clone instead of overwriting it\n    const cloned = cloneVNode(type, props, true\n    /* mergeRef: true */\n    );\n\n    if (children) {\n      normalizeChildren(cloned, children);\n    }\n\n    return cloned;\n  } // class component normalization.\n\n\n  if (isClassComponent(type)) {\n    type = type.__vccOpts;\n  } // class & style normalization.\n\n\n  if (props) {\n    // for reactive or proxy objects, we need to clone it to enable mutation.\n    props = guardReactiveProps(props);\n    let {\n      class: klass,\n      style\n    } = props;\n\n    if (klass && !isString(klass)) {\n      props.class = normalizeClass(klass);\n    }\n\n    if (isObject(style)) {\n      // reactive state objects need to be cloned since they are likely to be\n      // mutated\n      if (isProxy(style) && !isArray(style)) {\n        style = extend({}, style);\n      }\n\n      props.style = normalizeStyle(style);\n    }\n  } // encode the vnode type information into a bitmap\n\n\n  const shapeFlag = isString(type) ? 1\n  /* ELEMENT */\n  : isSuspense(type) ? 128\n  /* SUSPENSE */\n  : isTeleport(type) ? 64\n  /* TELEPORT */\n  : isObject(type) ? 4\n  /* STATEFUL_COMPONENT */\n  : isFunction(type) ? 2\n  /* FUNCTIONAL_COMPONENT */\n  : 0;\n  return createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);\n}\n\nfunction guardReactiveProps(props) {\n  if (!props) return null;\n  return isProxy(props) || InternalObjectKey in props ? extend({}, props) : props;\n}\n\nfunction cloneVNode(vnode, extraProps, mergeRef = false) {\n  // This is intentionally NOT using spread or extend to avoid the runtime\n  // key enumeration cost.\n  const {\n    props,\n    ref,\n    patchFlag,\n    children\n  } = vnode;\n  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;\n  const cloned = {\n    __v_isVNode: true,\n    __v_skip: true,\n    type: vnode.type,\n    props: mergedProps,\n    key: mergedProps && normalizeKey(mergedProps),\n    ref: extraProps && extraProps.ref ? // #2078 in the case of <component :is=\"vnode\" ref=\"extra\"/>\n    // if the vnode itself already has a ref, cloneVNode will need to merge\n    // the refs so the single vnode can be set on multiple refs\n    mergeRef && ref ? isArray(ref) ? ref.concat(normalizeRef(extraProps)) : [ref, normalizeRef(extraProps)] : normalizeRef(extraProps) : ref,\n    scopeId: vnode.scopeId,\n    slotScopeIds: vnode.slotScopeIds,\n    children: children,\n    target: vnode.target,\n    targetAnchor: vnode.targetAnchor,\n    staticCount: vnode.staticCount,\n    shapeFlag: vnode.shapeFlag,\n    // if the vnode is cloned with extra props, we can no longer assume its\n    // existing patch flag to be reliable and need to add the FULL_PROPS flag.\n    // note: preserve flag for fragments since they use the flag for children\n    // fast paths only.\n    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 // hoisted node\n    ? 16\n    /* FULL_PROPS */\n    : patchFlag | 16\n    /* FULL_PROPS */\n    : patchFlag,\n    dynamicProps: vnode.dynamicProps,\n    dynamicChildren: vnode.dynamicChildren,\n    appContext: vnode.appContext,\n    dirs: vnode.dirs,\n    transition: vnode.transition,\n    // These should technically only be non-null on mounted VNodes. However,\n    // they *should* be copied for kept-alive vnodes. So we just always copy\n    // them since them being non-null during a mount doesn't affect the logic as\n    // they will simply be overwritten.\n    component: vnode.component,\n    suspense: vnode.suspense,\n    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),\n    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),\n    el: vnode.el,\n    anchor: vnode.anchor\n  };\n  return cloned;\n}\n/**\r\n * @private\r\n */\n\n\nfunction createTextVNode(text = ' ', flag = 0) {\n  return createVNode(Text, null, text, flag);\n}\n\nfunction normalizeChildren(vnode, children) {\n  let type = 0;\n  const {\n    shapeFlag\n  } = vnode;\n\n  if (children == null) {\n    children = null;\n  } else if (isArray(children)) {\n    type = 16\n    /* ARRAY_CHILDREN */\n    ;\n  } else if (typeof children === 'object') {\n    if (shapeFlag & (1\n    /* ELEMENT */\n    | 64\n    /* TELEPORT */\n    )) {\n      // Normalize slot to plain children for plain element and Teleport\n      const slot = children.default;\n\n      if (slot) {\n        // _c marker is added by withCtx() indicating this is a compiled slot\n        slot._c && (slot._d = false);\n        normalizeChildren(vnode, slot());\n        slot._c && (slot._d = true);\n      }\n\n      return;\n    } else {\n      type = 32\n      /* SLOTS_CHILDREN */\n      ;\n      const slotFlag = children._;\n\n      if (!slotFlag && !(InternalObjectKey in children)) {\n        children._ctx = currentRenderingInstance;\n      } else if (slotFlag === 3\n      /* FORWARDED */\n      && currentRenderingInstance) {\n        // a child component receives forwarded slots from the parent.\n        // its slot type is determined by its parent's slot type.\n        if (currentRenderingInstance.slots._ === 1\n        /* STABLE */\n        ) {\n          children._ = 1\n          /* STABLE */\n          ;\n        } else {\n          children._ = 2\n          /* DYNAMIC */\n          ;\n          vnode.patchFlag |= 1024\n          /* DYNAMIC_SLOTS */\n          ;\n        }\n      }\n    }\n  } else if (isFunction(children)) {\n    children = {\n      default: children,\n      _ctx: currentRenderingInstance\n    };\n    type = 32\n    /* SLOTS_CHILDREN */\n    ;\n  } else {\n    children = String(children); // force teleport children to array so it can be moved around\n\n    if (shapeFlag & 64\n    /* TELEPORT */\n    ) {\n      type = 16\n      /* ARRAY_CHILDREN */\n      ;\n      children = [createTextVNode(children)];\n    } else {\n      type = 8\n      /* TEXT_CHILDREN */\n      ;\n    }\n  }\n\n  vnode.children = children;\n  vnode.shapeFlag |= type;\n}\n\nfunction mergeProps(...args) {\n  const ret = {};\n\n  for (let i = 0; i < args.length; i++) {\n    const toMerge = args[i];\n\n    for (const key in toMerge) {\n      if (key === 'class') {\n        if (ret.class !== toMerge.class) {\n          ret.class = normalizeClass([ret.class, toMerge.class]);\n        }\n      } else if (key === 'style') {\n        ret.style = normalizeStyle([ret.style, toMerge.style]);\n      } else if (isOn(key)) {\n        const existing = ret[key];\n        const incoming = toMerge[key];\n\n        if (incoming && existing !== incoming && !(isArray(existing) && existing.includes(incoming))) {\n          ret[key] = existing ? [].concat(existing, incoming) : incoming;\n        }\n      } else if (key !== '') {\n        ret[key] = toMerge[key];\n      }\n    }\n  }\n\n  return ret;\n}\n/**\r\n * #2437 In Vue 3, functional components do not have a public instance proxy but\r\n * they exist in the internal parent chain. For code that relies on traversing\r\n * public $parent chains, skip functional ones and go to the parent instead.\r\n */\n\n\nconst getPublicInstance = i => {\n  if (!i) return null;\n  if (isStatefulComponent(i)) return getExposeProxy(i) || i.proxy;\n  return getPublicInstance(i.parent);\n};\n\nconst publicPropertiesMap = extend(Object.create(null), {\n  $: i => i,\n  $el: i => i.vnode.el,\n  $data: i => i.data,\n  $props: i => i.props,\n  $attrs: i => i.attrs,\n  $slots: i => i.slots,\n  $refs: i => i.refs,\n  $parent: i => getPublicInstance(i.parent),\n  $root: i => getPublicInstance(i.root),\n  $emit: i => i.emit,\n  $options: i => __VUE_OPTIONS_API__ ? resolveMergedOptions(i) : i.type,\n  $forceUpdate: i => () => queueJob(i.update),\n  $nextTick: i => nextTick.bind(i.proxy),\n  $watch: i => __VUE_OPTIONS_API__ ? instanceWatch.bind(i) : NOOP\n});\nlet currentInstance = null;\n\nconst setCurrentInstance = instance => {\n  currentInstance = instance;\n  instance.scope.on();\n};\n\nconst unsetCurrentInstance = () => {\n  currentInstance && currentInstance.scope.off();\n  currentInstance = null;\n};\n\nfunction isStatefulComponent(instance) {\n  return instance.vnode.shapeFlag & 4\n  /* STATEFUL_COMPONENT */\n  ;\n}\n\nfunction getExposeProxy(instance) {\n  if (instance.exposed) {\n    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {\n      get(target, key) {\n        if (key in target) {\n          return target[key];\n        } else if (key in publicPropertiesMap) {\n          return publicPropertiesMap[key](instance);\n        }\n      }\n\n    }));\n  }\n}\n\nfunction isClassComponent(value) {\n  return isFunction(value) && '__vccOpts' in value;\n}\n\nvar script = /* #__PURE__ */defineComponent({\n  name: 'BootstrapIcon',\n  props: {\n    icon: {\n      type: String,\n      required: true\n    },\n    variant: {\n      type: String,\n      validator: value => ['success', 'warning', 'danger', 'info', 'primary', 'secondary', 'dark', 'light'].indexOf(value) !== -1\n    },\n    size: {\n      type: String,\n      validator: value => ['sm', 'md', 'lg', '2x', '3x', '4x', '5x'].indexOf(value) !== -1\n    },\n    flipH: {\n      type: Boolean\n    },\n    flipV: {\n      type: Boolean\n    },\n    rotate: {\n      type: [String, Number],\n      validator: value => value >= -360 && value <= 360\n    },\n    animation: {\n      type: String,\n      validator: value => ['cylon', 'cylon-vertical', 'fade', 'spin', 'spin-reverse', 'spin-pulse', 'spin-reverse-pulse', 'throb'].indexOf(value) !== -1\n    }\n  },\n  computed: {\n    cssClasses() {\n      const classes = [];\n      if (this.variant) classes.push(`bi--variant-${this.variant}`);\n      if (this.size) classes.push(`bi--size-${this.size}`);\n      if (this.animation) classes.push(`bi--animation-${this.animation}`);\n      return classes;\n    },\n\n    svgTransform() {\n      if (!this.flipH && !this.flipV && !this.rotate) return '';\n      let scale;\n      let rotate;\n\n      if (this.flipV && this.flipH) {\n        scale = '-1 -1';\n      } else if (this.flipH) {\n        scale = '-1 1';\n      } else if (this.flipV) {\n        scale = '1 -1';\n      }\n\n      if (this.rotate) {\n        rotate = this.rotate;\n      }\n\n      return (scale ? `scale(${scale})` : '') + (rotate ? `rotate(${rotate})` : '');\n    },\n\n    svgSprite() {\n      return BootstrapIcons;\n    }\n\n  },\n  methods: {\n    upperFirst(str) {\n      if (typeof str !== 'string') return str;\n      return str.charAt(0).toUpperCase() + str.slice(1);\n    }\n\n  }\n});\nconst _hoisted_1 = [\"transform\"];\nconst _hoisted_2 = [\"xlink:href\"];\n\nfunction render(_ctx, _cache, $props, $setup, $data, $options) {\n  return openBlock(), createElementBlock(\"svg\", {\n    class: normalizeClass([\"bi\", _ctx.cssClasses])\n  }, [createBaseVNode(\"g\", {\n    transform: _ctx.svgTransform,\n    \"transform-origin\": \"center\"\n  }, [createBaseVNode(\"use\", {\n    \"xlink:href\": `${_ctx.svgSprite}#${_ctx.icon}`\n  }, null, 8, _hoisted_2)], 8, _hoisted_1)], 2);\n}\n\nfunction styleInject(css, ref) {\n  if (ref === void 0) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') {\n    return;\n  }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar css_248z = \".bi {\\n  fill: currentColor;\\n  width: 1em;\\n  height: 1em;\\n  font-size: 1em;\\n  margin-bottom: 0.125em;\\n  vertical-align: middle;\\n}\\n.bi--variant-success {\\n  color: var(--bs-success);\\n}\\n.bi--variant-warning {\\n  color: var(--bs-warning);\\n}\\n.bi--variant-danger {\\n  color: var(--bs-danger);\\n}\\n.bi--variant-info {\\n  color: var(--bs-info);\\n}\\n.bi--variant-primary {\\n  color: var(--bs-primary);\\n}\\n.bi--variant-secondary {\\n  color: var(--bs-secondary);\\n}\\n.bi--variant-dark {\\n  color: var(--bs-dark);\\n}\\n.bi--variant-light {\\n  color: var(--bs-light);\\n}\\n.bi--size-sm {\\n  font-size: 0.75em;\\n}\\n.bi--size-md {\\n  font-size: 1.25rem;\\n}\\n.bi--size-lg {\\n  font-size: 1.33333333rem;\\n}\\n.bi--size-2x {\\n  font-size: 2rem;\\n}\\n.bi--size-3x {\\n  font-size: 3rem;\\n}\\n.bi--size-4x {\\n  font-size: 4rem;\\n}\\n.bi--size-5x {\\n  font-size: 5rem;\\n}\\n.bi--animation-cylon {\\n  animation: bi-animation-cylon 0.75s ease-in-out infinite alternate;\\n}\\n.bi--animation-cylon-vertical {\\n  animation: bi-animation-cylon-vertical 0.75s ease-in-out infinite alternate;\\n}\\n.bi--animation-fade {\\n  animation: bi-animation-fade 0.75s ease-in-out infinite alternate;\\n}\\n.bi--animation-spin {\\n  animation: bi-animation-spin 2s linear infinite normal;\\n}\\n.bi--animation-spin-reverse {\\n  animation: bi-animation-spin 2s linear infinite reverse;\\n}\\n.bi--animation-spin-pulse {\\n  animation: bi-animation-spin 1s steps(8) infinite normal;\\n}\\n.bi--animation-spin-reverse-pulse {\\n  animation: bi-animation-spin 1s steps(8) infinite reverse;\\n}\\n.bi--animation-throb {\\n  animation: bi-animation-throb 0.75s ease-in-out infinite alternate;\\n}\\n\\n@keyframes bi-animation-cylon {\\n  0% {\\n    transform: translateX(-25%);\\n  }\\n  100% {\\n    transform: translateX(25%);\\n  }\\n}\\n@keyframes bi-animation-cylon-vertical {\\n  0% {\\n    transform: translateY(25%);\\n  }\\n  100% {\\n    transform: translateY(-25%);\\n  }\\n}\\n@keyframes bi-animation-fade {\\n  0% {\\n    opacity: 0.1;\\n  }\\n  100% {\\n    opacity: 1;\\n  }\\n}\\n@keyframes bi-animation-spin {\\n  0% {\\n    transform: rotate(0deg);\\n  }\\n  100% {\\n    transform: rotate(359deg);\\n  }\\n}\\n@keyframes bi-animation-throb {\\n  0% {\\n    opacity: 0.5;\\n    transform: scale(0.5);\\n  }\\n  100% {\\n    opacity: 1;\\n    transform: scale(1);\\n  }\\n}\";\nstyleInject(css_248z);\nscript.render = render; // Import vue component\n// IIFE injects install function into component, allowing component\n// to be registered via Vue.use() as well as Vue.component().\n\nvar entry_esm = /* #__PURE__ */(() => {\n  // Get component instance\n  const installable = script; // Attach install function executed by Vue.use()\n\n  installable.install = app => {\n    app.component('BootstrapIcon', installable);\n  };\n\n  return installable;\n})(); // It's possible to expose named exports when writing components that can\n// also be used as directives, etc. - eg. import { RollupDemoDirective } from 'rollup-demo';\n// export const RollupDemoDirective = directive;\n\n\nexport { entry_esm as default };","map":{"version":3,"names":["BootstrapIcons","normalizeStyle","value","isArray","res","i","length","item","normalized","isString","parseStringStyle","key","isObject","listDelimiterRE","propertyDelimiterRE","cssText","ret","split","forEach","tmp","trim","normalizeClass","name","EMPTY_OBJ","EMPTY_ARR","NOOP","onRE","isOn","test","extend","Object","assign","remove","arr","el","indexOf","splice","Array","isMap","val","toTypeString","isSet","isFunction","isSymbol","isPromise","then","catch","objectToString","prototype","toString","call","isPlainObject","hasChanged","oldValue","is","def","obj","defineProperty","configurable","enumerable","activeEffectScope","recordEffectScope","effect","scope","active","effects","push","wasTracked","dep","w","trackOpBit","newTracked","n","initDepMarkers","deps","finalizeDepMarkers","ptr","delete","effectTrackDepth","maxMarkerBits","activeEffect","ReactiveEffect","constructor","fn","scheduler","parent","undefined","run","lastShouldTrack","shouldTrack","cleanupEffect","stop","onStop","Set","getOwnPropertyNames","Symbol","map","filter","isReactive","isReadonly","isShallow","isProxy","markRaw","isRef","r","__v_isRef","unref","ref","shallowUnwrapHandlers","get","target","receiver","Reflect","set","proxyRefs","objectWithRefs","Proxy","Promise","resolve","callWithErrorHandling","instance","type","args","err","handleError","callWithAsyncErrorHandling","values","throwInDev","contextVNode","vnode","cur","exposedInstance","proxy","errorInfo","errorCapturedHooks","ec","appErrorHandler","appContext","config","errorHandler","logError","console","error","isFlushing","isFlushPending","queue","flushIndex","pendingPreFlushCbs","activePreFlushCbs","preFlushIndex","pendingPostFlushCbs","activePostFlushCbs","postFlushIndex","resolvedPromise","currentFlushPromise","currentPreFlushParentJob","nextTick","p","bind","findInsertionIndex","id","start","end","middle","middleJobId","getId","queueJob","job","includes","allowRecurse","queueFlush","flushJobs","queueCb","cb","activeQueue","pendingQueue","index","queuePreFlushCb","queuePostFlushCb","flushPreFlushCbs","seen","parentJob","flushPostFlushCbs","deduped","sort","a","b","Infinity","check","currentRenderingInstance","currentScopeId","isSuspense","__isSuspense","queueEffectWithSuspense","suspense","pendingBranch","INITIAL_WATCHER_VALUE","doWatch","source","immediate","deep","flush","onTrack","onTrigger","currentInstance","getter","forceTrigger","isMultiSource","some","s","traverse","isUnmounted","cleanup","onCleanup","baseGetter","newValue","v","queuePostRenderEffect","isMounted","instanceWatch","options","publicThis","createPathGetter","handler","setCurrentInstance","unsetCurrentInstance","ctx","path","segments","has","add","defineComponent","setup","resolveMergedOptions","base","mixins","extends","extendsOptions","globalMixins","optionsCache","cache","optionMergeStrategies","cached","resolved","m","mergeOptions","to","from","strats","asMixin","strat","internalOptionMergeStrats","data","mergeDataFn","props","mergeObjectOptions","emits","methods","computed","beforeCreate","mergeAsArray","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","beforeUnmount","destroyed","unmounted","activated","deactivated","errorCaptured","serverPrefetch","components","directives","watch","mergeWatchOptions","provide","inject","mergeInject","mergedDataFn","normalizeInject","raw","concat","create","merged","isTeleport","__isTeleport","NULL_DYNAMIC_COMPONENT","Fragment","Text","Comment","blockStack","currentBlock","openBlock","disableTracking","closeBlock","pop","setupBlock","dynamicChildren","createElementBlock","children","patchFlag","dynamicProps","shapeFlag","createBaseVNode","isVNode","__v_isVNode","InternalObjectKey","normalizeKey","normalizeRef","ref_key","ref_for","k","f","isBlockNode","needFullChildrenNormalization","__v_skip","scopeId","slotScopeIds","component","ssContent","ssFallback","dirs","transition","anchor","targetAnchor","staticCount","normalizeChildren","normalize","createVNode","_createVNode","cloned","cloneVNode","isClassComponent","__vccOpts","guardReactiveProps","class","klass","style","extraProps","mergeRef","mergedProps","mergeProps","createTextVNode","text","flag","slot","default","_c","_d","slotFlag","_","_ctx","slots","String","toMerge","existing","incoming","getPublicInstance","isStatefulComponent","getExposeProxy","publicPropertiesMap","$","$el","$data","$props","$attrs","attrs","$slots","$refs","refs","$parent","$root","root","$emit","emit","$options","__VUE_OPTIONS_API__","$forceUpdate","update","$nextTick","$watch","on","off","exposed","exposeProxy","script","icon","required","variant","validator","size","flipH","Boolean","flipV","rotate","Number","animation","cssClasses","classes","svgTransform","scale","svgSprite","upperFirst","str","charAt","toUpperCase","slice","_hoisted_1","_hoisted_2","render","_cache","$setup","transform","styleInject","css","insertAt","document","head","getElementsByTagName","createElement","firstChild","insertBefore","appendChild","styleSheet","createTextNode","css_248z","entry_esm","installable","install","app"],"sources":["E:/web/alchemists_vue/alchemists/node_modules/@dvuckovic/vue3-bootstrap-icons/dist/bootstrap-icon.esm.js"],"sourcesContent":["import BootstrapIcons from 'bootstrap-icons/bootstrap-icons.svg';\n\n/**\r\n * Make a map and return a function for checking if a key\r\n * is in that map.\r\n * IMPORTANT: all calls of this function must be prefixed with\r\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\r\n * So that rollup can tree-shake them if necessary.\r\n */\r\n\nfunction normalizeStyle(value) {\r\n    if (isArray(value)) {\r\n        const res = {};\r\n        for (let i = 0; i < value.length; i++) {\r\n            const item = value[i];\r\n            const normalized = isString(item)\r\n                ? parseStringStyle(item)\r\n                : normalizeStyle(item);\r\n            if (normalized) {\r\n                for (const key in normalized) {\r\n                    res[key] = normalized[key];\r\n                }\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n    else if (isString(value)) {\r\n        return value;\r\n    }\r\n    else if (isObject(value)) {\r\n        return value;\r\n    }\r\n}\r\nconst listDelimiterRE = /;(?![^(]*\\))/g;\r\nconst propertyDelimiterRE = /:(.+)/;\r\nfunction parseStringStyle(cssText) {\r\n    const ret = {};\r\n    cssText.split(listDelimiterRE).forEach(item => {\r\n        if (item) {\r\n            const tmp = item.split(propertyDelimiterRE);\r\n            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());\r\n        }\r\n    });\r\n    return ret;\r\n}\r\nfunction normalizeClass(value) {\r\n    let res = '';\r\n    if (isString(value)) {\r\n        res = value;\r\n    }\r\n    else if (isArray(value)) {\r\n        for (let i = 0; i < value.length; i++) {\r\n            const normalized = normalizeClass(value[i]);\r\n            if (normalized) {\r\n                res += normalized + ' ';\r\n            }\r\n        }\r\n    }\r\n    else if (isObject(value)) {\r\n        for (const name in value) {\r\n            if (value[name]) {\r\n                res += name + ' ';\r\n            }\r\n        }\r\n    }\r\n    return res.trim();\r\n}\r\n\nconst EMPTY_OBJ = {};\r\nconst EMPTY_ARR = [];\r\nconst NOOP = () => { };\r\nconst onRE = /^on[^a-z]/;\r\nconst isOn = (key) => onRE.test(key);\r\nconst extend = Object.assign;\r\nconst remove = (arr, el) => {\r\n    const i = arr.indexOf(el);\r\n    if (i > -1) {\r\n        arr.splice(i, 1);\r\n    }\r\n};\r\nconst isArray = Array.isArray;\r\nconst isMap = (val) => toTypeString(val) === '[object Map]';\r\nconst isSet = (val) => toTypeString(val) === '[object Set]';\r\nconst isFunction = (val) => typeof val === 'function';\r\nconst isString = (val) => typeof val === 'string';\r\nconst isSymbol = (val) => typeof val === 'symbol';\r\nconst isObject = (val) => val !== null && typeof val === 'object';\r\nconst isPromise = (val) => {\r\n    return isObject(val) && isFunction(val.then) && isFunction(val.catch);\r\n};\r\nconst objectToString = Object.prototype.toString;\r\nconst toTypeString = (value) => objectToString.call(value);\r\nconst isPlainObject = (val) => toTypeString(val) === '[object Object]';\r\n// compare whether a value has changed, accounting for NaN.\r\nconst hasChanged = (value, oldValue) => !Object.is(value, oldValue);\r\nconst def = (obj, key, value) => {\r\n    Object.defineProperty(obj, key, {\r\n        configurable: true,\r\n        enumerable: false,\r\n        value\r\n    });\r\n};\n\nlet activeEffectScope;\r\nfunction recordEffectScope(effect, scope = activeEffectScope) {\r\n    if (scope && scope.active) {\r\n        scope.effects.push(effect);\r\n    }\r\n}\r\nconst wasTracked = (dep) => (dep.w & trackOpBit) > 0;\r\nconst newTracked = (dep) => (dep.n & trackOpBit) > 0;\r\nconst initDepMarkers = ({ deps }) => {\r\n    if (deps.length) {\r\n        for (let i = 0; i < deps.length; i++) {\r\n            deps[i].w |= trackOpBit; // set was tracked\r\n        }\r\n    }\r\n};\r\nconst finalizeDepMarkers = (effect) => {\r\n    const { deps } = effect;\r\n    if (deps.length) {\r\n        let ptr = 0;\r\n        for (let i = 0; i < deps.length; i++) {\r\n            const dep = deps[i];\r\n            if (wasTracked(dep) && !newTracked(dep)) {\r\n                dep.delete(effect);\r\n            }\r\n            else {\r\n                deps[ptr++] = dep;\r\n            }\r\n            // clear bits\r\n            dep.w &= ~trackOpBit;\r\n            dep.n &= ~trackOpBit;\r\n        }\r\n        deps.length = ptr;\r\n    }\r\n};\n// The number of effects currently being tracked recursively.\r\nlet effectTrackDepth = 0;\r\nlet trackOpBit = 1;\r\n/**\r\n * The bitwise track markers support at most 30 levels of recursion.\r\n * This value is chosen to enable modern JS engines to use a SMI on all platforms.\r\n * When recursion depth is greater, fall back to using a full cleanup.\r\n */\r\nconst maxMarkerBits = 30;\r\nlet activeEffect;\r\nclass ReactiveEffect {\r\n    constructor(fn, scheduler = null, scope) {\r\n        this.fn = fn;\r\n        this.scheduler = scheduler;\r\n        this.active = true;\r\n        this.deps = [];\r\n        this.parent = undefined;\r\n        recordEffectScope(this, scope);\r\n    }\r\n    run() {\r\n        if (!this.active) {\r\n            return this.fn();\r\n        }\r\n        let parent = activeEffect;\r\n        let lastShouldTrack = shouldTrack;\r\n        while (parent) {\r\n            if (parent === this) {\r\n                return;\r\n            }\r\n            parent = parent.parent;\r\n        }\r\n        try {\r\n            this.parent = activeEffect;\r\n            activeEffect = this;\r\n            shouldTrack = true;\r\n            trackOpBit = 1 << ++effectTrackDepth;\r\n            if (effectTrackDepth <= maxMarkerBits) {\r\n                initDepMarkers(this);\r\n            }\r\n            else {\r\n                cleanupEffect(this);\r\n            }\r\n            return this.fn();\r\n        }\r\n        finally {\r\n            if (effectTrackDepth <= maxMarkerBits) {\r\n                finalizeDepMarkers(this);\r\n            }\r\n            trackOpBit = 1 << --effectTrackDepth;\r\n            activeEffect = this.parent;\r\n            shouldTrack = lastShouldTrack;\r\n            this.parent = undefined;\r\n        }\r\n    }\r\n    stop() {\r\n        if (this.active) {\r\n            cleanupEffect(this);\r\n            if (this.onStop) {\r\n                this.onStop();\r\n            }\r\n            this.active = false;\r\n        }\r\n    }\r\n}\r\nfunction cleanupEffect(effect) {\r\n    const { deps } = effect;\r\n    if (deps.length) {\r\n        for (let i = 0; i < deps.length; i++) {\r\n            deps[i].delete(effect);\r\n        }\r\n        deps.length = 0;\r\n    }\r\n}\r\nlet shouldTrack = true;\r\nnew Set(Object.getOwnPropertyNames(Symbol)\r\n    .map(key => Symbol[key])\r\n    .filter(isSymbol));\r\nfunction isReactive(value) {\r\n    if (isReadonly(value)) {\r\n        return isReactive(value[\"__v_raw\" /* RAW */]);\r\n    }\r\n    return !!(value && value[\"__v_isReactive\" /* IS_REACTIVE */]);\r\n}\r\nfunction isReadonly(value) {\r\n    return !!(value && value[\"__v_isReadonly\" /* IS_READONLY */]);\r\n}\r\nfunction isShallow(value) {\r\n    return !!(value && value[\"__v_isShallow\" /* IS_SHALLOW */]);\r\n}\r\nfunction isProxy(value) {\r\n    return isReactive(value) || isReadonly(value);\r\n}\r\nfunction markRaw(value) {\r\n    def(value, \"__v_skip\" /* SKIP */, true);\r\n    return value;\r\n}\r\nfunction isRef(r) {\r\n    return !!(r && r.__v_isRef === true);\r\n}\r\nfunction unref(ref) {\r\n    return isRef(ref) ? ref.value : ref;\r\n}\r\nconst shallowUnwrapHandlers = {\r\n    get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\r\n    set: (target, key, value, receiver) => {\r\n        const oldValue = target[key];\r\n        if (isRef(oldValue) && !isRef(value)) {\r\n            oldValue.value = value;\r\n            return true;\r\n        }\r\n        else {\r\n            return Reflect.set(target, key, value, receiver);\r\n        }\r\n    }\r\n};\r\nfunction proxyRefs(objectWithRefs) {\r\n    return isReactive(objectWithRefs)\r\n        ? objectWithRefs\r\n        : new Proxy(objectWithRefs, shallowUnwrapHandlers);\r\n}\r\nPromise.resolve();\n\nfunction callWithErrorHandling(fn, instance, type, args) {\r\n    let res;\r\n    try {\r\n        res = args ? fn(...args) : fn();\r\n    }\r\n    catch (err) {\r\n        handleError(err, instance, type);\r\n    }\r\n    return res;\r\n}\r\nfunction callWithAsyncErrorHandling(fn, instance, type, args) {\r\n    if (isFunction(fn)) {\r\n        const res = callWithErrorHandling(fn, instance, type, args);\r\n        if (res && isPromise(res)) {\r\n            res.catch(err => {\r\n                handleError(err, instance, type);\r\n            });\r\n        }\r\n        return res;\r\n    }\r\n    const values = [];\r\n    for (let i = 0; i < fn.length; i++) {\r\n        values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));\r\n    }\r\n    return values;\r\n}\r\nfunction handleError(err, instance, type, throwInDev = true) {\r\n    const contextVNode = instance ? instance.vnode : null;\r\n    if (instance) {\r\n        let cur = instance.parent;\r\n        // the exposed instance is the render proxy to keep it consistent with 2.x\r\n        const exposedInstance = instance.proxy;\r\n        // in production the hook receives only the error code\r\n        const errorInfo = type;\r\n        while (cur) {\r\n            const errorCapturedHooks = cur.ec;\r\n            if (errorCapturedHooks) {\r\n                for (let i = 0; i < errorCapturedHooks.length; i++) {\r\n                    if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            cur = cur.parent;\r\n        }\r\n        // app-level handling\r\n        const appErrorHandler = instance.appContext.config.errorHandler;\r\n        if (appErrorHandler) {\r\n            callWithErrorHandling(appErrorHandler, null, 10 /* APP_ERROR_HANDLER */, [err, exposedInstance, errorInfo]);\r\n            return;\r\n        }\r\n    }\r\n    logError(err, type, contextVNode, throwInDev);\r\n}\r\nfunction logError(err, type, contextVNode, throwInDev = true) {\r\n    {\r\n        // recover in prod to reduce the impact on end-user\r\n        console.error(err);\r\n    }\r\n}\n\nlet isFlushing = false;\r\nlet isFlushPending = false;\r\nconst queue = [];\r\nlet flushIndex = 0;\r\nconst pendingPreFlushCbs = [];\r\nlet activePreFlushCbs = null;\r\nlet preFlushIndex = 0;\r\nconst pendingPostFlushCbs = [];\r\nlet activePostFlushCbs = null;\r\nlet postFlushIndex = 0;\r\nconst resolvedPromise = Promise.resolve();\r\nlet currentFlushPromise = null;\r\nlet currentPreFlushParentJob = null;\r\nfunction nextTick(fn) {\r\n    const p = currentFlushPromise || resolvedPromise;\r\n    return fn ? p.then(this ? fn.bind(this) : fn) : p;\r\n}\r\n// #2768\r\n// Use binary-search to find a suitable position in the queue,\r\n// so that the queue maintains the increasing order of job's id,\r\n// which can prevent the job from being skipped and also can avoid repeated patching.\r\nfunction findInsertionIndex(id) {\r\n    // the start index should be `flushIndex + 1`\r\n    let start = flushIndex + 1;\r\n    let end = queue.length;\r\n    while (start < end) {\r\n        const middle = (start + end) >>> 1;\r\n        const middleJobId = getId(queue[middle]);\r\n        middleJobId < id ? (start = middle + 1) : (end = middle);\r\n    }\r\n    return start;\r\n}\r\nfunction queueJob(job) {\r\n    // the dedupe search uses the startIndex argument of Array.includes()\r\n    // by default the search index includes the current job that is being run\r\n    // so it cannot recursively trigger itself again.\r\n    // if the job is a watch() callback, the search will start with a +1 index to\r\n    // allow it recursively trigger itself - it is the user's responsibility to\r\n    // ensure it doesn't end up in an infinite loop.\r\n    if ((!queue.length ||\r\n        !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) &&\r\n        job !== currentPreFlushParentJob) {\r\n        if (job.id == null) {\r\n            queue.push(job);\r\n        }\r\n        else {\r\n            queue.splice(findInsertionIndex(job.id), 0, job);\r\n        }\r\n        queueFlush();\r\n    }\r\n}\r\nfunction queueFlush() {\r\n    if (!isFlushing && !isFlushPending) {\r\n        isFlushPending = true;\r\n        currentFlushPromise = resolvedPromise.then(flushJobs);\r\n    }\r\n}\r\nfunction queueCb(cb, activeQueue, pendingQueue, index) {\r\n    if (!isArray(cb)) {\r\n        if (!activeQueue ||\r\n            !activeQueue.includes(cb, cb.allowRecurse ? index + 1 : index)) {\r\n            pendingQueue.push(cb);\r\n        }\r\n    }\r\n    else {\r\n        // if cb is an array, it is a component lifecycle hook which can only be\r\n        // triggered by a job, which is already deduped in the main queue, so\r\n        // we can skip duplicate check here to improve perf\r\n        pendingQueue.push(...cb);\r\n    }\r\n    queueFlush();\r\n}\r\nfunction queuePreFlushCb(cb) {\r\n    queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex);\r\n}\r\nfunction queuePostFlushCb(cb) {\r\n    queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex);\r\n}\r\nfunction flushPreFlushCbs(seen, parentJob = null) {\r\n    if (pendingPreFlushCbs.length) {\r\n        currentPreFlushParentJob = parentJob;\r\n        activePreFlushCbs = [...new Set(pendingPreFlushCbs)];\r\n        pendingPreFlushCbs.length = 0;\r\n        for (preFlushIndex = 0; preFlushIndex < activePreFlushCbs.length; preFlushIndex++) {\r\n            activePreFlushCbs[preFlushIndex]();\r\n        }\r\n        activePreFlushCbs = null;\r\n        preFlushIndex = 0;\r\n        currentPreFlushParentJob = null;\r\n        // recursively flush until it drains\r\n        flushPreFlushCbs(seen, parentJob);\r\n    }\r\n}\r\nfunction flushPostFlushCbs(seen) {\r\n    if (pendingPostFlushCbs.length) {\r\n        const deduped = [...new Set(pendingPostFlushCbs)];\r\n        pendingPostFlushCbs.length = 0;\r\n        // #1947 already has active queue, nested flushPostFlushCbs call\r\n        if (activePostFlushCbs) {\r\n            activePostFlushCbs.push(...deduped);\r\n            return;\r\n        }\r\n        activePostFlushCbs = deduped;\r\n        activePostFlushCbs.sort((a, b) => getId(a) - getId(b));\r\n        for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {\r\n            activePostFlushCbs[postFlushIndex]();\r\n        }\r\n        activePostFlushCbs = null;\r\n        postFlushIndex = 0;\r\n    }\r\n}\r\nconst getId = (job) => job.id == null ? Infinity : job.id;\r\nfunction flushJobs(seen) {\r\n    isFlushPending = false;\r\n    isFlushing = true;\r\n    flushPreFlushCbs(seen);\r\n    // Sort queue before flush.\r\n    // This ensures that:\r\n    // 1. Components are updated from parent to child. (because parent is always\r\n    //    created before the child so its render effect will have smaller\r\n    //    priority number)\r\n    // 2. If a component is unmounted during a parent component's update,\r\n    //    its update can be skipped.\r\n    queue.sort((a, b) => getId(a) - getId(b));\r\n    // conditional usage of checkRecursiveUpdate must be determined out of\r\n    // try ... catch block since Rollup by default de-optimizes treeshaking\r\n    // inside try-catch. This can leave all warning code unshaked. Although\r\n    // they would get eventually shaken by a minifier like terser, some minifiers\r\n    // would fail to do that (e.g. https://github.com/evanw/esbuild/issues/1610)\r\n    const check = NOOP;\r\n    try {\r\n        for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {\r\n            const job = queue[flushIndex];\r\n            if (job && job.active !== false) {\r\n                if ((\"production\" !== 'production') && check(job)) ;\r\n                // console.log(`running:`, job.id)\r\n                callWithErrorHandling(job, null, 14 /* SCHEDULER */);\r\n            }\r\n        }\r\n    }\r\n    finally {\r\n        flushIndex = 0;\r\n        queue.length = 0;\r\n        flushPostFlushCbs();\r\n        isFlushing = false;\r\n        currentFlushPromise = null;\r\n        // some postFlushCb queued jobs!\r\n        // keep flushing until it drains.\r\n        if (queue.length ||\r\n            pendingPreFlushCbs.length ||\r\n            pendingPostFlushCbs.length) {\r\n            flushJobs(seen);\r\n        }\r\n    }\r\n}\r\n\n/**\r\n * mark the current rendering instance for asset resolution (e.g.\r\n * resolveComponent, resolveDirective) during render\r\n */\r\nlet currentRenderingInstance = null;\r\nlet currentScopeId = null;\r\n\nconst isSuspense = (type) => type.__isSuspense;\r\nfunction queueEffectWithSuspense(fn, suspense) {\r\n    if (suspense && suspense.pendingBranch) {\r\n        if (isArray(fn)) {\r\n            suspense.effects.push(...fn);\r\n        }\r\n        else {\r\n            suspense.effects.push(fn);\r\n        }\r\n    }\r\n    else {\r\n        queuePostFlushCb(fn);\r\n    }\r\n}\r\n// initial value for watchers to trigger on undefined initial values\r\nconst INITIAL_WATCHER_VALUE = {};\r\nfunction doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {\r\n    const instance = currentInstance;\r\n    let getter;\r\n    let forceTrigger = false;\r\n    let isMultiSource = false;\r\n    if (isRef(source)) {\r\n        getter = () => source.value;\r\n        forceTrigger = isShallow(source);\r\n    }\r\n    else if (isReactive(source)) {\r\n        getter = () => source;\r\n        deep = true;\r\n    }\r\n    else if (isArray(source)) {\r\n        isMultiSource = true;\r\n        forceTrigger = source.some(isReactive);\r\n        getter = () => source.map(s => {\r\n            if (isRef(s)) {\r\n                return s.value;\r\n            }\r\n            else if (isReactive(s)) {\r\n                return traverse(s);\r\n            }\r\n            else if (isFunction(s)) {\r\n                return callWithErrorHandling(s, instance, 2 /* WATCH_GETTER */);\r\n            }\r\n            else ;\r\n        });\r\n    }\r\n    else if (isFunction(source)) {\r\n        if (cb) {\r\n            // getter with cb\r\n            getter = () => callWithErrorHandling(source, instance, 2 /* WATCH_GETTER */);\r\n        }\r\n        else {\r\n            // no cb -> simple effect\r\n            getter = () => {\r\n                if (instance && instance.isUnmounted) {\r\n                    return;\r\n                }\r\n                if (cleanup) {\r\n                    cleanup();\r\n                }\r\n                return callWithAsyncErrorHandling(source, instance, 3 /* WATCH_CALLBACK */, [onCleanup]);\r\n            };\r\n        }\r\n    }\r\n    else {\r\n        getter = NOOP;\r\n    }\r\n    if (cb && deep) {\r\n        const baseGetter = getter;\r\n        getter = () => traverse(baseGetter());\r\n    }\r\n    let cleanup;\r\n    let onCleanup = (fn) => {\r\n        cleanup = effect.onStop = () => {\r\n            callWithErrorHandling(fn, instance, 4 /* WATCH_CLEANUP */);\r\n        };\r\n    };\r\n    let oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;\r\n    const job = () => {\r\n        if (!effect.active) {\r\n            return;\r\n        }\r\n        if (cb) {\r\n            // watch(source, cb)\r\n            const newValue = effect.run();\r\n            if (deep ||\r\n                forceTrigger ||\r\n                (isMultiSource\r\n                    ? newValue.some((v, i) => hasChanged(v, oldValue[i]))\r\n                    : hasChanged(newValue, oldValue)) ||\r\n                (false  )) {\r\n                // cleanup before running cb again\r\n                if (cleanup) {\r\n                    cleanup();\r\n                }\r\n                callWithAsyncErrorHandling(cb, instance, 3 /* WATCH_CALLBACK */, [\r\n                    newValue,\r\n                    // pass undefined as the old value when it's changed for the first time\r\n                    oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue,\r\n                    onCleanup\r\n                ]);\r\n                oldValue = newValue;\r\n            }\r\n        }\r\n        else {\r\n            // watchEffect\r\n            effect.run();\r\n        }\r\n    };\r\n    // important: mark the job as a watcher callback so that scheduler knows\r\n    // it is allowed to self-trigger (#1727)\r\n    job.allowRecurse = !!cb;\r\n    let scheduler;\r\n    if (flush === 'sync') {\r\n        scheduler = job; // the scheduler function gets called directly\r\n    }\r\n    else if (flush === 'post') {\r\n        scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);\r\n    }\r\n    else {\r\n        // default: 'pre'\r\n        scheduler = () => {\r\n            if (!instance || instance.isMounted) {\r\n                queuePreFlushCb(job);\r\n            }\r\n            else {\r\n                // with 'pre' option, the first call must happen before\r\n                // the component is mounted so it is called synchronously.\r\n                job();\r\n            }\r\n        };\r\n    }\r\n    const effect = new ReactiveEffect(getter, scheduler);\r\n    // initial run\r\n    if (cb) {\r\n        if (immediate) {\r\n            job();\r\n        }\r\n        else {\r\n            oldValue = effect.run();\r\n        }\r\n    }\r\n    else if (flush === 'post') {\r\n        queuePostRenderEffect(effect.run.bind(effect), instance && instance.suspense);\r\n    }\r\n    else {\r\n        effect.run();\r\n    }\r\n    return () => {\r\n        effect.stop();\r\n        if (instance && instance.scope) {\r\n            remove(instance.scope.effects, effect);\r\n        }\r\n    };\r\n}\r\n// this.$watch\r\nfunction instanceWatch(source, value, options) {\r\n    const publicThis = this.proxy;\r\n    const getter = isString(source)\r\n        ? source.includes('.')\r\n            ? createPathGetter(publicThis, source)\r\n            : () => publicThis[source]\r\n        : source.bind(publicThis, publicThis);\r\n    let cb;\r\n    if (isFunction(value)) {\r\n        cb = value;\r\n    }\r\n    else {\r\n        cb = value.handler;\r\n        options = value;\r\n    }\r\n    const cur = currentInstance;\r\n    setCurrentInstance(this);\r\n    const res = doWatch(getter, cb.bind(publicThis), options);\r\n    if (cur) {\r\n        setCurrentInstance(cur);\r\n    }\r\n    else {\r\n        unsetCurrentInstance();\r\n    }\r\n    return res;\r\n}\r\nfunction createPathGetter(ctx, path) {\r\n    const segments = path.split('.');\r\n    return () => {\r\n        let cur = ctx;\r\n        for (let i = 0; i < segments.length && cur; i++) {\r\n            cur = cur[segments[i]];\r\n        }\r\n        return cur;\r\n    };\r\n}\r\nfunction traverse(value, seen) {\r\n    if (!isObject(value) || value[\"__v_skip\" /* SKIP */]) {\r\n        return value;\r\n    }\r\n    seen = seen || new Set();\r\n    if (seen.has(value)) {\r\n        return value;\r\n    }\r\n    seen.add(value);\r\n    if (isRef(value)) {\r\n        traverse(value.value, seen);\r\n    }\r\n    else if (isArray(value)) {\r\n        for (let i = 0; i < value.length; i++) {\r\n            traverse(value[i], seen);\r\n        }\r\n    }\r\n    else if (isSet(value) || isMap(value)) {\r\n        value.forEach((v) => {\r\n            traverse(v, seen);\r\n        });\r\n    }\r\n    else if (isPlainObject(value)) {\r\n        for (const key in value) {\r\n            traverse(value[key], seen);\r\n        }\r\n    }\r\n    return value;\r\n}\n\n// implementation, close to no-op\r\nfunction defineComponent(options) {\r\n    return isFunction(options) ? { setup: options, name: options.name } : options;\r\n}\n/**\r\n * Resolve merged options and cache it on the component.\r\n * This is done only once per-component since the merging does not involve\r\n * instances.\r\n */\r\nfunction resolveMergedOptions(instance) {\r\n    const base = instance.type;\r\n    const { mixins, extends: extendsOptions } = base;\r\n    const { mixins: globalMixins, optionsCache: cache, config: { optionMergeStrategies } } = instance.appContext;\r\n    const cached = cache.get(base);\r\n    let resolved;\r\n    if (cached) {\r\n        resolved = cached;\r\n    }\r\n    else if (!globalMixins.length && !mixins && !extendsOptions) {\r\n        {\r\n            resolved = base;\r\n        }\r\n    }\r\n    else {\r\n        resolved = {};\r\n        if (globalMixins.length) {\r\n            globalMixins.forEach(m => mergeOptions(resolved, m, optionMergeStrategies, true));\r\n        }\r\n        mergeOptions(resolved, base, optionMergeStrategies);\r\n    }\r\n    cache.set(base, resolved);\r\n    return resolved;\r\n}\r\nfunction mergeOptions(to, from, strats, asMixin = false) {\r\n    const { mixins, extends: extendsOptions } = from;\r\n    if (extendsOptions) {\r\n        mergeOptions(to, extendsOptions, strats, true);\r\n    }\r\n    if (mixins) {\r\n        mixins.forEach((m) => mergeOptions(to, m, strats, true));\r\n    }\r\n    for (const key in from) {\r\n        if (asMixin && key === 'expose') ;\r\n        else {\r\n            const strat = internalOptionMergeStrats[key] || (strats && strats[key]);\r\n            to[key] = strat ? strat(to[key], from[key]) : from[key];\r\n        }\r\n    }\r\n    return to;\r\n}\r\nconst internalOptionMergeStrats = {\r\n    data: mergeDataFn,\r\n    props: mergeObjectOptions,\r\n    emits: mergeObjectOptions,\r\n    // objects\r\n    methods: mergeObjectOptions,\r\n    computed: mergeObjectOptions,\r\n    // lifecycle\r\n    beforeCreate: mergeAsArray,\r\n    created: mergeAsArray,\r\n    beforeMount: mergeAsArray,\r\n    mounted: mergeAsArray,\r\n    beforeUpdate: mergeAsArray,\r\n    updated: mergeAsArray,\r\n    beforeDestroy: mergeAsArray,\r\n    beforeUnmount: mergeAsArray,\r\n    destroyed: mergeAsArray,\r\n    unmounted: mergeAsArray,\r\n    activated: mergeAsArray,\r\n    deactivated: mergeAsArray,\r\n    errorCaptured: mergeAsArray,\r\n    serverPrefetch: mergeAsArray,\r\n    // assets\r\n    components: mergeObjectOptions,\r\n    directives: mergeObjectOptions,\r\n    // watch\r\n    watch: mergeWatchOptions,\r\n    // provide / inject\r\n    provide: mergeDataFn,\r\n    inject: mergeInject\r\n};\r\nfunction mergeDataFn(to, from) {\r\n    if (!from) {\r\n        return to;\r\n    }\r\n    if (!to) {\r\n        return from;\r\n    }\r\n    return function mergedDataFn() {\r\n        return (extend)(isFunction(to) ? to.call(this, this) : to, isFunction(from) ? from.call(this, this) : from);\r\n    };\r\n}\r\nfunction mergeInject(to, from) {\r\n    return mergeObjectOptions(normalizeInject(to), normalizeInject(from));\r\n}\r\nfunction normalizeInject(raw) {\r\n    if (isArray(raw)) {\r\n        const res = {};\r\n        for (let i = 0; i < raw.length; i++) {\r\n            res[raw[i]] = raw[i];\r\n        }\r\n        return res;\r\n    }\r\n    return raw;\r\n}\r\nfunction mergeAsArray(to, from) {\r\n    return to ? [...new Set([].concat(to, from))] : from;\r\n}\r\nfunction mergeObjectOptions(to, from) {\r\n    return to ? extend(extend(Object.create(null), to), from) : from;\r\n}\r\nfunction mergeWatchOptions(to, from) {\r\n    if (!to)\r\n        return from;\r\n    if (!from)\r\n        return to;\r\n    const merged = extend(Object.create(null), to);\r\n    for (const key in from) {\r\n        merged[key] = mergeAsArray(to[key], from[key]);\r\n    }\r\n    return merged;\r\n}\n\nconst queuePostRenderEffect = queueEffectWithSuspense\r\n    ;\r\n\nconst isTeleport = (type) => type.__isTeleport;\r\nconst NULL_DYNAMIC_COMPONENT = Symbol();\r\n\nconst Fragment = Symbol(undefined);\r\nconst Text = Symbol(undefined);\r\nconst Comment = Symbol(undefined);\r\n// Since v-if and v-for are the two possible ways node structure can dynamically\r\n// change, once we consider v-if branches and each v-for fragment a block, we\r\n// can divide a template into nested blocks, and within each block the node\r\n// structure would be stable. This allows us to skip most children diffing\r\n// and only worry about the dynamic nodes (indicated by patch flags).\r\nconst blockStack = [];\r\nlet currentBlock = null;\r\n/**\r\n * Open a block.\r\n * This must be called before `createBlock`. It cannot be part of `createBlock`\r\n * because the children of the block are evaluated before `createBlock` itself\r\n * is called. The generated code typically looks like this:\r\n *\r\n * ```js\r\n * function render() {\r\n *   return (openBlock(),createBlock('div', null, [...]))\r\n * }\r\n * ```\r\n * disableTracking is true when creating a v-for fragment block, since a v-for\r\n * fragment always diffs its children.\r\n *\r\n * @private\r\n */\r\nfunction openBlock(disableTracking = false) {\r\n    blockStack.push((currentBlock = disableTracking ? null : []));\r\n}\r\nfunction closeBlock() {\r\n    blockStack.pop();\r\n    currentBlock = blockStack[blockStack.length - 1] || null;\r\n}\r\nfunction setupBlock(vnode) {\r\n    // save current block children on the block vnode\r\n    vnode.dynamicChildren =\r\n        currentBlock || EMPTY_ARR ;\r\n    // close block\r\n    closeBlock();\r\n    // a block is always going to be patched, so track it as a child of its\r\n    // parent block\r\n    if (currentBlock) {\r\n        currentBlock.push(vnode);\r\n    }\r\n    return vnode;\r\n}\r\n/**\r\n * @private\r\n */\r\nfunction createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {\r\n    return setupBlock(createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, true /* isBlock */));\r\n}\r\nfunction isVNode(value) {\r\n    return value ? value.__v_isVNode === true : false;\r\n}\r\nconst InternalObjectKey = `__vInternal`;\r\nconst normalizeKey = ({ key }) => key != null ? key : null;\r\nconst normalizeRef = ({ ref, ref_key, ref_for }) => {\r\n    return (ref != null\r\n        ? isString(ref) || isRef(ref) || isFunction(ref)\r\n            ? { i: currentRenderingInstance, r: ref, k: ref_key, f: !!ref_for }\r\n            : ref\r\n        : null);\r\n};\r\nfunction createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1 /* ELEMENT */, isBlockNode = false, needFullChildrenNormalization = false) {\r\n    const vnode = {\r\n        __v_isVNode: true,\r\n        __v_skip: true,\r\n        type,\r\n        props,\r\n        key: props && normalizeKey(props),\r\n        ref: props && normalizeRef(props),\r\n        scopeId: currentScopeId,\r\n        slotScopeIds: null,\r\n        children,\r\n        component: null,\r\n        suspense: null,\r\n        ssContent: null,\r\n        ssFallback: null,\r\n        dirs: null,\r\n        transition: null,\r\n        el: null,\r\n        anchor: null,\r\n        target: null,\r\n        targetAnchor: null,\r\n        staticCount: 0,\r\n        shapeFlag,\r\n        patchFlag,\r\n        dynamicProps,\r\n        dynamicChildren: null,\r\n        appContext: null\r\n    };\r\n    if (needFullChildrenNormalization) {\r\n        normalizeChildren(vnode, children);\r\n        // normalize suspense children\r\n        if (shapeFlag & 128 /* SUSPENSE */) {\r\n            type.normalize(vnode);\r\n        }\r\n    }\r\n    else if (children) {\r\n        // compiled element vnode - if children is passed, only possible types are\r\n        // string or Array.\r\n        vnode.shapeFlag |= isString(children)\r\n            ? 8 /* TEXT_CHILDREN */\r\n            : 16 /* ARRAY_CHILDREN */;\r\n    }\r\n    // track vnode for block tree\r\n    if (// avoid a block node from tracking itself\r\n        !isBlockNode &&\r\n        // has current parent block\r\n        currentBlock &&\r\n        // presence of a patch flag indicates this node needs patching on updates.\r\n        // component nodes also should always be patched, because even if the\r\n        // component doesn't need to update, it needs to persist the instance on to\r\n        // the next vnode so that it can be properly unmounted later.\r\n        (vnode.patchFlag > 0 || shapeFlag & 6 /* COMPONENT */) &&\r\n        // the EVENTS flag is only for hydration and if it is the only flag, the\r\n        // vnode should not be considered dynamic due to handler caching.\r\n        vnode.patchFlag !== 32 /* HYDRATE_EVENTS */) {\r\n        currentBlock.push(vnode);\r\n    }\r\n    return vnode;\r\n}\r\nconst createVNode = (_createVNode);\r\nfunction _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {\r\n    if (!type || type === NULL_DYNAMIC_COMPONENT) {\r\n        type = Comment;\r\n    }\r\n    if (isVNode(type)) {\r\n        // createVNode receiving an existing vnode. This happens in cases like\r\n        // <component :is=\"vnode\"/>\r\n        // #2078 make sure to merge refs during the clone instead of overwriting it\r\n        const cloned = cloneVNode(type, props, true /* mergeRef: true */);\r\n        if (children) {\r\n            normalizeChildren(cloned, children);\r\n        }\r\n        return cloned;\r\n    }\r\n    // class component normalization.\r\n    if (isClassComponent(type)) {\r\n        type = type.__vccOpts;\r\n    }\r\n    // class & style normalization.\r\n    if (props) {\r\n        // for reactive or proxy objects, we need to clone it to enable mutation.\r\n        props = guardReactiveProps(props);\r\n        let { class: klass, style } = props;\r\n        if (klass && !isString(klass)) {\r\n            props.class = normalizeClass(klass);\r\n        }\r\n        if (isObject(style)) {\r\n            // reactive state objects need to be cloned since they are likely to be\r\n            // mutated\r\n            if (isProxy(style) && !isArray(style)) {\r\n                style = extend({}, style);\r\n            }\r\n            props.style = normalizeStyle(style);\r\n        }\r\n    }\r\n    // encode the vnode type information into a bitmap\r\n    const shapeFlag = isString(type)\r\n        ? 1 /* ELEMENT */\r\n        : isSuspense(type)\r\n            ? 128 /* SUSPENSE */\r\n            : isTeleport(type)\r\n                ? 64 /* TELEPORT */\r\n                : isObject(type)\r\n                    ? 4 /* STATEFUL_COMPONENT */\r\n                    : isFunction(type)\r\n                        ? 2 /* FUNCTIONAL_COMPONENT */\r\n                        : 0;\r\n    return createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);\r\n}\r\nfunction guardReactiveProps(props) {\r\n    if (!props)\r\n        return null;\r\n    return isProxy(props) || InternalObjectKey in props\r\n        ? extend({}, props)\r\n        : props;\r\n}\r\nfunction cloneVNode(vnode, extraProps, mergeRef = false) {\r\n    // This is intentionally NOT using spread or extend to avoid the runtime\r\n    // key enumeration cost.\r\n    const { props, ref, patchFlag, children } = vnode;\r\n    const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;\r\n    const cloned = {\r\n        __v_isVNode: true,\r\n        __v_skip: true,\r\n        type: vnode.type,\r\n        props: mergedProps,\r\n        key: mergedProps && normalizeKey(mergedProps),\r\n        ref: extraProps && extraProps.ref\r\n            ? // #2078 in the case of <component :is=\"vnode\" ref=\"extra\"/>\r\n                // if the vnode itself already has a ref, cloneVNode will need to merge\r\n                // the refs so the single vnode can be set on multiple refs\r\n                mergeRef && ref\r\n                    ? isArray(ref)\r\n                        ? ref.concat(normalizeRef(extraProps))\r\n                        : [ref, normalizeRef(extraProps)]\r\n                    : normalizeRef(extraProps)\r\n            : ref,\r\n        scopeId: vnode.scopeId,\r\n        slotScopeIds: vnode.slotScopeIds,\r\n        children: children,\r\n        target: vnode.target,\r\n        targetAnchor: vnode.targetAnchor,\r\n        staticCount: vnode.staticCount,\r\n        shapeFlag: vnode.shapeFlag,\r\n        // if the vnode is cloned with extra props, we can no longer assume its\r\n        // existing patch flag to be reliable and need to add the FULL_PROPS flag.\r\n        // note: preserve flag for fragments since they use the flag for children\r\n        // fast paths only.\r\n        patchFlag: extraProps && vnode.type !== Fragment\r\n            ? patchFlag === -1 // hoisted node\r\n                ? 16 /* FULL_PROPS */\r\n                : patchFlag | 16 /* FULL_PROPS */\r\n            : patchFlag,\r\n        dynamicProps: vnode.dynamicProps,\r\n        dynamicChildren: vnode.dynamicChildren,\r\n        appContext: vnode.appContext,\r\n        dirs: vnode.dirs,\r\n        transition: vnode.transition,\r\n        // These should technically only be non-null on mounted VNodes. However,\r\n        // they *should* be copied for kept-alive vnodes. So we just always copy\r\n        // them since them being non-null during a mount doesn't affect the logic as\r\n        // they will simply be overwritten.\r\n        component: vnode.component,\r\n        suspense: vnode.suspense,\r\n        ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),\r\n        ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),\r\n        el: vnode.el,\r\n        anchor: vnode.anchor\r\n    };\r\n    return cloned;\r\n}\r\n/**\r\n * @private\r\n */\r\nfunction createTextVNode(text = ' ', flag = 0) {\r\n    return createVNode(Text, null, text, flag);\r\n}\r\nfunction normalizeChildren(vnode, children) {\r\n    let type = 0;\r\n    const { shapeFlag } = vnode;\r\n    if (children == null) {\r\n        children = null;\r\n    }\r\n    else if (isArray(children)) {\r\n        type = 16 /* ARRAY_CHILDREN */;\r\n    }\r\n    else if (typeof children === 'object') {\r\n        if (shapeFlag & (1 /* ELEMENT */ | 64 /* TELEPORT */)) {\r\n            // Normalize slot to plain children for plain element and Teleport\r\n            const slot = children.default;\r\n            if (slot) {\r\n                // _c marker is added by withCtx() indicating this is a compiled slot\r\n                slot._c && (slot._d = false);\r\n                normalizeChildren(vnode, slot());\r\n                slot._c && (slot._d = true);\r\n            }\r\n            return;\r\n        }\r\n        else {\r\n            type = 32 /* SLOTS_CHILDREN */;\r\n            const slotFlag = children._;\r\n            if (!slotFlag && !(InternalObjectKey in children)) {\r\n                children._ctx = currentRenderingInstance;\r\n            }\r\n            else if (slotFlag === 3 /* FORWARDED */ && currentRenderingInstance) {\r\n                // a child component receives forwarded slots from the parent.\r\n                // its slot type is determined by its parent's slot type.\r\n                if (currentRenderingInstance.slots._ === 1 /* STABLE */) {\r\n                    children._ = 1 /* STABLE */;\r\n                }\r\n                else {\r\n                    children._ = 2 /* DYNAMIC */;\r\n                    vnode.patchFlag |= 1024 /* DYNAMIC_SLOTS */;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else if (isFunction(children)) {\r\n        children = { default: children, _ctx: currentRenderingInstance };\r\n        type = 32 /* SLOTS_CHILDREN */;\r\n    }\r\n    else {\r\n        children = String(children);\r\n        // force teleport children to array so it can be moved around\r\n        if (shapeFlag & 64 /* TELEPORT */) {\r\n            type = 16 /* ARRAY_CHILDREN */;\r\n            children = [createTextVNode(children)];\r\n        }\r\n        else {\r\n            type = 8 /* TEXT_CHILDREN */;\r\n        }\r\n    }\r\n    vnode.children = children;\r\n    vnode.shapeFlag |= type;\r\n}\r\nfunction mergeProps(...args) {\r\n    const ret = {};\r\n    for (let i = 0; i < args.length; i++) {\r\n        const toMerge = args[i];\r\n        for (const key in toMerge) {\r\n            if (key === 'class') {\r\n                if (ret.class !== toMerge.class) {\r\n                    ret.class = normalizeClass([ret.class, toMerge.class]);\r\n                }\r\n            }\r\n            else if (key === 'style') {\r\n                ret.style = normalizeStyle([ret.style, toMerge.style]);\r\n            }\r\n            else if (isOn(key)) {\r\n                const existing = ret[key];\r\n                const incoming = toMerge[key];\r\n                if (incoming &&\r\n                    existing !== incoming &&\r\n                    !(isArray(existing) && existing.includes(incoming))) {\r\n                    ret[key] = existing\r\n                        ? [].concat(existing, incoming)\r\n                        : incoming;\r\n                }\r\n            }\r\n            else if (key !== '') {\r\n                ret[key] = toMerge[key];\r\n            }\r\n        }\r\n    }\r\n    return ret;\r\n}\r\n\n/**\r\n * #2437 In Vue 3, functional components do not have a public instance proxy but\r\n * they exist in the internal parent chain. For code that relies on traversing\r\n * public $parent chains, skip functional ones and go to the parent instead.\r\n */\r\nconst getPublicInstance = (i) => {\r\n    if (!i)\r\n        return null;\r\n    if (isStatefulComponent(i))\r\n        return getExposeProxy(i) || i.proxy;\r\n    return getPublicInstance(i.parent);\r\n};\r\nconst publicPropertiesMap = extend(Object.create(null), {\r\n    $: i => i,\r\n    $el: i => i.vnode.el,\r\n    $data: i => i.data,\r\n    $props: i => (i.props),\r\n    $attrs: i => (i.attrs),\r\n    $slots: i => (i.slots),\r\n    $refs: i => (i.refs),\r\n    $parent: i => getPublicInstance(i.parent),\r\n    $root: i => getPublicInstance(i.root),\r\n    $emit: i => i.emit,\r\n    $options: i => (__VUE_OPTIONS_API__ ? resolveMergedOptions(i) : i.type),\r\n    $forceUpdate: i => () => queueJob(i.update),\r\n    $nextTick: i => nextTick.bind(i.proxy),\r\n    $watch: i => (__VUE_OPTIONS_API__ ? instanceWatch.bind(i) : NOOP)\r\n});\r\nlet currentInstance = null;\r\nconst setCurrentInstance = (instance) => {\r\n    currentInstance = instance;\r\n    instance.scope.on();\r\n};\r\nconst unsetCurrentInstance = () => {\r\n    currentInstance && currentInstance.scope.off();\r\n    currentInstance = null;\r\n};\r\nfunction isStatefulComponent(instance) {\r\n    return instance.vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */;\r\n}\r\nfunction getExposeProxy(instance) {\r\n    if (instance.exposed) {\r\n        return (instance.exposeProxy ||\r\n            (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {\r\n                get(target, key) {\r\n                    if (key in target) {\r\n                        return target[key];\r\n                    }\r\n                    else if (key in publicPropertiesMap) {\r\n                        return publicPropertiesMap[key](instance);\r\n                    }\r\n                }\r\n            })));\r\n    }\r\n}\r\nfunction isClassComponent(value) {\r\n    return isFunction(value) && '__vccOpts' in value;\r\n}\n\nvar script = /* #__PURE__ */defineComponent({\n  name: 'BootstrapIcon',\n  props: {\n    icon: {\n      type: String,\n      required: true\n    },\n    variant: {\n      type: String,\n      validator: value => ['success', 'warning', 'danger', 'info', 'primary', 'secondary', 'dark', 'light'].indexOf(value) !== -1\n    },\n    size: {\n      type: String,\n      validator: value => ['sm', 'md', 'lg', '2x', '3x', '4x', '5x'].indexOf(value) !== -1\n    },\n    flipH: {\n      type: Boolean\n    },\n    flipV: {\n      type: Boolean\n    },\n    rotate: {\n      type: [String, Number],\n      validator: value => value >= -360 && value <= 360\n    },\n    animation: {\n      type: String,\n      validator: value => ['cylon', 'cylon-vertical', 'fade', 'spin', 'spin-reverse', 'spin-pulse', 'spin-reverse-pulse', 'throb'].indexOf(value) !== -1\n    }\n  },\n  computed: {\n    cssClasses() {\n      const classes = [];\n      if (this.variant) classes.push(`bi--variant-${this.variant}`);\n      if (this.size) classes.push(`bi--size-${this.size}`);\n      if (this.animation) classes.push(`bi--animation-${this.animation}`);\n      return classes;\n    },\n\n    svgTransform() {\n      if (!this.flipH && !this.flipV && !this.rotate) return '';\n      let scale;\n      let rotate;\n\n      if (this.flipV && this.flipH) {\n        scale = '-1 -1';\n      } else if (this.flipH) {\n        scale = '-1 1';\n      } else if (this.flipV) {\n        scale = '1 -1';\n      }\n\n      if (this.rotate) {\n        rotate = this.rotate;\n      }\n\n      return (scale ? `scale(${scale})` : '') + (rotate ? `rotate(${rotate})` : '');\n    },\n\n    svgSprite() {\n      return BootstrapIcons;\n    }\n\n  },\n  methods: {\n    upperFirst(str) {\n      if (typeof str !== 'string') return str;\n      return str.charAt(0).toUpperCase() + str.slice(1);\n    }\n\n  }\n});\n\nconst _hoisted_1 = [\"transform\"];\nconst _hoisted_2 = [\"xlink:href\"];\nfunction render(_ctx, _cache, $props, $setup, $data, $options) {\n  return openBlock(), createElementBlock(\"svg\", {\n    class: normalizeClass([\"bi\", _ctx.cssClasses])\n  }, [createBaseVNode(\"g\", {\n    transform: _ctx.svgTransform,\n    \"transform-origin\": \"center\"\n  }, [createBaseVNode(\"use\", {\n    \"xlink:href\": `${_ctx.svgSprite}#${_ctx.icon}`\n  }, null, 8, _hoisted_2)], 8, _hoisted_1)], 2);\n}\n\nfunction styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar css_248z = \".bi {\\n  fill: currentColor;\\n  width: 1em;\\n  height: 1em;\\n  font-size: 1em;\\n  margin-bottom: 0.125em;\\n  vertical-align: middle;\\n}\\n.bi--variant-success {\\n  color: var(--bs-success);\\n}\\n.bi--variant-warning {\\n  color: var(--bs-warning);\\n}\\n.bi--variant-danger {\\n  color: var(--bs-danger);\\n}\\n.bi--variant-info {\\n  color: var(--bs-info);\\n}\\n.bi--variant-primary {\\n  color: var(--bs-primary);\\n}\\n.bi--variant-secondary {\\n  color: var(--bs-secondary);\\n}\\n.bi--variant-dark {\\n  color: var(--bs-dark);\\n}\\n.bi--variant-light {\\n  color: var(--bs-light);\\n}\\n.bi--size-sm {\\n  font-size: 0.75em;\\n}\\n.bi--size-md {\\n  font-size: 1.25rem;\\n}\\n.bi--size-lg {\\n  font-size: 1.33333333rem;\\n}\\n.bi--size-2x {\\n  font-size: 2rem;\\n}\\n.bi--size-3x {\\n  font-size: 3rem;\\n}\\n.bi--size-4x {\\n  font-size: 4rem;\\n}\\n.bi--size-5x {\\n  font-size: 5rem;\\n}\\n.bi--animation-cylon {\\n  animation: bi-animation-cylon 0.75s ease-in-out infinite alternate;\\n}\\n.bi--animation-cylon-vertical {\\n  animation: bi-animation-cylon-vertical 0.75s ease-in-out infinite alternate;\\n}\\n.bi--animation-fade {\\n  animation: bi-animation-fade 0.75s ease-in-out infinite alternate;\\n}\\n.bi--animation-spin {\\n  animation: bi-animation-spin 2s linear infinite normal;\\n}\\n.bi--animation-spin-reverse {\\n  animation: bi-animation-spin 2s linear infinite reverse;\\n}\\n.bi--animation-spin-pulse {\\n  animation: bi-animation-spin 1s steps(8) infinite normal;\\n}\\n.bi--animation-spin-reverse-pulse {\\n  animation: bi-animation-spin 1s steps(8) infinite reverse;\\n}\\n.bi--animation-throb {\\n  animation: bi-animation-throb 0.75s ease-in-out infinite alternate;\\n}\\n\\n@keyframes bi-animation-cylon {\\n  0% {\\n    transform: translateX(-25%);\\n  }\\n  100% {\\n    transform: translateX(25%);\\n  }\\n}\\n@keyframes bi-animation-cylon-vertical {\\n  0% {\\n    transform: translateY(25%);\\n  }\\n  100% {\\n    transform: translateY(-25%);\\n  }\\n}\\n@keyframes bi-animation-fade {\\n  0% {\\n    opacity: 0.1;\\n  }\\n  100% {\\n    opacity: 1;\\n  }\\n}\\n@keyframes bi-animation-spin {\\n  0% {\\n    transform: rotate(0deg);\\n  }\\n  100% {\\n    transform: rotate(359deg);\\n  }\\n}\\n@keyframes bi-animation-throb {\\n  0% {\\n    opacity: 0.5;\\n    transform: scale(0.5);\\n  }\\n  100% {\\n    opacity: 1;\\n    transform: scale(1);\\n  }\\n}\";\nstyleInject(css_248z);\n\nscript.render = render;\n\n// Import vue component\n// IIFE injects install function into component, allowing component\n// to be registered via Vue.use() as well as Vue.component().\n\nvar entry_esm = /* #__PURE__ */(() => {\n  // Get component instance\n  const installable = script; // Attach install function executed by Vue.use()\n\n  installable.install = app => {\n    app.component('BootstrapIcon', installable);\n  };\n\n  return installable;\n})(); // It's possible to expose named exports when writing components that can\n// also be used as directives, etc. - eg. import { RollupDemoDirective } from 'rollup-demo';\n// export const RollupDemoDirective = directive;\n\nexport { entry_esm as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}