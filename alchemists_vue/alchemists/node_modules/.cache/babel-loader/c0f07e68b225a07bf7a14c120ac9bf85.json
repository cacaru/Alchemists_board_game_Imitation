{"ast":null,"code":"'use strict';\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nconst {\n  V4MAPPED,\n  ADDRCONFIG,\n  ALL,\n  promises: {\n    Resolver: AsyncResolver\n  },\n  lookup: dnsLookup\n} = require('dns');\n\nconst {\n  promisify\n} = require('util');\n\nconst os = require('os');\n\nconst kCacheableLookupCreateConnection = Symbol('cacheableLookupCreateConnection');\nconst kCacheableLookupInstance = Symbol('cacheableLookupInstance');\nconst kExpires = Symbol('expires');\nconst supportsALL = typeof ALL === 'number';\n\nconst verifyAgent = agent => {\n  if (!(agent && typeof agent.createConnection === 'function')) {\n    throw new Error('Expected an Agent instance as the first argument');\n  }\n};\n\nconst map4to6 = entries => {\n  for (const entry of entries) {\n    if (entry.family === 6) {\n      continue;\n    }\n\n    entry.address = `::ffff:${entry.address}`;\n    entry.family = 6;\n  }\n};\n\nconst getIfaceInfo = () => {\n  let has4 = false;\n  let has6 = false;\n\n  for (const device of Object.values(os.networkInterfaces())) {\n    for (const iface of device) {\n      if (iface.internal) {\n        continue;\n      }\n\n      if (iface.family === 'IPv6') {\n        has6 = true;\n      } else {\n        has4 = true;\n      }\n\n      if (has4 && has6) {\n        return {\n          has4,\n          has6\n        };\n      }\n    }\n  }\n\n  return {\n    has4,\n    has6\n  };\n};\n\nconst isIterable = map => {\n  return Symbol.iterator in map;\n};\n\nconst ignoreNoResultErrors = dnsPromise => {\n  return dnsPromise.catch(error => {\n    if (error.code === 'ENODATA' || error.code === 'ENOTFOUND' || error.code === 'ENOENT' // Windows: name exists, but not this record type\n    ) {\n      return [];\n    }\n\n    throw error;\n  });\n};\n\nconst ttl = {\n  ttl: true\n};\nconst all = {\n  all: true\n};\nconst all4 = {\n  all: true,\n  family: 4\n};\nconst all6 = {\n  all: true,\n  family: 6\n};\n\nclass CacheableLookup {\n  constructor({\n    cache = new Map(),\n    maxTtl = Infinity,\n    fallbackDuration = 3600,\n    errorTtl = 0.15,\n    resolver = new AsyncResolver(),\n    lookup = dnsLookup\n  } = {}) {\n    this.maxTtl = maxTtl;\n    this.errorTtl = errorTtl;\n    this._cache = cache;\n    this._resolver = resolver;\n    this._dnsLookup = lookup && promisify(lookup);\n\n    if (this._resolver instanceof AsyncResolver) {\n      this._resolve4 = this._resolver.resolve4.bind(this._resolver);\n      this._resolve6 = this._resolver.resolve6.bind(this._resolver);\n    } else {\n      this._resolve4 = promisify(this._resolver.resolve4.bind(this._resolver));\n      this._resolve6 = promisify(this._resolver.resolve6.bind(this._resolver));\n    }\n\n    this._iface = getIfaceInfo();\n    this._pending = {};\n    this._nextRemovalTime = false;\n    this._hostnamesToFallback = new Set();\n    this.fallbackDuration = fallbackDuration;\n\n    if (fallbackDuration > 0) {\n      const interval = setInterval(() => {\n        this._hostnamesToFallback.clear();\n      }, fallbackDuration * 1000);\n      /* istanbul ignore next: There is no `interval.unref()` when running inside an Electron renderer */\n\n      if (interval.unref) {\n        interval.unref();\n      }\n\n      this._fallbackInterval = interval;\n    }\n\n    this.lookup = this.lookup.bind(this);\n    this.lookupAsync = this.lookupAsync.bind(this);\n  }\n\n  set servers(servers) {\n    this.clear();\n\n    this._resolver.setServers(servers);\n  }\n\n  get servers() {\n    return this._resolver.getServers();\n  }\n\n  lookup(hostname, options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    } else if (typeof options === 'number') {\n      options = {\n        family: options\n      };\n    }\n\n    if (!callback) {\n      throw new Error('Callback must be a function.');\n    } // eslint-disable-next-line promise/prefer-await-to-then\n\n\n    this.lookupAsync(hostname, options).then(result => {\n      if (options.all) {\n        callback(null, result);\n      } else {\n        callback(null, result.address, result.family, result.expires, result.ttl);\n      }\n    }, callback);\n  }\n\n  async lookupAsync(hostname, options = {}) {\n    if (typeof options === 'number') {\n      options = {\n        family: options\n      };\n    }\n\n    let cached = await this.query(hostname);\n\n    if (options.family === 6) {\n      const filtered = cached.filter(entry => entry.family === 6);\n\n      if (options.hints & V4MAPPED) {\n        if (supportsALL && options.hints & ALL || filtered.length === 0) {\n          map4to6(cached);\n        } else {\n          cached = filtered;\n        }\n      } else {\n        cached = filtered;\n      }\n    } else if (options.family === 4) {\n      cached = cached.filter(entry => entry.family === 4);\n    }\n\n    if (options.hints & ADDRCONFIG) {\n      const {\n        _iface\n      } = this;\n      cached = cached.filter(entry => entry.family === 6 ? _iface.has6 : _iface.has4);\n    }\n\n    if (cached.length === 0) {\n      const error = new Error(`cacheableLookup ENOTFOUND ${hostname}`);\n      error.code = 'ENOTFOUND';\n      error.hostname = hostname;\n      throw error;\n    }\n\n    if (options.all) {\n      return cached;\n    }\n\n    return cached[0];\n  }\n\n  async query(hostname) {\n    let cached = await this._cache.get(hostname);\n\n    if (!cached) {\n      const pending = this._pending[hostname];\n\n      if (pending) {\n        cached = await pending;\n      } else {\n        const newPromise = this.queryAndCache(hostname);\n        this._pending[hostname] = newPromise;\n\n        try {\n          cached = await newPromise;\n        } finally {\n          delete this._pending[hostname];\n        }\n      }\n    }\n\n    cached = cached.map(entry => {\n      return { ...entry\n      };\n    });\n    return cached;\n  }\n\n  async _resolve(hostname) {\n    // ANY is unsafe as it doesn't trigger new queries in the underlying server.\n    const [A, AAAA] = await Promise.all([ignoreNoResultErrors(this._resolve4(hostname, ttl)), ignoreNoResultErrors(this._resolve6(hostname, ttl))]);\n    let aTtl = 0;\n    let aaaaTtl = 0;\n    let cacheTtl = 0;\n    const now = Date.now();\n\n    for (const entry of A) {\n      entry.family = 4;\n      entry.expires = now + entry.ttl * 1000;\n      aTtl = Math.max(aTtl, entry.ttl);\n    }\n\n    for (const entry of AAAA) {\n      entry.family = 6;\n      entry.expires = now + entry.ttl * 1000;\n      aaaaTtl = Math.max(aaaaTtl, entry.ttl);\n    }\n\n    if (A.length > 0) {\n      if (AAAA.length > 0) {\n        cacheTtl = Math.min(aTtl, aaaaTtl);\n      } else {\n        cacheTtl = aTtl;\n      }\n    } else {\n      cacheTtl = aaaaTtl;\n    }\n\n    return {\n      entries: [...A, ...AAAA],\n      cacheTtl\n    };\n  }\n\n  async _lookup(hostname) {\n    try {\n      const [A, AAAA] = await Promise.all([// Passing {all: true} doesn't return all IPv4 and IPv6 entries.\n      // See https://github.com/szmarczak/cacheable-lookup/issues/42\n      ignoreNoResultErrors(this._dnsLookup(hostname, all4)), ignoreNoResultErrors(this._dnsLookup(hostname, all6))]);\n      return {\n        entries: [...A, ...AAAA],\n        cacheTtl: 0\n      };\n    } catch {\n      return {\n        entries: [],\n        cacheTtl: 0\n      };\n    }\n  }\n\n  async _set(hostname, data, cacheTtl) {\n    if (this.maxTtl > 0 && cacheTtl > 0) {\n      cacheTtl = Math.min(cacheTtl, this.maxTtl) * 1000;\n      data[kExpires] = Date.now() + cacheTtl;\n\n      try {\n        await this._cache.set(hostname, data, cacheTtl);\n      } catch (error) {\n        this.lookupAsync = async () => {\n          const cacheError = new Error('Cache Error. Please recreate the CacheableLookup instance.');\n          cacheError.cause = error;\n          throw cacheError;\n        };\n      }\n\n      if (isIterable(this._cache)) {\n        this._tick(cacheTtl);\n      }\n    }\n  }\n\n  async queryAndCache(hostname) {\n    if (this._hostnamesToFallback.has(hostname)) {\n      return this._dnsLookup(hostname, all);\n    }\n\n    let query = await this._resolve(hostname);\n\n    if (query.entries.length === 0 && this._dnsLookup) {\n      query = await this._lookup(hostname);\n\n      if (query.entries.length !== 0 && this.fallbackDuration > 0) {\n        // Use `dns.lookup(...)` for that particular hostname\n        this._hostnamesToFallback.add(hostname);\n      }\n    }\n\n    const cacheTtl = query.entries.length === 0 ? this.errorTtl : query.cacheTtl;\n    await this._set(hostname, query.entries, cacheTtl);\n    return query.entries;\n  }\n\n  _tick(ms) {\n    const nextRemovalTime = this._nextRemovalTime;\n\n    if (!nextRemovalTime || ms < nextRemovalTime) {\n      clearTimeout(this._removalTimeout);\n      this._nextRemovalTime = ms;\n      this._removalTimeout = setTimeout(() => {\n        this._nextRemovalTime = false;\n        let nextExpiry = Infinity;\n        const now = Date.now();\n\n        for (const [hostname, entries] of this._cache) {\n          const expires = entries[kExpires];\n\n          if (now >= expires) {\n            this._cache.delete(hostname);\n          } else if (expires < nextExpiry) {\n            nextExpiry = expires;\n          }\n        }\n\n        if (nextExpiry !== Infinity) {\n          this._tick(nextExpiry - now);\n        }\n      }, ms);\n      /* istanbul ignore next: There is no `timeout.unref()` when running inside an Electron renderer */\n\n      if (this._removalTimeout.unref) {\n        this._removalTimeout.unref();\n      }\n    }\n  }\n\n  install(agent) {\n    verifyAgent(agent);\n\n    if (kCacheableLookupCreateConnection in agent) {\n      throw new Error('CacheableLookup has been already installed');\n    }\n\n    agent[kCacheableLookupCreateConnection] = agent.createConnection;\n    agent[kCacheableLookupInstance] = this;\n\n    agent.createConnection = (options, callback) => {\n      if (!('lookup' in options)) {\n        options.lookup = this.lookup;\n      }\n\n      return agent[kCacheableLookupCreateConnection](options, callback);\n    };\n  }\n\n  uninstall(agent) {\n    verifyAgent(agent);\n\n    if (agent[kCacheableLookupCreateConnection]) {\n      if (agent[kCacheableLookupInstance] !== this) {\n        throw new Error('The agent is not owned by this CacheableLookup instance');\n      }\n\n      agent.createConnection = agent[kCacheableLookupCreateConnection];\n      delete agent[kCacheableLookupCreateConnection];\n      delete agent[kCacheableLookupInstance];\n    }\n  }\n\n  updateInterfaceInfo() {\n    const {\n      _iface\n    } = this;\n    this._iface = getIfaceInfo();\n\n    if (_iface.has4 && !this._iface.has4 || _iface.has6 && !this._iface.has6) {\n      this._cache.clear();\n    }\n  }\n\n  clear(hostname) {\n    if (hostname) {\n      this._cache.delete(hostname);\n\n      return;\n    }\n\n    this._cache.clear();\n  }\n\n}\n\nmodule.exports = CacheableLookup;\nmodule.exports.default = CacheableLookup;","map":{"version":3,"names":["V4MAPPED","ADDRCONFIG","ALL","promises","Resolver","AsyncResolver","lookup","dnsLookup","require","promisify","os","kCacheableLookupCreateConnection","Symbol","kCacheableLookupInstance","kExpires","supportsALL","verifyAgent","agent","createConnection","Error","map4to6","entries","entry","family","address","getIfaceInfo","has4","has6","device","Object","values","networkInterfaces","iface","internal","isIterable","map","iterator","ignoreNoResultErrors","dnsPromise","catch","error","code","ttl","all","all4","all6","CacheableLookup","constructor","cache","Map","maxTtl","Infinity","fallbackDuration","errorTtl","resolver","_cache","_resolver","_dnsLookup","_resolve4","resolve4","bind","_resolve6","resolve6","_iface","_pending","_nextRemovalTime","_hostnamesToFallback","Set","interval","setInterval","clear","unref","_fallbackInterval","lookupAsync","servers","setServers","getServers","hostname","options","callback","then","result","expires","cached","query","filtered","filter","hints","length","get","pending","newPromise","queryAndCache","_resolve","A","AAAA","Promise","aTtl","aaaaTtl","cacheTtl","now","Date","Math","max","min","_lookup","_set","data","set","cacheError","cause","_tick","has","add","ms","nextRemovalTime","clearTimeout","_removalTimeout","setTimeout","nextExpiry","delete","install","uninstall","updateInterfaceInfo","module","exports","default"],"sources":["E:/web/alchemists_vue/alchemists/node_modules/cacheable-lookup/source/index.js"],"sourcesContent":["'use strict';\nconst {\n\tV4MAPPED,\n\tADDRCONFIG,\n\tALL,\n\tpromises: {\n\t\tResolver: AsyncResolver\n\t},\n\tlookup: dnsLookup\n} = require('dns');\nconst {promisify} = require('util');\nconst os = require('os');\n\nconst kCacheableLookupCreateConnection = Symbol('cacheableLookupCreateConnection');\nconst kCacheableLookupInstance = Symbol('cacheableLookupInstance');\nconst kExpires = Symbol('expires');\n\nconst supportsALL = typeof ALL === 'number';\n\nconst verifyAgent = agent => {\n\tif (!(agent && typeof agent.createConnection === 'function')) {\n\t\tthrow new Error('Expected an Agent instance as the first argument');\n\t}\n};\n\nconst map4to6 = entries => {\n\tfor (const entry of entries) {\n\t\tif (entry.family === 6) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tentry.address = `::ffff:${entry.address}`;\n\t\tentry.family = 6;\n\t}\n};\n\nconst getIfaceInfo = () => {\n\tlet has4 = false;\n\tlet has6 = false;\n\n\tfor (const device of Object.values(os.networkInterfaces())) {\n\t\tfor (const iface of device) {\n\t\t\tif (iface.internal) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (iface.family === 'IPv6') {\n\t\t\t\thas6 = true;\n\t\t\t} else {\n\t\t\t\thas4 = true;\n\t\t\t}\n\n\t\t\tif (has4 && has6) {\n\t\t\t\treturn {has4, has6};\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {has4, has6};\n};\n\nconst isIterable = map => {\n\treturn Symbol.iterator in map;\n};\n\nconst ignoreNoResultErrors = dnsPromise => {\n\treturn dnsPromise.catch(error => {\n\t\tif (\n\t\t\terror.code === 'ENODATA' ||\n\t\t\terror.code === 'ENOTFOUND' ||\n\t\t\terror.code === 'ENOENT' // Windows: name exists, but not this record type\n\t\t) {\n\t\t\treturn [];\n\t\t}\n\n\t\tthrow error;\n\t});\n};\n\nconst ttl = {ttl: true};\nconst all = {all: true};\nconst all4 = {all: true, family: 4};\nconst all6 = {all: true, family: 6};\n\nclass CacheableLookup {\n\tconstructor({\n\t\tcache = new Map(),\n\t\tmaxTtl = Infinity,\n\t\tfallbackDuration = 3600,\n\t\terrorTtl = 0.15,\n\t\tresolver = new AsyncResolver(),\n\t\tlookup = dnsLookup\n\t} = {}) {\n\t\tthis.maxTtl = maxTtl;\n\t\tthis.errorTtl = errorTtl;\n\n\t\tthis._cache = cache;\n\t\tthis._resolver = resolver;\n\t\tthis._dnsLookup = lookup && promisify(lookup);\n\n\t\tif (this._resolver instanceof AsyncResolver) {\n\t\t\tthis._resolve4 = this._resolver.resolve4.bind(this._resolver);\n\t\t\tthis._resolve6 = this._resolver.resolve6.bind(this._resolver);\n\t\t} else {\n\t\t\tthis._resolve4 = promisify(this._resolver.resolve4.bind(this._resolver));\n\t\t\tthis._resolve6 = promisify(this._resolver.resolve6.bind(this._resolver));\n\t\t}\n\n\t\tthis._iface = getIfaceInfo();\n\n\t\tthis._pending = {};\n\t\tthis._nextRemovalTime = false;\n\t\tthis._hostnamesToFallback = new Set();\n\n\t\tthis.fallbackDuration = fallbackDuration;\n\n\t\tif (fallbackDuration > 0) {\n\t\t\tconst interval = setInterval(() => {\n\t\t\t\tthis._hostnamesToFallback.clear();\n\t\t\t}, fallbackDuration * 1000);\n\n\t\t\t/* istanbul ignore next: There is no `interval.unref()` when running inside an Electron renderer */\n\t\t\tif (interval.unref) {\n\t\t\t\tinterval.unref();\n\t\t\t}\n\n\t\t\tthis._fallbackInterval = interval;\n\t\t}\n\n\t\tthis.lookup = this.lookup.bind(this);\n\t\tthis.lookupAsync = this.lookupAsync.bind(this);\n\t}\n\n\tset servers(servers) {\n\t\tthis.clear();\n\n\t\tthis._resolver.setServers(servers);\n\t}\n\n\tget servers() {\n\t\treturn this._resolver.getServers();\n\t}\n\n\tlookup(hostname, options, callback) {\n\t\tif (typeof options === 'function') {\n\t\t\tcallback = options;\n\t\t\toptions = {};\n\t\t} else if (typeof options === 'number') {\n\t\t\toptions = {\n\t\t\t\tfamily: options\n\t\t\t};\n\t\t}\n\n\t\tif (!callback) {\n\t\t\tthrow new Error('Callback must be a function.');\n\t\t}\n\n\t\t// eslint-disable-next-line promise/prefer-await-to-then\n\t\tthis.lookupAsync(hostname, options).then(result => {\n\t\t\tif (options.all) {\n\t\t\t\tcallback(null, result);\n\t\t\t} else {\n\t\t\t\tcallback(null, result.address, result.family, result.expires, result.ttl);\n\t\t\t}\n\t\t}, callback);\n\t}\n\n\tasync lookupAsync(hostname, options = {}) {\n\t\tif (typeof options === 'number') {\n\t\t\toptions = {\n\t\t\t\tfamily: options\n\t\t\t};\n\t\t}\n\n\t\tlet cached = await this.query(hostname);\n\n\t\tif (options.family === 6) {\n\t\t\tconst filtered = cached.filter(entry => entry.family === 6);\n\n\t\t\tif (options.hints & V4MAPPED) {\n\t\t\t\tif ((supportsALL && options.hints & ALL) || filtered.length === 0) {\n\t\t\t\t\tmap4to6(cached);\n\t\t\t\t} else {\n\t\t\t\t\tcached = filtered;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcached = filtered;\n\t\t\t}\n\t\t} else if (options.family === 4) {\n\t\t\tcached = cached.filter(entry => entry.family === 4);\n\t\t}\n\n\t\tif (options.hints & ADDRCONFIG) {\n\t\t\tconst {_iface} = this;\n\t\t\tcached = cached.filter(entry => entry.family === 6 ? _iface.has6 : _iface.has4);\n\t\t}\n\n\t\tif (cached.length === 0) {\n\t\t\tconst error = new Error(`cacheableLookup ENOTFOUND ${hostname}`);\n\t\t\terror.code = 'ENOTFOUND';\n\t\t\terror.hostname = hostname;\n\n\t\t\tthrow error;\n\t\t}\n\n\t\tif (options.all) {\n\t\t\treturn cached;\n\t\t}\n\n\t\treturn cached[0];\n\t}\n\n\tasync query(hostname) {\n\t\tlet cached = await this._cache.get(hostname);\n\n\t\tif (!cached) {\n\t\t\tconst pending = this._pending[hostname];\n\n\t\t\tif (pending) {\n\t\t\t\tcached = await pending;\n\t\t\t} else {\n\t\t\t\tconst newPromise = this.queryAndCache(hostname);\n\t\t\t\tthis._pending[hostname] = newPromise;\n\n\t\t\t\ttry {\n\t\t\t\t\tcached = await newPromise;\n\t\t\t\t} finally {\n\t\t\t\t\tdelete this._pending[hostname];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcached = cached.map(entry => {\n\t\t\treturn {...entry};\n\t\t});\n\n\t\treturn cached;\n\t}\n\n\tasync _resolve(hostname) {\n\t\t// ANY is unsafe as it doesn't trigger new queries in the underlying server.\n\t\tconst [A, AAAA] = await Promise.all([\n\t\t\tignoreNoResultErrors(this._resolve4(hostname, ttl)),\n\t\t\tignoreNoResultErrors(this._resolve6(hostname, ttl))\n\t\t]);\n\n\t\tlet aTtl = 0;\n\t\tlet aaaaTtl = 0;\n\t\tlet cacheTtl = 0;\n\n\t\tconst now = Date.now();\n\n\t\tfor (const entry of A) {\n\t\t\tentry.family = 4;\n\t\t\tentry.expires = now + (entry.ttl * 1000);\n\n\t\t\taTtl = Math.max(aTtl, entry.ttl);\n\t\t}\n\n\t\tfor (const entry of AAAA) {\n\t\t\tentry.family = 6;\n\t\t\tentry.expires = now + (entry.ttl * 1000);\n\n\t\t\taaaaTtl = Math.max(aaaaTtl, entry.ttl);\n\t\t}\n\n\t\tif (A.length > 0) {\n\t\t\tif (AAAA.length > 0) {\n\t\t\t\tcacheTtl = Math.min(aTtl, aaaaTtl);\n\t\t\t} else {\n\t\t\t\tcacheTtl = aTtl;\n\t\t\t}\n\t\t} else {\n\t\t\tcacheTtl = aaaaTtl;\n\t\t}\n\n\t\treturn {\n\t\t\tentries: [\n\t\t\t\t...A,\n\t\t\t\t...AAAA\n\t\t\t],\n\t\t\tcacheTtl\n\t\t};\n\t}\n\n\tasync _lookup(hostname) {\n\t\ttry {\n\t\t\tconst [A, AAAA] = await Promise.all([\n\t\t\t\t// Passing {all: true} doesn't return all IPv4 and IPv6 entries.\n\t\t\t\t// See https://github.com/szmarczak/cacheable-lookup/issues/42\n\t\t\t\tignoreNoResultErrors(this._dnsLookup(hostname, all4)),\n\t\t\t\tignoreNoResultErrors(this._dnsLookup(hostname, all6))\n\t\t\t]);\n\n\t\t\treturn {\n\t\t\t\tentries: [\n\t\t\t\t\t...A,\n\t\t\t\t\t...AAAA\n\t\t\t\t],\n\t\t\t\tcacheTtl: 0\n\t\t\t};\n\t\t} catch {\n\t\t\treturn {\n\t\t\t\tentries: [],\n\t\t\t\tcacheTtl: 0\n\t\t\t};\n\t\t}\n\t}\n\n\tasync _set(hostname, data, cacheTtl) {\n\t\tif (this.maxTtl > 0 && cacheTtl > 0) {\n\t\t\tcacheTtl = Math.min(cacheTtl, this.maxTtl) * 1000;\n\t\t\tdata[kExpires] = Date.now() + cacheTtl;\n\n\t\t\ttry {\n\t\t\t\tawait this._cache.set(hostname, data, cacheTtl);\n\t\t\t} catch (error) {\n\t\t\t\tthis.lookupAsync = async () => {\n\t\t\t\t\tconst cacheError = new Error('Cache Error. Please recreate the CacheableLookup instance.');\n\t\t\t\t\tcacheError.cause = error;\n\n\t\t\t\t\tthrow cacheError;\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (isIterable(this._cache)) {\n\t\t\t\tthis._tick(cacheTtl);\n\t\t\t}\n\t\t}\n\t}\n\n\tasync queryAndCache(hostname) {\n\t\tif (this._hostnamesToFallback.has(hostname)) {\n\t\t\treturn this._dnsLookup(hostname, all);\n\t\t}\n\n\t\tlet query = await this._resolve(hostname);\n\n\t\tif (query.entries.length === 0 && this._dnsLookup) {\n\t\t\tquery = await this._lookup(hostname);\n\n\t\t\tif (query.entries.length !== 0 && this.fallbackDuration > 0) {\n\t\t\t\t// Use `dns.lookup(...)` for that particular hostname\n\t\t\t\tthis._hostnamesToFallback.add(hostname);\n\t\t\t}\n\t\t}\n\n\t\tconst cacheTtl = query.entries.length === 0 ? this.errorTtl : query.cacheTtl;\n\t\tawait this._set(hostname, query.entries, cacheTtl);\n\n\t\treturn query.entries;\n\t}\n\n\t_tick(ms) {\n\t\tconst nextRemovalTime = this._nextRemovalTime;\n\n\t\tif (!nextRemovalTime || ms < nextRemovalTime) {\n\t\t\tclearTimeout(this._removalTimeout);\n\n\t\t\tthis._nextRemovalTime = ms;\n\n\t\t\tthis._removalTimeout = setTimeout(() => {\n\t\t\t\tthis._nextRemovalTime = false;\n\n\t\t\t\tlet nextExpiry = Infinity;\n\n\t\t\t\tconst now = Date.now();\n\n\t\t\t\tfor (const [hostname, entries] of this._cache) {\n\t\t\t\t\tconst expires = entries[kExpires];\n\n\t\t\t\t\tif (now >= expires) {\n\t\t\t\t\t\tthis._cache.delete(hostname);\n\t\t\t\t\t} else if (expires < nextExpiry) {\n\t\t\t\t\t\tnextExpiry = expires;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (nextExpiry !== Infinity) {\n\t\t\t\t\tthis._tick(nextExpiry - now);\n\t\t\t\t}\n\t\t\t}, ms);\n\n\t\t\t/* istanbul ignore next: There is no `timeout.unref()` when running inside an Electron renderer */\n\t\t\tif (this._removalTimeout.unref) {\n\t\t\t\tthis._removalTimeout.unref();\n\t\t\t}\n\t\t}\n\t}\n\n\tinstall(agent) {\n\t\tverifyAgent(agent);\n\n\t\tif (kCacheableLookupCreateConnection in agent) {\n\t\t\tthrow new Error('CacheableLookup has been already installed');\n\t\t}\n\n\t\tagent[kCacheableLookupCreateConnection] = agent.createConnection;\n\t\tagent[kCacheableLookupInstance] = this;\n\n\t\tagent.createConnection = (options, callback) => {\n\t\t\tif (!('lookup' in options)) {\n\t\t\t\toptions.lookup = this.lookup;\n\t\t\t}\n\n\t\t\treturn agent[kCacheableLookupCreateConnection](options, callback);\n\t\t};\n\t}\n\n\tuninstall(agent) {\n\t\tverifyAgent(agent);\n\n\t\tif (agent[kCacheableLookupCreateConnection]) {\n\t\t\tif (agent[kCacheableLookupInstance] !== this) {\n\t\t\t\tthrow new Error('The agent is not owned by this CacheableLookup instance');\n\t\t\t}\n\n\t\t\tagent.createConnection = agent[kCacheableLookupCreateConnection];\n\n\t\t\tdelete agent[kCacheableLookupCreateConnection];\n\t\t\tdelete agent[kCacheableLookupInstance];\n\t\t}\n\t}\n\n\tupdateInterfaceInfo() {\n\t\tconst {_iface} = this;\n\n\t\tthis._iface = getIfaceInfo();\n\n\t\tif ((_iface.has4 && !this._iface.has4) || (_iface.has6 && !this._iface.has6)) {\n\t\t\tthis._cache.clear();\n\t\t}\n\t}\n\n\tclear(hostname) {\n\t\tif (hostname) {\n\t\t\tthis._cache.delete(hostname);\n\t\t\treturn;\n\t\t}\n\n\t\tthis._cache.clear();\n\t}\n}\n\nmodule.exports = CacheableLookup;\nmodule.exports.default = CacheableLookup;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}