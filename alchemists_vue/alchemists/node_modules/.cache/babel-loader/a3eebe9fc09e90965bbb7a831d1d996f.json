{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport { EventEmitter } from 'node:events';\nimport is from '@sindresorhus/is';\nimport PCancelable from 'p-cancelable';\nimport { HTTPError, RetryError } from '../core/errors.js';\nimport Request from '../core/index.js';\nimport { parseBody, isResponseOk } from '../core/response.js';\nimport proxyEvents from '../core/utils/proxy-events.js';\nimport { CancelError } from './types.js';\nconst proxiedRequestEvents = ['request', 'response', 'redirect', 'uploadProgress', 'downloadProgress'];\nexport default function asPromise(firstRequest) {\n  let globalRequest;\n  let globalResponse;\n  let normalizedOptions;\n  const emitter = new EventEmitter();\n  const promise = new PCancelable((resolve, reject, onCancel) => {\n    onCancel(() => {\n      globalRequest.destroy();\n    });\n    onCancel.shouldReject = false;\n    onCancel(() => {\n      reject(new CancelError(globalRequest));\n    });\n\n    const makeRequest = retryCount => {\n      // Errors when a new request is made after the promise settles.\n      // Used to detect a race condition.\n      // See https://github.com/sindresorhus/got/issues/1489\n      onCancel(() => {});\n      const request = firstRequest ?? new Request(undefined, undefined, normalizedOptions);\n      request.retryCount = retryCount;\n      request._noPipe = true;\n      globalRequest = request;\n      request.once('response', async response => {\n        // Parse body\n        const contentEncoding = (response.headers['content-encoding'] ?? '').toLowerCase();\n        const isCompressed = contentEncoding === 'gzip' || contentEncoding === 'deflate' || contentEncoding === 'br';\n        const {\n          options\n        } = request;\n\n        if (isCompressed && !options.decompress) {\n          response.body = response.rawBody;\n        } else {\n          try {\n            response.body = parseBody(response, options.responseType, options.parseJson, options.encoding);\n          } catch (error) {\n            // Fall back to `utf8`\n            response.body = response.rawBody.toString();\n\n            if (isResponseOk(response)) {\n              request._beforeError(error);\n\n              return;\n            }\n          }\n        }\n\n        try {\n          const hooks = options.hooks.afterResponse;\n\n          for (const [index, hook] of hooks.entries()) {\n            // @ts-expect-error TS doesn't notice that CancelableRequest is a Promise\n            // eslint-disable-next-line no-await-in-loop\n            response = await hook(response, async updatedOptions => {\n              options.merge(updatedOptions);\n              options.prefixUrl = '';\n\n              if (updatedOptions.url) {\n                options.url = updatedOptions.url;\n              } // Remove any further hooks for that request, because we'll call them anyway.\n              // The loop continues. We don't want duplicates (asPromise recursion).\n\n\n              options.hooks.afterResponse = options.hooks.afterResponse.slice(0, index);\n              throw new RetryError(request);\n            });\n\n            if (!(is.object(response) && is.number(response.statusCode) && !is.nullOrUndefined(response.body))) {\n              throw new TypeError('The `afterResponse` hook returned an invalid value');\n            }\n          }\n        } catch (error) {\n          request._beforeError(error);\n\n          return;\n        }\n\n        globalResponse = response;\n\n        if (!isResponseOk(response)) {\n          request._beforeError(new HTTPError(response));\n\n          return;\n        }\n\n        request.destroy();\n        resolve(request.options.resolveBodyOnly ? response.body : response);\n      });\n\n      const onError = error => {\n        if (promise.isCanceled) {\n          return;\n        }\n\n        const {\n          options\n        } = request;\n\n        if (error instanceof HTTPError && !options.throwHttpErrors) {\n          const {\n            response\n          } = error;\n          request.destroy();\n          resolve(request.options.resolveBodyOnly ? response.body : response);\n          return;\n        }\n\n        reject(error);\n      };\n\n      request.once('error', onError);\n      const previousBody = request.options?.body;\n      request.once('retry', (newRetryCount, error) => {\n        firstRequest = undefined;\n        const newBody = request.options.body;\n\n        if (previousBody === newBody && is.nodeStream(newBody)) {\n          error.message = 'Cannot retry with consumed body stream';\n          onError(error);\n          return;\n        } // This is needed! We need to reuse `request.options` because they can get modified!\n        // For example, by calling `promise.json()`.\n\n\n        normalizedOptions = request.options;\n        makeRequest(newRetryCount);\n      });\n      proxyEvents(request, emitter, proxiedRequestEvents);\n\n      if (is.undefined(firstRequest)) {\n        void request.flush();\n      }\n    };\n\n    makeRequest(0);\n  });\n\n  promise.on = (event, fn) => {\n    emitter.on(event, fn);\n    return promise;\n  };\n\n  const shortcut = responseType => {\n    const newPromise = (async () => {\n      // Wait until downloading has ended\n      await promise;\n      const {\n        options\n      } = globalResponse.request;\n      return parseBody(globalResponse, responseType, options.parseJson, options.encoding);\n    })(); // eslint-disable-next-line @typescript-eslint/no-floating-promises\n\n\n    Object.defineProperties(newPromise, Object.getOwnPropertyDescriptors(promise));\n    return newPromise;\n  };\n\n  promise.json = () => {\n    if (globalRequest.options) {\n      const {\n        headers\n      } = globalRequest.options;\n\n      if (!globalRequest.writableFinished && !('accept' in headers)) {\n        headers.accept = 'application/json';\n      }\n    }\n\n    return shortcut('json');\n  };\n\n  promise.buffer = () => shortcut('buffer');\n\n  promise.text = () => shortcut('text');\n\n  return promise;\n}","map":{"version":3,"names":["EventEmitter","is","PCancelable","HTTPError","RetryError","Request","parseBody","isResponseOk","proxyEvents","CancelError","proxiedRequestEvents","asPromise","firstRequest","globalRequest","globalResponse","normalizedOptions","emitter","promise","resolve","reject","onCancel","destroy","shouldReject","makeRequest","retryCount","request","undefined","_noPipe","once","response","contentEncoding","headers","toLowerCase","isCompressed","options","decompress","body","rawBody","responseType","parseJson","encoding","error","toString","_beforeError","hooks","afterResponse","index","hook","entries","updatedOptions","merge","prefixUrl","url","slice","object","number","statusCode","nullOrUndefined","TypeError","resolveBodyOnly","onError","isCanceled","throwHttpErrors","previousBody","newRetryCount","newBody","nodeStream","message","flush","on","event","fn","shortcut","newPromise","Object","defineProperties","getOwnPropertyDescriptors","json","writableFinished","accept","buffer","text"],"sources":["E:/web/alchemists_vue/alchemists/node_modules/got/dist/source/as-promise/index.js"],"sourcesContent":["import { EventEmitter } from 'node:events';\nimport is from '@sindresorhus/is';\nimport PCancelable from 'p-cancelable';\nimport { HTTPError, RetryError, } from '../core/errors.js';\nimport Request from '../core/index.js';\nimport { parseBody, isResponseOk } from '../core/response.js';\nimport proxyEvents from '../core/utils/proxy-events.js';\nimport { CancelError } from './types.js';\nconst proxiedRequestEvents = [\n    'request',\n    'response',\n    'redirect',\n    'uploadProgress',\n    'downloadProgress',\n];\nexport default function asPromise(firstRequest) {\n    let globalRequest;\n    let globalResponse;\n    let normalizedOptions;\n    const emitter = new EventEmitter();\n    const promise = new PCancelable((resolve, reject, onCancel) => {\n        onCancel(() => {\n            globalRequest.destroy();\n        });\n        onCancel.shouldReject = false;\n        onCancel(() => {\n            reject(new CancelError(globalRequest));\n        });\n        const makeRequest = (retryCount) => {\n            // Errors when a new request is made after the promise settles.\n            // Used to detect a race condition.\n            // See https://github.com/sindresorhus/got/issues/1489\n            onCancel(() => { });\n            const request = firstRequest ?? new Request(undefined, undefined, normalizedOptions);\n            request.retryCount = retryCount;\n            request._noPipe = true;\n            globalRequest = request;\n            request.once('response', async (response) => {\n                // Parse body\n                const contentEncoding = (response.headers['content-encoding'] ?? '').toLowerCase();\n                const isCompressed = contentEncoding === 'gzip' || contentEncoding === 'deflate' || contentEncoding === 'br';\n                const { options } = request;\n                if (isCompressed && !options.decompress) {\n                    response.body = response.rawBody;\n                }\n                else {\n                    try {\n                        response.body = parseBody(response, options.responseType, options.parseJson, options.encoding);\n                    }\n                    catch (error) {\n                        // Fall back to `utf8`\n                        response.body = response.rawBody.toString();\n                        if (isResponseOk(response)) {\n                            request._beforeError(error);\n                            return;\n                        }\n                    }\n                }\n                try {\n                    const hooks = options.hooks.afterResponse;\n                    for (const [index, hook] of hooks.entries()) {\n                        // @ts-expect-error TS doesn't notice that CancelableRequest is a Promise\n                        // eslint-disable-next-line no-await-in-loop\n                        response = await hook(response, async (updatedOptions) => {\n                            options.merge(updatedOptions);\n                            options.prefixUrl = '';\n                            if (updatedOptions.url) {\n                                options.url = updatedOptions.url;\n                            }\n                            // Remove any further hooks for that request, because we'll call them anyway.\n                            // The loop continues. We don't want duplicates (asPromise recursion).\n                            options.hooks.afterResponse = options.hooks.afterResponse.slice(0, index);\n                            throw new RetryError(request);\n                        });\n                        if (!(is.object(response) && is.number(response.statusCode) && !is.nullOrUndefined(response.body))) {\n                            throw new TypeError('The `afterResponse` hook returned an invalid value');\n                        }\n                    }\n                }\n                catch (error) {\n                    request._beforeError(error);\n                    return;\n                }\n                globalResponse = response;\n                if (!isResponseOk(response)) {\n                    request._beforeError(new HTTPError(response));\n                    return;\n                }\n                request.destroy();\n                resolve(request.options.resolveBodyOnly ? response.body : response);\n            });\n            const onError = (error) => {\n                if (promise.isCanceled) {\n                    return;\n                }\n                const { options } = request;\n                if (error instanceof HTTPError && !options.throwHttpErrors) {\n                    const { response } = error;\n                    request.destroy();\n                    resolve(request.options.resolveBodyOnly ? response.body : response);\n                    return;\n                }\n                reject(error);\n            };\n            request.once('error', onError);\n            const previousBody = request.options?.body;\n            request.once('retry', (newRetryCount, error) => {\n                firstRequest = undefined;\n                const newBody = request.options.body;\n                if (previousBody === newBody && is.nodeStream(newBody)) {\n                    error.message = 'Cannot retry with consumed body stream';\n                    onError(error);\n                    return;\n                }\n                // This is needed! We need to reuse `request.options` because they can get modified!\n                // For example, by calling `promise.json()`.\n                normalizedOptions = request.options;\n                makeRequest(newRetryCount);\n            });\n            proxyEvents(request, emitter, proxiedRequestEvents);\n            if (is.undefined(firstRequest)) {\n                void request.flush();\n            }\n        };\n        makeRequest(0);\n    });\n    promise.on = (event, fn) => {\n        emitter.on(event, fn);\n        return promise;\n    };\n    const shortcut = (responseType) => {\n        const newPromise = (async () => {\n            // Wait until downloading has ended\n            await promise;\n            const { options } = globalResponse.request;\n            return parseBody(globalResponse, responseType, options.parseJson, options.encoding);\n        })();\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        Object.defineProperties(newPromise, Object.getOwnPropertyDescriptors(promise));\n        return newPromise;\n    };\n    promise.json = () => {\n        if (globalRequest.options) {\n            const { headers } = globalRequest.options;\n            if (!globalRequest.writableFinished && !('accept' in headers)) {\n                headers.accept = 'application/json';\n            }\n        }\n        return shortcut('json');\n    };\n    promise.buffer = () => shortcut('buffer');\n    promise.text = () => shortcut('text');\n    return promise;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}