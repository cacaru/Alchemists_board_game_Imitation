{"ast":null,"code":"'use strict'; // See https://github.com/facebook/jest/issues/2549\n// eslint-disable-next-line node/prefer-global/url\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nconst {\n  URL,\n  urlToHttpOptions\n} = require('url');\n\nconst http2 = require('http2');\n\nconst {\n  Writable\n} = require('stream');\n\nconst {\n  Agent,\n  globalAgent\n} = require('./agent.js');\n\nconst IncomingMessage = require('./incoming-message.js');\n\nconst proxyEvents = require('./utils/proxy-events.js');\n\nconst {\n  ERR_INVALID_ARG_TYPE,\n  ERR_INVALID_PROTOCOL,\n  ERR_HTTP_HEADERS_SENT\n} = require('./utils/errors.js');\n\nconst validateHeaderName = require('./utils/validate-header-name.js');\n\nconst validateHeaderValue = require('./utils/validate-header-value.js');\n\nconst proxySocketHandler = require('./utils/proxy-socket-handler.js');\n\nconst {\n  HTTP2_HEADER_STATUS,\n  HTTP2_HEADER_METHOD,\n  HTTP2_HEADER_PATH,\n  HTTP2_HEADER_AUTHORITY,\n  HTTP2_METHOD_CONNECT\n} = http2.constants;\nconst kHeaders = Symbol('headers');\nconst kOrigin = Symbol('origin');\nconst kSession = Symbol('session');\nconst kOptions = Symbol('options');\nconst kFlushedHeaders = Symbol('flushedHeaders');\nconst kJobs = Symbol('jobs');\nconst kPendingAgentPromise = Symbol('pendingAgentPromise');\n\nclass ClientRequest extends Writable {\n  constructor(input, options, callback) {\n    super({\n      autoDestroy: false,\n      emitClose: false\n    });\n\n    if (typeof input === 'string') {\n      input = urlToHttpOptions(new URL(input));\n    } else if (input instanceof URL) {\n      input = urlToHttpOptions(input);\n    } else {\n      input = { ...input\n      };\n    }\n\n    if (typeof options === 'function' || options === undefined) {\n      // (options, callback)\n      callback = options;\n      options = input;\n    } else {\n      // (input, options, callback)\n      options = Object.assign(input, options);\n    }\n\n    if (options.h2session) {\n      this[kSession] = options.h2session;\n\n      if (this[kSession].destroyed) {\n        throw new Error('The session has been closed already');\n      }\n\n      this.protocol = this[kSession].socket.encrypted ? 'https:' : 'http:';\n    } else if (options.agent === false) {\n      this.agent = new Agent({\n        maxEmptySessions: 0\n      });\n    } else if (typeof options.agent === 'undefined' || options.agent === null) {\n      this.agent = globalAgent;\n    } else if (typeof options.agent.request === 'function') {\n      this.agent = options.agent;\n    } else {\n      throw new ERR_INVALID_ARG_TYPE('options.agent', ['http2wrapper.Agent-like Object', 'undefined', 'false'], options.agent);\n    }\n\n    if (this.agent) {\n      this.protocol = this.agent.protocol;\n    }\n\n    if (options.protocol && options.protocol !== this.protocol) {\n      throw new ERR_INVALID_PROTOCOL(options.protocol, this.protocol);\n    }\n\n    if (!options.port) {\n      options.port = options.defaultPort || this.agent && this.agent.defaultPort || 443;\n    }\n\n    options.host = options.hostname || options.host || 'localhost'; // Unused\n\n    delete options.hostname;\n    const {\n      timeout\n    } = options;\n    options.timeout = undefined;\n    this[kHeaders] = Object.create(null);\n    this[kJobs] = [];\n    this[kPendingAgentPromise] = undefined;\n    this.socket = null;\n    this.connection = null;\n    this.method = options.method || 'GET';\n\n    if (!(this.method === 'CONNECT' && (options.path === '/' || options.path === undefined))) {\n      this.path = options.path;\n    }\n\n    this.res = null;\n    this.aborted = false;\n    this.reusedSocket = false;\n    const {\n      headers\n    } = options;\n\n    if (headers) {\n      // eslint-disable-next-line guard-for-in\n      for (const header in headers) {\n        this.setHeader(header, headers[header]);\n      }\n    }\n\n    if (options.auth && !('authorization' in this[kHeaders])) {\n      this[kHeaders].authorization = 'Basic ' + Buffer.from(options.auth).toString('base64');\n    }\n\n    options.session = options.tlsSession;\n    options.path = options.socketPath;\n    this[kOptions] = options; // Clients that generate HTTP/2 requests directly SHOULD use the :authority pseudo-header field instead of the Host header field.\n\n    this[kOrigin] = new URL(`${this.protocol}//${options.servername || options.host}:${options.port}`); // A socket is being reused\n\n    const reuseSocket = options._reuseSocket;\n\n    if (reuseSocket) {\n      options.createConnection = (...args) => {\n        if (reuseSocket.destroyed) {\n          return this.agent.createConnection(...args);\n        }\n\n        return reuseSocket;\n      }; // eslint-disable-next-line promise/prefer-await-to-then\n\n\n      this.agent.getSession(this[kOrigin], this[kOptions]).catch(() => {});\n    }\n\n    if (timeout) {\n      this.setTimeout(timeout);\n    }\n\n    if (callback) {\n      this.once('response', callback);\n    }\n\n    this[kFlushedHeaders] = false;\n  }\n\n  get method() {\n    return this[kHeaders][HTTP2_HEADER_METHOD];\n  }\n\n  set method(value) {\n    if (value) {\n      this[kHeaders][HTTP2_HEADER_METHOD] = value.toUpperCase();\n    }\n  }\n\n  get path() {\n    const header = this.method === 'CONNECT' ? HTTP2_HEADER_AUTHORITY : HTTP2_HEADER_PATH;\n    return this[kHeaders][header];\n  }\n\n  set path(value) {\n    if (value) {\n      const header = this.method === 'CONNECT' ? HTTP2_HEADER_AUTHORITY : HTTP2_HEADER_PATH;\n      this[kHeaders][header] = value;\n    }\n  }\n\n  get host() {\n    return this[kOrigin].hostname;\n  }\n\n  set host(_value) {// Do nothing as this is read only.\n  }\n\n  get _mustNotHaveABody() {\n    return this.method === 'GET' || this.method === 'HEAD' || this.method === 'DELETE';\n  }\n\n  _write(chunk, encoding, callback) {\n    // https://github.com/nodejs/node/blob/654df09ae0c5e17d1b52a900a545f0664d8c7627/lib/internal/http2/util.js#L148-L156\n    if (this._mustNotHaveABody) {\n      callback(new Error('The GET, HEAD and DELETE methods must NOT have a body'));\n      /* istanbul ignore next: Node.js 12 throws directly */\n\n      return;\n    }\n\n    this.flushHeaders();\n\n    const callWrite = () => this._request.write(chunk, encoding, callback);\n\n    if (this._request) {\n      callWrite();\n    } else {\n      this[kJobs].push(callWrite);\n    }\n  }\n\n  _final(callback) {\n    this.flushHeaders();\n\n    const callEnd = () => {\n      // For GET, HEAD and DELETE and CONNECT\n      if (this._mustNotHaveABody || this.method === 'CONNECT') {\n        callback();\n        return;\n      }\n\n      this._request.end(callback);\n    };\n\n    if (this._request) {\n      callEnd();\n    } else {\n      this[kJobs].push(callEnd);\n    }\n  }\n\n  abort() {\n    if (this.res && this.res.complete) {\n      return;\n    }\n\n    if (!this.aborted) {\n      process.nextTick(() => this.emit('abort'));\n    }\n\n    this.aborted = true;\n    this.destroy();\n  }\n\n  async _destroy(error, callback) {\n    if (this.res) {\n      this.res._dump();\n    }\n\n    if (this._request) {\n      this._request.destroy();\n    } else {\n      process.nextTick(() => {\n        this.emit('close');\n      });\n    }\n\n    try {\n      await this[kPendingAgentPromise];\n    } catch (internalError) {\n      if (this.aborted) {\n        error = internalError;\n      }\n    }\n\n    callback(error);\n  }\n\n  async flushHeaders() {\n    if (this[kFlushedHeaders] || this.destroyed) {\n      return;\n    }\n\n    this[kFlushedHeaders] = true;\n    const isConnectMethod = this.method === HTTP2_METHOD_CONNECT; // The real magic is here\n\n    const onStream = stream => {\n      this._request = stream;\n\n      if (this.destroyed) {\n        stream.destroy();\n        return;\n      } // Forwards `timeout`, `continue`, `close` and `error` events to this instance.\n\n\n      if (!isConnectMethod) {\n        // TODO: Should we proxy `close` here?\n        proxyEvents(stream, this, ['timeout', 'continue']);\n      }\n\n      stream.once('error', error => {\n        this.destroy(error);\n      });\n      stream.once('aborted', () => {\n        const {\n          res\n        } = this;\n\n        if (res) {\n          res.aborted = true;\n          res.emit('aborted');\n          res.destroy();\n        } else {\n          this.destroy(new Error('The server aborted the HTTP/2 stream'));\n        }\n      });\n\n      const onResponse = (headers, flags, rawHeaders) => {\n        // If we were to emit raw request stream, it would be as fast as the native approach.\n        // Note that wrapping the raw stream in a Proxy instance won't improve the performance (already tested it).\n        const response = new IncomingMessage(this.socket, stream.readableHighWaterMark);\n        this.res = response; // Undocumented, but it is used by `cacheable-request`\n\n        response.url = `${this[kOrigin].origin}${this.path}`;\n        response.req = this;\n        response.statusCode = headers[HTTP2_HEADER_STATUS];\n        response.headers = headers;\n        response.rawHeaders = rawHeaders;\n        response.once('end', () => {\n          response.complete = true; // Has no effect, just be consistent with the Node.js behavior\n\n          response.socket = null;\n          response.connection = null;\n        });\n\n        if (isConnectMethod) {\n          response.upgrade = true; // The HTTP1 API says the socket is detached here,\n          // but we can't do that so we pass the original HTTP2 request.\n\n          if (this.emit('connect', response, stream, Buffer.alloc(0))) {\n            this.emit('close');\n          } else {\n            // No listeners attached, destroy the original request.\n            stream.destroy();\n          }\n        } else {\n          // Forwards data\n          stream.on('data', chunk => {\n            if (!response._dumped && !response.push(chunk)) {\n              stream.pause();\n            }\n          });\n          stream.once('end', () => {\n            if (!this.aborted) {\n              response.push(null);\n            }\n          });\n\n          if (!this.emit('response', response)) {\n            // No listeners attached, dump the response.\n            response._dump();\n          }\n        }\n      }; // This event tells we are ready to listen for the data.\n\n\n      stream.once('response', onResponse); // Emits `information` event\n\n      stream.once('headers', headers => this.emit('information', {\n        statusCode: headers[HTTP2_HEADER_STATUS]\n      }));\n      stream.once('trailers', (trailers, flags, rawTrailers) => {\n        const {\n          res\n        } = this; // https://github.com/nodejs/node/issues/41251\n\n        if (res === null) {\n          onResponse(trailers, flags, rawTrailers);\n          return;\n        } // Assigns trailers to the response object.\n\n\n        res.trailers = trailers;\n        res.rawTrailers = rawTrailers;\n      });\n      stream.once('close', () => {\n        const {\n          aborted,\n          res\n        } = this;\n\n        if (res) {\n          if (aborted) {\n            res.aborted = true;\n            res.emit('aborted');\n            res.destroy();\n          }\n\n          const finish = () => {\n            res.emit('close');\n            this.destroy();\n            this.emit('close');\n          };\n\n          if (res.readable) {\n            res.once('end', finish);\n          } else {\n            finish();\n          }\n\n          return;\n        }\n\n        if (!this.destroyed) {\n          this.destroy(new Error('The HTTP/2 stream has been early terminated'));\n          this.emit('close');\n          return;\n        }\n\n        this.destroy();\n        this.emit('close');\n      });\n      this.socket = new Proxy(stream, proxySocketHandler);\n\n      for (const job of this[kJobs]) {\n        job();\n      }\n\n      this.emit('socket', this.socket);\n    };\n\n    if (!(HTTP2_HEADER_AUTHORITY in this[kHeaders]) && !isConnectMethod) {\n      this[kHeaders][HTTP2_HEADER_AUTHORITY] = this[kOrigin].host;\n    } // Makes a HTTP2 request\n\n\n    if (this[kSession]) {\n      try {\n        onStream(this[kSession].request(this[kHeaders]));\n      } catch (error) {\n        this.destroy(error);\n      }\n    } else {\n      this.reusedSocket = true;\n\n      try {\n        const promise = this.agent.request(this[kOrigin], this[kOptions], this[kHeaders]);\n        this[kPendingAgentPromise] = promise;\n        onStream(await promise);\n        this[kPendingAgentPromise] = false;\n      } catch (error) {\n        this[kPendingAgentPromise] = false;\n        this.destroy(error);\n      }\n    }\n  }\n\n  get connection() {\n    return this.socket;\n  }\n\n  set connection(value) {\n    this.socket = value;\n  }\n\n  getHeaderNames() {\n    return Object.keys(this[kHeaders]);\n  }\n\n  hasHeader(name) {\n    if (typeof name !== 'string') {\n      throw new ERR_INVALID_ARG_TYPE('name', 'string', name);\n    }\n\n    return Boolean(this[kHeaders][name.toLowerCase()]);\n  }\n\n  getHeader(name) {\n    if (typeof name !== 'string') {\n      throw new ERR_INVALID_ARG_TYPE('name', 'string', name);\n    }\n\n    return this[kHeaders][name.toLowerCase()];\n  }\n\n  get headersSent() {\n    return this[kFlushedHeaders];\n  }\n\n  removeHeader(name) {\n    if (typeof name !== 'string') {\n      throw new ERR_INVALID_ARG_TYPE('name', 'string', name);\n    }\n\n    if (this.headersSent) {\n      throw new ERR_HTTP_HEADERS_SENT('remove');\n    }\n\n    delete this[kHeaders][name.toLowerCase()];\n  }\n\n  setHeader(name, value) {\n    if (this.headersSent) {\n      throw new ERR_HTTP_HEADERS_SENT('set');\n    }\n\n    validateHeaderName(name);\n    validateHeaderValue(name, value);\n    const lowercased = name.toLowerCase();\n\n    if (lowercased === 'connection') {\n      if (value.toLowerCase() === 'keep-alive') {\n        return;\n      }\n\n      throw new Error(`Invalid 'connection' header: ${value}`);\n    }\n\n    if (lowercased === 'host' && this.method === 'CONNECT') {\n      this[kHeaders][HTTP2_HEADER_AUTHORITY] = value;\n    } else {\n      this[kHeaders][lowercased] = value;\n    }\n  }\n\n  setNoDelay() {// HTTP2 sockets cannot be malformed, do nothing.\n  }\n\n  setSocketKeepAlive() {// HTTP2 sockets cannot be malformed, do nothing.\n  }\n\n  setTimeout(ms, callback) {\n    const applyTimeout = () => this._request.setTimeout(ms, callback);\n\n    if (this._request) {\n      applyTimeout();\n    } else {\n      this[kJobs].push(applyTimeout);\n    }\n\n    return this;\n  }\n\n  get maxHeadersCount() {\n    if (!this.destroyed && this._request) {\n      return this._request.session.localSettings.maxHeaderListSize;\n    }\n\n    return undefined;\n  }\n\n  set maxHeadersCount(_value) {// Updating HTTP2 settings would affect all requests, do nothing.\n  }\n\n}\n\nmodule.exports = ClientRequest;","map":{"version":3,"names":["URL","urlToHttpOptions","require","http2","Writable","Agent","globalAgent","IncomingMessage","proxyEvents","ERR_INVALID_ARG_TYPE","ERR_INVALID_PROTOCOL","ERR_HTTP_HEADERS_SENT","validateHeaderName","validateHeaderValue","proxySocketHandler","HTTP2_HEADER_STATUS","HTTP2_HEADER_METHOD","HTTP2_HEADER_PATH","HTTP2_HEADER_AUTHORITY","HTTP2_METHOD_CONNECT","constants","kHeaders","Symbol","kOrigin","kSession","kOptions","kFlushedHeaders","kJobs","kPendingAgentPromise","ClientRequest","constructor","input","options","callback","autoDestroy","emitClose","undefined","Object","assign","h2session","destroyed","Error","protocol","socket","encrypted","agent","maxEmptySessions","request","port","defaultPort","host","hostname","timeout","create","connection","method","path","res","aborted","reusedSocket","headers","header","setHeader","auth","authorization","Buffer","from","toString","session","tlsSession","socketPath","servername","reuseSocket","_reuseSocket","createConnection","args","getSession","catch","setTimeout","once","value","toUpperCase","_value","_mustNotHaveABody","_write","chunk","encoding","flushHeaders","callWrite","_request","write","push","_final","callEnd","end","abort","complete","process","nextTick","emit","destroy","_destroy","error","_dump","internalError","isConnectMethod","onStream","stream","onResponse","flags","rawHeaders","response","readableHighWaterMark","url","origin","req","statusCode","upgrade","alloc","on","_dumped","pause","trailers","rawTrailers","finish","readable","Proxy","job","promise","getHeaderNames","keys","hasHeader","name","Boolean","toLowerCase","getHeader","headersSent","removeHeader","lowercased","setNoDelay","setSocketKeepAlive","ms","applyTimeout","maxHeadersCount","localSettings","maxHeaderListSize","module","exports"],"sources":["E:/web/alchemists_vue/alchemists/node_modules/http2-wrapper/source/client-request.js"],"sourcesContent":["'use strict';\n// See https://github.com/facebook/jest/issues/2549\n// eslint-disable-next-line node/prefer-global/url\nconst {URL, urlToHttpOptions} = require('url');\nconst http2 = require('http2');\nconst {Writable} = require('stream');\nconst {Agent, globalAgent} = require('./agent.js');\nconst IncomingMessage = require('./incoming-message.js');\nconst proxyEvents = require('./utils/proxy-events.js');\nconst {\n\tERR_INVALID_ARG_TYPE,\n\tERR_INVALID_PROTOCOL,\n\tERR_HTTP_HEADERS_SENT\n} = require('./utils/errors.js');\nconst validateHeaderName = require('./utils/validate-header-name.js');\nconst validateHeaderValue = require('./utils/validate-header-value.js');\nconst proxySocketHandler = require('./utils/proxy-socket-handler.js');\n\nconst {\n\tHTTP2_HEADER_STATUS,\n\tHTTP2_HEADER_METHOD,\n\tHTTP2_HEADER_PATH,\n\tHTTP2_HEADER_AUTHORITY,\n\tHTTP2_METHOD_CONNECT\n} = http2.constants;\n\nconst kHeaders = Symbol('headers');\nconst kOrigin = Symbol('origin');\nconst kSession = Symbol('session');\nconst kOptions = Symbol('options');\nconst kFlushedHeaders = Symbol('flushedHeaders');\nconst kJobs = Symbol('jobs');\nconst kPendingAgentPromise = Symbol('pendingAgentPromise');\n\nclass ClientRequest extends Writable {\n\tconstructor(input, options, callback) {\n\t\tsuper({\n\t\t\tautoDestroy: false,\n\t\t\temitClose: false\n\t\t});\n\n\t\tif (typeof input === 'string') {\n\t\t\tinput = urlToHttpOptions(new URL(input));\n\t\t} else if (input instanceof URL) {\n\t\t\tinput = urlToHttpOptions(input);\n\t\t} else {\n\t\t\tinput = {...input};\n\t\t}\n\n\t\tif (typeof options === 'function' || options === undefined) {\n\t\t\t// (options, callback)\n\t\t\tcallback = options;\n\t\t\toptions = input;\n\t\t} else {\n\t\t\t// (input, options, callback)\n\t\t\toptions = Object.assign(input, options);\n\t\t}\n\n\t\tif (options.h2session) {\n\t\t\tthis[kSession] = options.h2session;\n\n\t\t\tif (this[kSession].destroyed) {\n\t\t\t\tthrow new Error('The session has been closed already');\n\t\t\t}\n\n\t\t\tthis.protocol = this[kSession].socket.encrypted ? 'https:' : 'http:';\n\t\t} else if (options.agent === false) {\n\t\t\tthis.agent = new Agent({maxEmptySessions: 0});\n\t\t} else if (typeof options.agent === 'undefined' || options.agent === null) {\n\t\t\tthis.agent = globalAgent;\n\t\t} else if (typeof options.agent.request === 'function') {\n\t\t\tthis.agent = options.agent;\n\t\t} else {\n\t\t\tthrow new ERR_INVALID_ARG_TYPE('options.agent', ['http2wrapper.Agent-like Object', 'undefined', 'false'], options.agent);\n\t\t}\n\n\t\tif (this.agent) {\n\t\t\tthis.protocol = this.agent.protocol;\n\t\t}\n\n\t\tif (options.protocol && options.protocol !== this.protocol) {\n\t\t\tthrow new ERR_INVALID_PROTOCOL(options.protocol, this.protocol);\n\t\t}\n\n\t\tif (!options.port) {\n\t\t\toptions.port = options.defaultPort || (this.agent && this.agent.defaultPort) || 443;\n\t\t}\n\n\t\toptions.host = options.hostname || options.host || 'localhost';\n\n\t\t// Unused\n\t\tdelete options.hostname;\n\n\t\tconst {timeout} = options;\n\t\toptions.timeout = undefined;\n\n\t\tthis[kHeaders] = Object.create(null);\n\t\tthis[kJobs] = [];\n\n\t\tthis[kPendingAgentPromise] = undefined;\n\n\t\tthis.socket = null;\n\t\tthis.connection = null;\n\n\t\tthis.method = options.method || 'GET';\n\n\t\tif (!(this.method === 'CONNECT' && (options.path === '/' || options.path === undefined))) {\n\t\t\tthis.path = options.path;\n\t\t}\n\n\t\tthis.res = null;\n\t\tthis.aborted = false;\n\t\tthis.reusedSocket = false;\n\n\t\tconst {headers} = options;\n\t\tif (headers) {\n\t\t\t// eslint-disable-next-line guard-for-in\n\t\t\tfor (const header in headers) {\n\t\t\t\tthis.setHeader(header, headers[header]);\n\t\t\t}\n\t\t}\n\n\t\tif (options.auth && !('authorization' in this[kHeaders])) {\n\t\t\tthis[kHeaders].authorization = 'Basic ' + Buffer.from(options.auth).toString('base64');\n\t\t}\n\n\t\toptions.session = options.tlsSession;\n\t\toptions.path = options.socketPath;\n\n\t\tthis[kOptions] = options;\n\n\t\t// Clients that generate HTTP/2 requests directly SHOULD use the :authority pseudo-header field instead of the Host header field.\n\t\tthis[kOrigin] = new URL(`${this.protocol}//${options.servername || options.host}:${options.port}`);\n\n\t\t// A socket is being reused\n\t\tconst reuseSocket = options._reuseSocket;\n\t\tif (reuseSocket) {\n\t\t\toptions.createConnection = (...args) => {\n\t\t\t\tif (reuseSocket.destroyed) {\n\t\t\t\t\treturn this.agent.createConnection(...args);\n\t\t\t\t}\n\n\t\t\t\treturn reuseSocket;\n\t\t\t};\n\n\t\t\t// eslint-disable-next-line promise/prefer-await-to-then\n\t\t\tthis.agent.getSession(this[kOrigin], this[kOptions]).catch(() => {});\n\t\t}\n\n\t\tif (timeout) {\n\t\t\tthis.setTimeout(timeout);\n\t\t}\n\n\t\tif (callback) {\n\t\t\tthis.once('response', callback);\n\t\t}\n\n\t\tthis[kFlushedHeaders] = false;\n\t}\n\n\tget method() {\n\t\treturn this[kHeaders][HTTP2_HEADER_METHOD];\n\t}\n\n\tset method(value) {\n\t\tif (value) {\n\t\t\tthis[kHeaders][HTTP2_HEADER_METHOD] = value.toUpperCase();\n\t\t}\n\t}\n\n\tget path() {\n\t\tconst header = this.method === 'CONNECT' ? HTTP2_HEADER_AUTHORITY : HTTP2_HEADER_PATH;\n\n\t\treturn this[kHeaders][header];\n\t}\n\n\tset path(value) {\n\t\tif (value) {\n\t\t\tconst header = this.method === 'CONNECT' ? HTTP2_HEADER_AUTHORITY : HTTP2_HEADER_PATH;\n\n\t\t\tthis[kHeaders][header] = value;\n\t\t}\n\t}\n\n\tget host() {\n\t\treturn this[kOrigin].hostname;\n\t}\n\n\tset host(_value) {\n\t\t// Do nothing as this is read only.\n\t}\n\n\tget _mustNotHaveABody() {\n\t\treturn this.method === 'GET' || this.method === 'HEAD' || this.method === 'DELETE';\n\t}\n\n\t_write(chunk, encoding, callback) {\n\t\t// https://github.com/nodejs/node/blob/654df09ae0c5e17d1b52a900a545f0664d8c7627/lib/internal/http2/util.js#L148-L156\n\t\tif (this._mustNotHaveABody) {\n\t\t\tcallback(new Error('The GET, HEAD and DELETE methods must NOT have a body'));\n\t\t\t/* istanbul ignore next: Node.js 12 throws directly */\n\t\t\treturn;\n\t\t}\n\n\t\tthis.flushHeaders();\n\n\t\tconst callWrite = () => this._request.write(chunk, encoding, callback);\n\t\tif (this._request) {\n\t\t\tcallWrite();\n\t\t} else {\n\t\t\tthis[kJobs].push(callWrite);\n\t\t}\n\t}\n\n\t_final(callback) {\n\t\tthis.flushHeaders();\n\n\t\tconst callEnd = () => {\n\t\t\t// For GET, HEAD and DELETE and CONNECT\n\t\t\tif (this._mustNotHaveABody || this.method === 'CONNECT') {\n\t\t\t\tcallback();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._request.end(callback);\n\t\t};\n\n\t\tif (this._request) {\n\t\t\tcallEnd();\n\t\t} else {\n\t\t\tthis[kJobs].push(callEnd);\n\t\t}\n\t}\n\n\tabort() {\n\t\tif (this.res && this.res.complete) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.aborted) {\n\t\t\tprocess.nextTick(() => this.emit('abort'));\n\t\t}\n\n\t\tthis.aborted = true;\n\n\t\tthis.destroy();\n\t}\n\n\tasync _destroy(error, callback) {\n\t\tif (this.res) {\n\t\t\tthis.res._dump();\n\t\t}\n\n\t\tif (this._request) {\n\t\t\tthis._request.destroy();\n\t\t} else {\n\t\t\tprocess.nextTick(() => {\n\t\t\t\tthis.emit('close');\n\t\t\t});\n\t\t}\n\n\t\ttry {\n\t\t\tawait this[kPendingAgentPromise];\n\t\t} catch (internalError) {\n\t\t\tif (this.aborted) {\n\t\t\t\terror = internalError;\n\t\t\t}\n\t\t}\n\n\t\tcallback(error);\n\t}\n\n\tasync flushHeaders() {\n\t\tif (this[kFlushedHeaders] || this.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis[kFlushedHeaders] = true;\n\n\t\tconst isConnectMethod = this.method === HTTP2_METHOD_CONNECT;\n\n\t\t// The real magic is here\n\t\tconst onStream = stream => {\n\t\t\tthis._request = stream;\n\n\t\t\tif (this.destroyed) {\n\t\t\t\tstream.destroy();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Forwards `timeout`, `continue`, `close` and `error` events to this instance.\n\t\t\tif (!isConnectMethod) {\n\t\t\t\t// TODO: Should we proxy `close` here?\n\t\t\t\tproxyEvents(stream, this, ['timeout', 'continue']);\n\t\t\t}\n\n\t\t\tstream.once('error', error => {\n\t\t\t\tthis.destroy(error);\n\t\t\t});\n\n\t\t\tstream.once('aborted', () => {\n\t\t\t\tconst {res} = this;\n\t\t\t\tif (res) {\n\t\t\t\t\tres.aborted = true;\n\t\t\t\t\tres.emit('aborted');\n\t\t\t\t\tres.destroy();\n\t\t\t\t} else {\n\t\t\t\t\tthis.destroy(new Error('The server aborted the HTTP/2 stream'));\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tconst onResponse = (headers, flags, rawHeaders) => {\n\t\t\t\t// If we were to emit raw request stream, it would be as fast as the native approach.\n\t\t\t\t// Note that wrapping the raw stream in a Proxy instance won't improve the performance (already tested it).\n\t\t\t\tconst response = new IncomingMessage(this.socket, stream.readableHighWaterMark);\n\t\t\t\tthis.res = response;\n\n\t\t\t\t// Undocumented, but it is used by `cacheable-request`\n\t\t\t\tresponse.url = `${this[kOrigin].origin}${this.path}`;\n\n\t\t\t\tresponse.req = this;\n\t\t\t\tresponse.statusCode = headers[HTTP2_HEADER_STATUS];\n\t\t\t\tresponse.headers = headers;\n\t\t\t\tresponse.rawHeaders = rawHeaders;\n\n\t\t\t\tresponse.once('end', () => {\n\t\t\t\t\tresponse.complete = true;\n\n\t\t\t\t\t// Has no effect, just be consistent with the Node.js behavior\n\t\t\t\t\tresponse.socket = null;\n\t\t\t\t\tresponse.connection = null;\n\t\t\t\t});\n\n\t\t\t\tif (isConnectMethod) {\n\t\t\t\t\tresponse.upgrade = true;\n\n\t\t\t\t\t// The HTTP1 API says the socket is detached here,\n\t\t\t\t\t// but we can't do that so we pass the original HTTP2 request.\n\t\t\t\t\tif (this.emit('connect', response, stream, Buffer.alloc(0))) {\n\t\t\t\t\t\tthis.emit('close');\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// No listeners attached, destroy the original request.\n\t\t\t\t\t\tstream.destroy();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Forwards data\n\t\t\t\t\tstream.on('data', chunk => {\n\t\t\t\t\t\tif (!response._dumped && !response.push(chunk)) {\n\t\t\t\t\t\t\tstream.pause();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tstream.once('end', () => {\n\t\t\t\t\t\tif (!this.aborted) {\n\t\t\t\t\t\t\tresponse.push(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tif (!this.emit('response', response)) {\n\t\t\t\t\t\t// No listeners attached, dump the response.\n\t\t\t\t\t\tresponse._dump();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// This event tells we are ready to listen for the data.\n\t\t\tstream.once('response', onResponse);\n\n\t\t\t// Emits `information` event\n\t\t\tstream.once('headers', headers => this.emit('information', {statusCode: headers[HTTP2_HEADER_STATUS]}));\n\n\t\t\tstream.once('trailers', (trailers, flags, rawTrailers) => {\n\t\t\t\tconst {res} = this;\n\n\t\t\t\t// https://github.com/nodejs/node/issues/41251\n\t\t\t\tif (res === null) {\n\t\t\t\t\tonResponse(trailers, flags, rawTrailers);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Assigns trailers to the response object.\n\t\t\t\tres.trailers = trailers;\n\t\t\t\tres.rawTrailers = rawTrailers;\n\t\t\t});\n\n\t\t\tstream.once('close', () => {\n\t\t\t\tconst {aborted, res} = this;\n\t\t\t\tif (res) {\n\t\t\t\t\tif (aborted) {\n\t\t\t\t\t\tres.aborted = true;\n\t\t\t\t\t\tres.emit('aborted');\n\t\t\t\t\t\tres.destroy();\n\t\t\t\t\t}\n\n\t\t\t\t\tconst finish = () => {\n\t\t\t\t\t\tres.emit('close');\n\n\t\t\t\t\t\tthis.destroy();\n\t\t\t\t\t\tthis.emit('close');\n\t\t\t\t\t};\n\n\t\t\t\t\tif (res.readable) {\n\t\t\t\t\t\tres.once('end', finish);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfinish();\n\t\t\t\t\t}\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (!this.destroyed) {\n\t\t\t\t\tthis.destroy(new Error('The HTTP/2 stream has been early terminated'));\n\t\t\t\t\tthis.emit('close');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis.destroy();\n\t\t\t\tthis.emit('close');\n\t\t\t});\n\n\t\t\tthis.socket = new Proxy(stream, proxySocketHandler);\n\n\t\t\tfor (const job of this[kJobs]) {\n\t\t\t\tjob();\n\t\t\t}\n\n\t\t\tthis.emit('socket', this.socket);\n\t\t};\n\n\t\tif (!(HTTP2_HEADER_AUTHORITY in this[kHeaders]) && !isConnectMethod) {\n\t\t\tthis[kHeaders][HTTP2_HEADER_AUTHORITY] = this[kOrigin].host;\n\t\t}\n\n\t\t// Makes a HTTP2 request\n\t\tif (this[kSession]) {\n\t\t\ttry {\n\t\t\t\tonStream(this[kSession].request(this[kHeaders]));\n\t\t\t} catch (error) {\n\t\t\t\tthis.destroy(error);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.reusedSocket = true;\n\n\t\t\ttry {\n\t\t\t\tconst promise = this.agent.request(this[kOrigin], this[kOptions], this[kHeaders]);\n\t\t\t\tthis[kPendingAgentPromise] = promise;\n\n\t\t\t\tonStream(await promise);\n\n\t\t\t\tthis[kPendingAgentPromise] = false;\n\t\t\t} catch (error) {\n\t\t\t\tthis[kPendingAgentPromise] = false;\n\n\t\t\t\tthis.destroy(error);\n\t\t\t}\n\t\t}\n\t}\n\n\tget connection() {\n\t\treturn this.socket;\n\t}\n\n\tset connection(value) {\n\t\tthis.socket = value;\n\t}\n\n\tgetHeaderNames() {\n\t\treturn Object.keys(this[kHeaders]);\n\t}\n\n\thasHeader(name) {\n\t\tif (typeof name !== 'string') {\n\t\t\tthrow new ERR_INVALID_ARG_TYPE('name', 'string', name);\n\t\t}\n\n\t\treturn Boolean(this[kHeaders][name.toLowerCase()]);\n\t}\n\n\tgetHeader(name) {\n\t\tif (typeof name !== 'string') {\n\t\t\tthrow new ERR_INVALID_ARG_TYPE('name', 'string', name);\n\t\t}\n\n\t\treturn this[kHeaders][name.toLowerCase()];\n\t}\n\n\tget headersSent() {\n\t\treturn this[kFlushedHeaders];\n\t}\n\n\tremoveHeader(name) {\n\t\tif (typeof name !== 'string') {\n\t\t\tthrow new ERR_INVALID_ARG_TYPE('name', 'string', name);\n\t\t}\n\n\t\tif (this.headersSent) {\n\t\t\tthrow new ERR_HTTP_HEADERS_SENT('remove');\n\t\t}\n\n\t\tdelete this[kHeaders][name.toLowerCase()];\n\t}\n\n\tsetHeader(name, value) {\n\t\tif (this.headersSent) {\n\t\t\tthrow new ERR_HTTP_HEADERS_SENT('set');\n\t\t}\n\n\t\tvalidateHeaderName(name);\n\t\tvalidateHeaderValue(name, value);\n\n\t\tconst lowercased = name.toLowerCase();\n\n\t\tif (lowercased === 'connection') {\n\t\t\tif (value.toLowerCase() === 'keep-alive') {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthrow new Error(`Invalid 'connection' header: ${value}`);\n\t\t}\n\n\t\tif (lowercased === 'host' && this.method === 'CONNECT') {\n\t\t\tthis[kHeaders][HTTP2_HEADER_AUTHORITY] = value;\n\t\t} else {\n\t\t\tthis[kHeaders][lowercased] = value;\n\t\t}\n\t}\n\n\tsetNoDelay() {\n\t\t// HTTP2 sockets cannot be malformed, do nothing.\n\t}\n\n\tsetSocketKeepAlive() {\n\t\t// HTTP2 sockets cannot be malformed, do nothing.\n\t}\n\n\tsetTimeout(ms, callback) {\n\t\tconst applyTimeout = () => this._request.setTimeout(ms, callback);\n\n\t\tif (this._request) {\n\t\t\tapplyTimeout();\n\t\t} else {\n\t\t\tthis[kJobs].push(applyTimeout);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tget maxHeadersCount() {\n\t\tif (!this.destroyed && this._request) {\n\t\t\treturn this._request.session.localSettings.maxHeaderListSize;\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tset maxHeadersCount(_value) {\n\t\t// Updating HTTP2 settings would affect all requests, do nothing.\n\t}\n}\n\nmodule.exports = ClientRequest;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}