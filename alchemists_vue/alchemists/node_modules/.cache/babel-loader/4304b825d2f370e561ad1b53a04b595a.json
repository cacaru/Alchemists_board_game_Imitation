{"ast":null,"code":"'use strict'; // See https://github.com/facebook/jest/issues/2549\n// eslint-disable-next-line node/prefer-global/url\n\nrequire(\"core-js/modules/es.array.includes.js\");\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nconst {\n  URL\n} = require('url');\n\nconst EventEmitter = require('events');\n\nconst tls = require('tls');\n\nconst http2 = require('http2');\n\nconst QuickLRU = require('quick-lru');\n\nconst delayAsyncDestroy = require('./utils/delay-async-destroy.js');\n\nconst kCurrentStreamCount = Symbol('currentStreamCount');\nconst kRequest = Symbol('request');\nconst kOriginSet = Symbol('cachedOriginSet');\nconst kGracefullyClosing = Symbol('gracefullyClosing');\nconst kLength = Symbol('length');\nconst nameKeys = [// Not an Agent option actually\n'createConnection', // `http2.connect()` options\n'maxDeflateDynamicTableSize', 'maxSettings', 'maxSessionMemory', 'maxHeaderListPairs', 'maxOutstandingPings', 'maxReservedRemoteStreams', 'maxSendHeaderBlockLength', 'paddingStrategy', 'peerMaxConcurrentStreams', 'settings', // `tls.connect()` source options\n'family', 'localAddress', 'rejectUnauthorized', // `tls.connect()` secure context options\n'pskCallback', 'minDHSize', // `tls.connect()` destination options\n// - `servername` is automatically validated, skip it\n// - `host` and `port` just describe the destination server,\n'path', 'socket', // `tls.createSecureContext()` options\n'ca', 'cert', 'sigalgs', 'ciphers', 'clientCertEngine', 'crl', 'dhparam', 'ecdhCurve', 'honorCipherOrder', 'key', 'privateKeyEngine', 'privateKeyIdentifier', 'maxVersion', 'minVersion', 'pfx', 'secureOptions', 'secureProtocol', 'sessionIdContext', 'ticketKeys'];\n\nconst getSortedIndex = (array, value, compare) => {\n  let low = 0;\n  let high = array.length;\n\n  while (low < high) {\n    const mid = low + high >>> 1;\n\n    if (compare(array[mid], value)) {\n      low = mid + 1;\n    } else {\n      high = mid;\n    }\n  }\n\n  return low;\n};\n\nconst compareSessions = (a, b) => a.remoteSettings.maxConcurrentStreams > b.remoteSettings.maxConcurrentStreams; // See https://tools.ietf.org/html/rfc8336\n\n\nconst closeCoveredSessions = (where, session) => {\n  // Clients SHOULD NOT emit new requests on any connection whose Origin\n  // Set is a proper subset of another connection's Origin Set, and they\n  // SHOULD close it once all outstanding requests are satisfied.\n  for (let index = 0; index < where.length; index++) {\n    const coveredSession = where[index];\n\n    if ( // Unfortunately `.every()` returns true for an empty array\n    coveredSession[kOriginSet].length > 0 // The set is a proper subset when its length is less than the other set.\n    && coveredSession[kOriginSet].length < session[kOriginSet].length // And the other set includes all elements of the subset.\n    && coveredSession[kOriginSet].every(origin => session[kOriginSet].includes(origin)) // Makes sure that the session can handle all requests from the covered session.\n    && coveredSession[kCurrentStreamCount] + session[kCurrentStreamCount] <= session.remoteSettings.maxConcurrentStreams) {\n      // This allows pending requests to finish and prevents making new requests.\n      gracefullyClose(coveredSession);\n    }\n  }\n}; // This is basically inverted `closeCoveredSessions(...)`.\n\n\nconst closeSessionIfCovered = (where, coveredSession) => {\n  for (let index = 0; index < where.length; index++) {\n    const session = where[index];\n\n    if (coveredSession[kOriginSet].length > 0 && coveredSession[kOriginSet].length < session[kOriginSet].length && coveredSession[kOriginSet].every(origin => session[kOriginSet].includes(origin)) && coveredSession[kCurrentStreamCount] + session[kCurrentStreamCount] <= session.remoteSettings.maxConcurrentStreams) {\n      gracefullyClose(coveredSession);\n      return true;\n    }\n  }\n\n  return false;\n};\n\nconst gracefullyClose = session => {\n  session[kGracefullyClosing] = true;\n\n  if (session[kCurrentStreamCount] === 0) {\n    session.close();\n  }\n};\n\nclass Agent extends EventEmitter {\n  constructor({\n    timeout = 0,\n    maxSessions = Number.POSITIVE_INFINITY,\n    maxEmptySessions = 10,\n    maxCachedTlsSessions = 100\n  } = {}) {\n    super(); // SESSIONS[NORMALIZED_OPTIONS] = [];\n\n    this.sessions = {}; // The queue for creating new sessions. It looks like this:\n    // QUEUE[NORMALIZED_OPTIONS][NORMALIZED_ORIGIN] = ENTRY_FUNCTION\n    //\n    // It's faster when there are many origins. If there's only one, then QUEUE[`${options}:${origin}`] is faster.\n    // I guess object creation / deletion is causing the slowdown.\n    //\n    // The entry function has `listeners`, `completed` and `destroyed` properties.\n    // `listeners` is an array of objects containing `resolve` and `reject` functions.\n    // `completed` is a boolean. It's set to true after ENTRY_FUNCTION is executed.\n    // `destroyed` is a boolean. If it's set to true, the session will be destroyed if hasn't connected yet.\n\n    this.queue = {}; // Each session will use this timeout value.\n\n    this.timeout = timeout; // Max sessions in total\n\n    this.maxSessions = maxSessions; // Max empty sessions in total\n\n    this.maxEmptySessions = maxEmptySessions;\n    this._emptySessionCount = 0;\n    this._sessionCount = 0; // We don't support push streams by default.\n\n    this.settings = {\n      enablePush: false,\n      initialWindowSize: 1024 * 1024 * 32 // 32MB, see https://github.com/nodejs/node/issues/38426\n\n    }; // Reusing TLS sessions increases performance.\n\n    this.tlsSessionCache = new QuickLRU({\n      maxSize: maxCachedTlsSessions\n    });\n  }\n\n  get protocol() {\n    return 'https:';\n  }\n\n  normalizeOptions(options) {\n    let normalized = '';\n\n    for (let index = 0; index < nameKeys.length; index++) {\n      const key = nameKeys[index];\n      normalized += ':';\n\n      if (options && options[key] !== undefined) {\n        normalized += options[key];\n      }\n    }\n\n    return normalized;\n  }\n\n  _processQueue() {\n    if (this._sessionCount >= this.maxSessions) {\n      this.closeEmptySessions(this.maxSessions - this._sessionCount + 1);\n      return;\n    } // eslint-disable-next-line guard-for-in\n\n\n    for (const normalizedOptions in this.queue) {\n      // eslint-disable-next-line guard-for-in\n      for (const normalizedOrigin in this.queue[normalizedOptions]) {\n        const item = this.queue[normalizedOptions][normalizedOrigin]; // The entry function can be run only once.\n\n        if (!item.completed) {\n          item.completed = true;\n          item();\n        }\n      }\n    }\n  }\n\n  _isBetterSession(thisStreamCount, thatStreamCount) {\n    return thisStreamCount > thatStreamCount;\n  }\n\n  _accept(session, listeners, normalizedOrigin, options) {\n    let index = 0;\n\n    while (index < listeners.length && session[kCurrentStreamCount] < session.remoteSettings.maxConcurrentStreams) {\n      // We assume `resolve(...)` calls `request(...)` *directly*,\n      // otherwise the session will get overloaded.\n      listeners[index].resolve(session);\n      index++;\n    }\n\n    listeners.splice(0, index);\n\n    if (listeners.length > 0) {\n      this.getSession(normalizedOrigin, options, listeners);\n      listeners.length = 0;\n    }\n  }\n\n  getSession(origin, options, listeners) {\n    return new Promise((resolve, reject) => {\n      if (Array.isArray(listeners) && listeners.length > 0) {\n        listeners = [...listeners]; // Resolve the current promise ASAP, we're just moving the listeners.\n        // They will be executed at a different time.\n\n        resolve();\n      } else {\n        listeners = [{\n          resolve,\n          reject\n        }];\n      }\n\n      try {\n        // Parse origin\n        if (typeof origin === 'string') {\n          origin = new URL(origin);\n        } else if (!(origin instanceof URL)) {\n          throw new TypeError('The `origin` argument needs to be a string or an URL object');\n        }\n\n        if (options) {\n          // Validate servername\n          const {\n            servername\n          } = options;\n          const {\n            hostname\n          } = origin;\n\n          if (servername && hostname !== servername) {\n            throw new Error(`Origin ${hostname} differs from servername ${servername}`);\n          }\n        }\n      } catch (error) {\n        for (let index = 0; index < listeners.length; index++) {\n          listeners[index].reject(error);\n        }\n\n        return;\n      }\n\n      const normalizedOptions = this.normalizeOptions(options);\n      const normalizedOrigin = origin.origin;\n\n      if (normalizedOptions in this.sessions) {\n        const sessions = this.sessions[normalizedOptions];\n        let maxConcurrentStreams = -1;\n        let currentStreamsCount = -1;\n        let optimalSession; // We could just do this.sessions[normalizedOptions].find(...) but that isn't optimal.\n        // Additionally, we are looking for session which has biggest current pending streams count.\n        //\n        // |------------| |------------| |------------| |------------|\n        // | Session: A | | Session: B | | Session: C | | Session: D |\n        // | Pending: 5 |-| Pending: 8 |-| Pending: 9 |-| Pending: 4 |\n        // | Max:    10 | | Max:    10 | | Max:     9 | | Max:     5 |\n        // |------------| |------------| |------------| |------------|\n        //                     ^\n        //                     |\n        //     pick this one  --\n        //\n\n        for (let index = 0; index < sessions.length; index++) {\n          const session = sessions[index];\n          const sessionMaxConcurrentStreams = session.remoteSettings.maxConcurrentStreams;\n\n          if (sessionMaxConcurrentStreams < maxConcurrentStreams) {\n            break;\n          }\n\n          if (!session[kOriginSet].includes(normalizedOrigin)) {\n            continue;\n          }\n\n          const sessionCurrentStreamsCount = session[kCurrentStreamCount];\n\n          if (sessionCurrentStreamsCount >= sessionMaxConcurrentStreams || session[kGracefullyClosing] // Unfortunately the `close` event isn't called immediately,\n          // so `session.destroyed` is `true`, but `session.closed` is `false`.\n          || session.destroyed) {\n            continue;\n          } // We only need set this once.\n\n\n          if (!optimalSession) {\n            maxConcurrentStreams = sessionMaxConcurrentStreams;\n          } // Either get the session which has biggest current stream count or the lowest.\n\n\n          if (this._isBetterSession(sessionCurrentStreamsCount, currentStreamsCount)) {\n            optimalSession = session;\n            currentStreamsCount = sessionCurrentStreamsCount;\n          }\n        }\n\n        if (optimalSession) {\n          this._accept(optimalSession, listeners, normalizedOrigin, options);\n\n          return;\n        }\n      }\n\n      if (normalizedOptions in this.queue) {\n        if (normalizedOrigin in this.queue[normalizedOptions]) {\n          // There's already an item in the queue, just attach ourselves to it.\n          this.queue[normalizedOptions][normalizedOrigin].listeners.push(...listeners);\n          return;\n        }\n      } else {\n        this.queue[normalizedOptions] = {\n          [kLength]: 0\n        };\n      } // The entry must be removed from the queue IMMEDIATELY when:\n      // 1. the session connects successfully,\n      // 2. an error occurs.\n\n\n      const removeFromQueue = () => {\n        // Our entry can be replaced. We cannot remove the new one.\n        if (normalizedOptions in this.queue && this.queue[normalizedOptions][normalizedOrigin] === entry) {\n          delete this.queue[normalizedOptions][normalizedOrigin];\n\n          if (--this.queue[normalizedOptions][kLength] === 0) {\n            delete this.queue[normalizedOptions];\n          }\n        }\n      }; // The main logic is here\n\n\n      const entry = async () => {\n        this._sessionCount++;\n        const name = `${normalizedOrigin}:${normalizedOptions}`;\n        let receivedSettings = false;\n        let socket;\n\n        try {\n          const computedOptions = { ...options\n          };\n\n          if (computedOptions.settings === undefined) {\n            computedOptions.settings = this.settings;\n          }\n\n          if (computedOptions.session === undefined) {\n            computedOptions.session = this.tlsSessionCache.get(name);\n          }\n\n          const createConnection = computedOptions.createConnection || this.createConnection; // A hacky workaround to enable async `createConnection`\n\n          socket = await createConnection.call(this, origin, computedOptions);\n\n          computedOptions.createConnection = () => socket;\n\n          const session = http2.connect(origin, computedOptions);\n          session[kCurrentStreamCount] = 0;\n          session[kGracefullyClosing] = false; // Node.js return https://false:443 instead of https://1.1.1.1:443\n\n          const getOriginSet = () => {\n            const {\n              socket\n            } = session;\n            let originSet;\n\n            if (socket.servername === false) {\n              socket.servername = socket.remoteAddress;\n              originSet = session.originSet;\n              socket.servername = false;\n            } else {\n              originSet = session.originSet;\n            }\n\n            return originSet;\n          };\n\n          const isFree = () => session[kCurrentStreamCount] < session.remoteSettings.maxConcurrentStreams;\n\n          session.socket.once('session', tlsSession => {\n            this.tlsSessionCache.set(name, tlsSession);\n          });\n          session.once('error', error => {\n            // Listeners are empty when the session successfully connected.\n            for (let index = 0; index < listeners.length; index++) {\n              listeners[index].reject(error);\n            } // The connection got broken, purge the cache.\n\n\n            this.tlsSessionCache.delete(name);\n          });\n          session.setTimeout(this.timeout, () => {\n            // Terminates all streams owned by this session.\n            session.destroy();\n          });\n          session.once('close', () => {\n            this._sessionCount--;\n\n            if (receivedSettings) {\n              // Assumes session `close` is emitted after request `close`\n              this._emptySessionCount--; // This cannot be moved to the stream logic,\n              // because there may be a session that hadn't made a single request.\n\n              const where = this.sessions[normalizedOptions];\n\n              if (where.length === 1) {\n                delete this.sessions[normalizedOptions];\n              } else {\n                where.splice(where.indexOf(session), 1);\n              }\n            } else {\n              // Broken connection\n              removeFromQueue();\n              const error = new Error('Session closed without receiving a SETTINGS frame');\n              error.code = 'HTTP2WRAPPER_NOSETTINGS';\n\n              for (let index = 0; index < listeners.length; index++) {\n                listeners[index].reject(error);\n              }\n            } // There may be another session awaiting.\n\n\n            this._processQueue();\n          }); // Iterates over the queue and processes listeners.\n\n          const processListeners = () => {\n            const queue = this.queue[normalizedOptions];\n\n            if (!queue) {\n              return;\n            }\n\n            const originSet = session[kOriginSet];\n\n            for (let index = 0; index < originSet.length; index++) {\n              const origin = originSet[index];\n\n              if (origin in queue) {\n                const {\n                  listeners,\n                  completed\n                } = queue[origin];\n                let index = 0; // Prevents session overloading.\n\n                while (index < listeners.length && isFree()) {\n                  // We assume `resolve(...)` calls `request(...)` *directly*,\n                  // otherwise the session will get overloaded.\n                  listeners[index].resolve(session);\n                  index++;\n                }\n\n                queue[origin].listeners.splice(0, index);\n\n                if (queue[origin].listeners.length === 0 && !completed) {\n                  delete queue[origin];\n\n                  if (--queue[kLength] === 0) {\n                    delete this.queue[normalizedOptions];\n                    break;\n                  }\n                } // We're no longer free, no point in continuing.\n\n\n                if (!isFree()) {\n                  break;\n                }\n              }\n            }\n          }; // The Origin Set cannot shrink. No need to check if it suddenly became covered by another one.\n\n\n          session.on('origin', () => {\n            session[kOriginSet] = getOriginSet() || [];\n            session[kGracefullyClosing] = false;\n            closeSessionIfCovered(this.sessions[normalizedOptions], session);\n\n            if (session[kGracefullyClosing] || !isFree()) {\n              return;\n            }\n\n            processListeners();\n\n            if (!isFree()) {\n              return;\n            } // Close covered sessions (if possible).\n\n\n            closeCoveredSessions(this.sessions[normalizedOptions], session);\n          });\n          session.once('remoteSettings', () => {\n            // The Agent could have been destroyed already.\n            if (entry.destroyed) {\n              const error = new Error('Agent has been destroyed');\n\n              for (let index = 0; index < listeners.length; index++) {\n                listeners[index].reject(error);\n              }\n\n              session.destroy();\n              return;\n            } // See https://github.com/nodejs/node/issues/38426\n\n\n            if (session.setLocalWindowSize) {\n              session.setLocalWindowSize(1024 * 1024 * 4); // 4 MB\n            }\n\n            session[kOriginSet] = getOriginSet() || [];\n\n            if (session.socket.encrypted) {\n              const mainOrigin = session[kOriginSet][0];\n\n              if (mainOrigin !== normalizedOrigin) {\n                const error = new Error(`Requested origin ${normalizedOrigin} does not match server ${mainOrigin}`);\n\n                for (let index = 0; index < listeners.length; index++) {\n                  listeners[index].reject(error);\n                }\n\n                session.destroy();\n                return;\n              }\n            }\n\n            removeFromQueue();\n            {\n              const where = this.sessions;\n\n              if (normalizedOptions in where) {\n                const sessions = where[normalizedOptions];\n                sessions.splice(getSortedIndex(sessions, session, compareSessions), 0, session);\n              } else {\n                where[normalizedOptions] = [session];\n              }\n            }\n            receivedSettings = true;\n            this._emptySessionCount++;\n            this.emit('session', session);\n\n            this._accept(session, listeners, normalizedOrigin, options);\n\n            if (session[kCurrentStreamCount] === 0 && this._emptySessionCount > this.maxEmptySessions) {\n              this.closeEmptySessions(this._emptySessionCount - this.maxEmptySessions);\n            } // `session.remoteSettings.maxConcurrentStreams` might get increased\n\n\n            session.on('remoteSettings', () => {\n              if (!isFree()) {\n                return;\n              }\n\n              processListeners();\n\n              if (!isFree()) {\n                return;\n              } // In case the Origin Set changes\n\n\n              closeCoveredSessions(this.sessions[normalizedOptions], session);\n            });\n          }); // Shim `session.request()` in order to catch all streams\n\n          session[kRequest] = session.request;\n\n          session.request = (headers, streamOptions) => {\n            if (session[kGracefullyClosing]) {\n              throw new Error('The session is gracefully closing. No new streams are allowed.');\n            }\n\n            const stream = session[kRequest](headers, streamOptions); // The process won't exit until the session is closed or all requests are gone.\n\n            session.ref();\n\n            if (session[kCurrentStreamCount]++ === 0) {\n              this._emptySessionCount--;\n            }\n\n            stream.once('close', () => {\n              if (--session[kCurrentStreamCount] === 0) {\n                this._emptySessionCount++;\n                session.unref();\n\n                if (this._emptySessionCount > this.maxEmptySessions || session[kGracefullyClosing]) {\n                  session.close();\n                  return;\n                }\n              }\n\n              if (session.destroyed || session.closed) {\n                return;\n              }\n\n              if (isFree() && !closeSessionIfCovered(this.sessions[normalizedOptions], session)) {\n                closeCoveredSessions(this.sessions[normalizedOptions], session);\n                processListeners();\n\n                if (session[kCurrentStreamCount] === 0) {\n                  this._processQueue();\n                }\n              }\n            });\n            return stream;\n          };\n        } catch (error) {\n          removeFromQueue();\n          this._sessionCount--;\n\n          for (let index = 0; index < listeners.length; index++) {\n            listeners[index].reject(error);\n          }\n        }\n      };\n\n      entry.listeners = listeners;\n      entry.completed = false;\n      entry.destroyed = false;\n      this.queue[normalizedOptions][normalizedOrigin] = entry;\n      this.queue[normalizedOptions][kLength]++;\n\n      this._processQueue();\n    });\n  }\n\n  request(origin, options, headers, streamOptions) {\n    return new Promise((resolve, reject) => {\n      this.getSession(origin, options, [{\n        reject,\n        resolve: session => {\n          try {\n            const stream = session.request(headers, streamOptions); // Do not throw before `request(...)` has been awaited\n\n            delayAsyncDestroy(stream);\n            resolve(stream);\n          } catch (error) {\n            reject(error);\n          }\n        }\n      }]);\n    });\n  }\n\n  async createConnection(origin, options) {\n    return Agent.connect(origin, options);\n  }\n\n  static connect(origin, options) {\n    options.ALPNProtocols = ['h2'];\n    const port = origin.port || 443;\n    const host = origin.hostname;\n\n    if (typeof options.servername === 'undefined') {\n      options.servername = host;\n    }\n\n    const socket = tls.connect(port, host, options);\n\n    if (options.socket) {\n      socket._peername = {\n        family: undefined,\n        address: undefined,\n        port\n      };\n    }\n\n    return socket;\n  }\n\n  closeEmptySessions(maxCount = Number.POSITIVE_INFINITY) {\n    let closedCount = 0;\n    const {\n      sessions\n    } = this; // eslint-disable-next-line guard-for-in\n\n    for (const key in sessions) {\n      const thisSessions = sessions[key];\n\n      for (let index = 0; index < thisSessions.length; index++) {\n        const session = thisSessions[index];\n\n        if (session[kCurrentStreamCount] === 0) {\n          closedCount++;\n          session.close();\n\n          if (closedCount >= maxCount) {\n            return closedCount;\n          }\n        }\n      }\n    }\n\n    return closedCount;\n  }\n\n  destroy(reason) {\n    const {\n      sessions,\n      queue\n    } = this; // eslint-disable-next-line guard-for-in\n\n    for (const key in sessions) {\n      const thisSessions = sessions[key];\n\n      for (let index = 0; index < thisSessions.length; index++) {\n        thisSessions[index].destroy(reason);\n      }\n    } // eslint-disable-next-line guard-for-in\n\n\n    for (const normalizedOptions in queue) {\n      const entries = queue[normalizedOptions]; // eslint-disable-next-line guard-for-in\n\n      for (const normalizedOrigin in entries) {\n        entries[normalizedOrigin].destroyed = true;\n      }\n    } // New requests should NOT attach to destroyed sessions\n\n\n    this.queue = {};\n    this.tlsSessionCache.clear();\n  }\n\n  get emptySessionCount() {\n    return this._emptySessionCount;\n  }\n\n  get pendingSessionCount() {\n    return this._sessionCount - this._emptySessionCount;\n  }\n\n  get sessionCount() {\n    return this._sessionCount;\n  }\n\n}\n\nAgent.kCurrentStreamCount = kCurrentStreamCount;\nAgent.kGracefullyClosing = kGracefullyClosing;\nmodule.exports = {\n  Agent,\n  globalAgent: new Agent()\n};","map":{"version":3,"names":["URL","require","EventEmitter","tls","http2","QuickLRU","delayAsyncDestroy","kCurrentStreamCount","Symbol","kRequest","kOriginSet","kGracefullyClosing","kLength","nameKeys","getSortedIndex","array","value","compare","low","high","length","mid","compareSessions","a","b","remoteSettings","maxConcurrentStreams","closeCoveredSessions","where","session","index","coveredSession","every","origin","includes","gracefullyClose","closeSessionIfCovered","close","Agent","constructor","timeout","maxSessions","Number","POSITIVE_INFINITY","maxEmptySessions","maxCachedTlsSessions","sessions","queue","_emptySessionCount","_sessionCount","settings","enablePush","initialWindowSize","tlsSessionCache","maxSize","protocol","normalizeOptions","options","normalized","key","undefined","_processQueue","closeEmptySessions","normalizedOptions","normalizedOrigin","item","completed","_isBetterSession","thisStreamCount","thatStreamCount","_accept","listeners","resolve","splice","getSession","Promise","reject","Array","isArray","TypeError","servername","hostname","Error","error","currentStreamsCount","optimalSession","sessionMaxConcurrentStreams","sessionCurrentStreamsCount","destroyed","push","removeFromQueue","entry","name","receivedSettings","socket","computedOptions","get","createConnection","call","connect","getOriginSet","originSet","remoteAddress","isFree","once","tlsSession","set","delete","setTimeout","destroy","indexOf","code","processListeners","on","setLocalWindowSize","encrypted","mainOrigin","emit","request","headers","streamOptions","stream","ref","unref","closed","ALPNProtocols","port","host","_peername","family","address","maxCount","closedCount","thisSessions","reason","entries","clear","emptySessionCount","pendingSessionCount","sessionCount","module","exports","globalAgent"],"sources":["E:/web/alchemists_vue/alchemists/node_modules/http2-wrapper/source/agent.js"],"sourcesContent":["'use strict';\n// See https://github.com/facebook/jest/issues/2549\n// eslint-disable-next-line node/prefer-global/url\nconst {URL} = require('url');\nconst EventEmitter = require('events');\nconst tls = require('tls');\nconst http2 = require('http2');\nconst QuickLRU = require('quick-lru');\nconst delayAsyncDestroy = require('./utils/delay-async-destroy.js');\n\nconst kCurrentStreamCount = Symbol('currentStreamCount');\nconst kRequest = Symbol('request');\nconst kOriginSet = Symbol('cachedOriginSet');\nconst kGracefullyClosing = Symbol('gracefullyClosing');\nconst kLength = Symbol('length');\n\nconst nameKeys = [\n\t// Not an Agent option actually\n\t'createConnection',\n\n\t// `http2.connect()` options\n\t'maxDeflateDynamicTableSize',\n\t'maxSettings',\n\t'maxSessionMemory',\n\t'maxHeaderListPairs',\n\t'maxOutstandingPings',\n\t'maxReservedRemoteStreams',\n\t'maxSendHeaderBlockLength',\n\t'paddingStrategy',\n\t'peerMaxConcurrentStreams',\n\t'settings',\n\n\t// `tls.connect()` source options\n\t'family',\n\t'localAddress',\n\t'rejectUnauthorized',\n\n\t// `tls.connect()` secure context options\n\t'pskCallback',\n\t'minDHSize',\n\n\t// `tls.connect()` destination options\n\t// - `servername` is automatically validated, skip it\n\t// - `host` and `port` just describe the destination server,\n\t'path',\n\t'socket',\n\n\t// `tls.createSecureContext()` options\n\t'ca',\n\t'cert',\n\t'sigalgs',\n\t'ciphers',\n\t'clientCertEngine',\n\t'crl',\n\t'dhparam',\n\t'ecdhCurve',\n\t'honorCipherOrder',\n\t'key',\n\t'privateKeyEngine',\n\t'privateKeyIdentifier',\n\t'maxVersion',\n\t'minVersion',\n\t'pfx',\n\t'secureOptions',\n\t'secureProtocol',\n\t'sessionIdContext',\n\t'ticketKeys'\n];\n\nconst getSortedIndex = (array, value, compare) => {\n\tlet low = 0;\n\tlet high = array.length;\n\n\twhile (low < high) {\n\t\tconst mid = (low + high) >>> 1;\n\n\t\tif (compare(array[mid], value)) {\n\t\t\tlow = mid + 1;\n\t\t} else {\n\t\t\thigh = mid;\n\t\t}\n\t}\n\n\treturn low;\n};\n\nconst compareSessions = (a, b) => a.remoteSettings.maxConcurrentStreams > b.remoteSettings.maxConcurrentStreams;\n\n// See https://tools.ietf.org/html/rfc8336\nconst closeCoveredSessions = (where, session) => {\n\t// Clients SHOULD NOT emit new requests on any connection whose Origin\n\t// Set is a proper subset of another connection's Origin Set, and they\n\t// SHOULD close it once all outstanding requests are satisfied.\n\tfor (let index = 0; index < where.length; index++) {\n\t\tconst coveredSession = where[index];\n\n\t\tif (\n\t\t\t// Unfortunately `.every()` returns true for an empty array\n\t\t\tcoveredSession[kOriginSet].length > 0\n\n\t\t\t// The set is a proper subset when its length is less than the other set.\n\t\t\t&& coveredSession[kOriginSet].length < session[kOriginSet].length\n\n\t\t\t// And the other set includes all elements of the subset.\n\t\t\t&& coveredSession[kOriginSet].every(origin => session[kOriginSet].includes(origin))\n\n\t\t\t// Makes sure that the session can handle all requests from the covered session.\n\t\t\t&& (coveredSession[kCurrentStreamCount] + session[kCurrentStreamCount]) <= session.remoteSettings.maxConcurrentStreams\n\t\t) {\n\t\t\t// This allows pending requests to finish and prevents making new requests.\n\t\t\tgracefullyClose(coveredSession);\n\t\t}\n\t}\n};\n\n// This is basically inverted `closeCoveredSessions(...)`.\nconst closeSessionIfCovered = (where, coveredSession) => {\n\tfor (let index = 0; index < where.length; index++) {\n\t\tconst session = where[index];\n\n\t\tif (\n\t\t\tcoveredSession[kOriginSet].length > 0\n\t\t\t&& coveredSession[kOriginSet].length < session[kOriginSet].length\n\t\t\t&& coveredSession[kOriginSet].every(origin => session[kOriginSet].includes(origin))\n\t\t\t&& (coveredSession[kCurrentStreamCount] + session[kCurrentStreamCount]) <= session.remoteSettings.maxConcurrentStreams\n\t\t) {\n\t\t\tgracefullyClose(coveredSession);\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n};\n\nconst gracefullyClose = session => {\n\tsession[kGracefullyClosing] = true;\n\n\tif (session[kCurrentStreamCount] === 0) {\n\t\tsession.close();\n\t}\n};\n\nclass Agent extends EventEmitter {\n\tconstructor({timeout = 0, maxSessions = Number.POSITIVE_INFINITY, maxEmptySessions = 10, maxCachedTlsSessions = 100} = {}) {\n\t\tsuper();\n\n\t\t// SESSIONS[NORMALIZED_OPTIONS] = [];\n\t\tthis.sessions = {};\n\n\t\t// The queue for creating new sessions. It looks like this:\n\t\t// QUEUE[NORMALIZED_OPTIONS][NORMALIZED_ORIGIN] = ENTRY_FUNCTION\n\t\t//\n\t\t// It's faster when there are many origins. If there's only one, then QUEUE[`${options}:${origin}`] is faster.\n\t\t// I guess object creation / deletion is causing the slowdown.\n\t\t//\n\t\t// The entry function has `listeners`, `completed` and `destroyed` properties.\n\t\t// `listeners` is an array of objects containing `resolve` and `reject` functions.\n\t\t// `completed` is a boolean. It's set to true after ENTRY_FUNCTION is executed.\n\t\t// `destroyed` is a boolean. If it's set to true, the session will be destroyed if hasn't connected yet.\n\t\tthis.queue = {};\n\n\t\t// Each session will use this timeout value.\n\t\tthis.timeout = timeout;\n\n\t\t// Max sessions in total\n\t\tthis.maxSessions = maxSessions;\n\n\t\t// Max empty sessions in total\n\t\tthis.maxEmptySessions = maxEmptySessions;\n\n\t\tthis._emptySessionCount = 0;\n\t\tthis._sessionCount = 0;\n\n\t\t// We don't support push streams by default.\n\t\tthis.settings = {\n\t\t\tenablePush: false,\n\t\t\tinitialWindowSize: 1024 * 1024 * 32 // 32MB, see https://github.com/nodejs/node/issues/38426\n\t\t};\n\n\t\t// Reusing TLS sessions increases performance.\n\t\tthis.tlsSessionCache = new QuickLRU({maxSize: maxCachedTlsSessions});\n\t}\n\n\tget protocol() {\n\t\treturn 'https:';\n\t}\n\n\tnormalizeOptions(options) {\n\t\tlet normalized = '';\n\n\t\tfor (let index = 0; index < nameKeys.length; index++) {\n\t\t\tconst key = nameKeys[index];\n\n\t\t\tnormalized += ':';\n\n\t\t\tif (options && options[key] !== undefined) {\n\t\t\t\tnormalized += options[key];\n\t\t\t}\n\t\t}\n\n\t\treturn normalized;\n\t}\n\n\t_processQueue() {\n\t\tif (this._sessionCount >= this.maxSessions) {\n\t\t\tthis.closeEmptySessions(this.maxSessions - this._sessionCount + 1);\n\t\t\treturn;\n\t\t}\n\n\t\t// eslint-disable-next-line guard-for-in\n\t\tfor (const normalizedOptions in this.queue) {\n\t\t\t// eslint-disable-next-line guard-for-in\n\t\t\tfor (const normalizedOrigin in this.queue[normalizedOptions]) {\n\t\t\t\tconst item = this.queue[normalizedOptions][normalizedOrigin];\n\n\t\t\t\t// The entry function can be run only once.\n\t\t\t\tif (!item.completed) {\n\t\t\t\t\titem.completed = true;\n\n\t\t\t\t\titem();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t_isBetterSession(thisStreamCount, thatStreamCount) {\n\t\treturn thisStreamCount > thatStreamCount;\n\t}\n\n\t_accept(session, listeners, normalizedOrigin, options) {\n\t\tlet index = 0;\n\n\t\twhile (index < listeners.length && session[kCurrentStreamCount] < session.remoteSettings.maxConcurrentStreams) {\n\t\t\t// We assume `resolve(...)` calls `request(...)` *directly*,\n\t\t\t// otherwise the session will get overloaded.\n\t\t\tlisteners[index].resolve(session);\n\n\t\t\tindex++;\n\t\t}\n\n\t\tlisteners.splice(0, index);\n\n\t\tif (listeners.length > 0) {\n\t\t\tthis.getSession(normalizedOrigin, options, listeners);\n\t\t\tlisteners.length = 0;\n\t\t}\n\t}\n\n\tgetSession(origin, options, listeners) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tif (Array.isArray(listeners) && listeners.length > 0) {\n\t\t\t\tlisteners = [...listeners];\n\n\t\t\t\t// Resolve the current promise ASAP, we're just moving the listeners.\n\t\t\t\t// They will be executed at a different time.\n\t\t\t\tresolve();\n\t\t\t} else {\n\t\t\t\tlisteners = [{resolve, reject}];\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\t// Parse origin\n\t\t\t\tif (typeof origin === 'string') {\n\t\t\t\t\torigin = new URL(origin);\n\t\t\t\t} else if (!(origin instanceof URL)) {\n\t\t\t\t\tthrow new TypeError('The `origin` argument needs to be a string or an URL object');\n\t\t\t\t}\n\n\t\t\t\tif (options) {\n\t\t\t\t\t// Validate servername\n\t\t\t\t\tconst {servername} = options;\n\t\t\t\t\tconst {hostname} = origin;\n\t\t\t\t\tif (servername && hostname !== servername) {\n\t\t\t\t\t\tthrow new Error(`Origin ${hostname} differs from servername ${servername}`);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tfor (let index = 0; index < listeners.length; index++) {\n\t\t\t\t\tlisteners[index].reject(error);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst normalizedOptions = this.normalizeOptions(options);\n\t\t\tconst normalizedOrigin = origin.origin;\n\n\t\t\tif (normalizedOptions in this.sessions) {\n\t\t\t\tconst sessions = this.sessions[normalizedOptions];\n\n\t\t\t\tlet maxConcurrentStreams = -1;\n\t\t\t\tlet currentStreamsCount = -1;\n\t\t\t\tlet optimalSession;\n\n\t\t\t\t// We could just do this.sessions[normalizedOptions].find(...) but that isn't optimal.\n\t\t\t\t// Additionally, we are looking for session which has biggest current pending streams count.\n\t\t\t\t//\n\t\t\t\t// |------------| |------------| |------------| |------------|\n\t\t\t\t// | Session: A | | Session: B | | Session: C | | Session: D |\n\t\t\t\t// | Pending: 5 |-| Pending: 8 |-| Pending: 9 |-| Pending: 4 |\n\t\t\t\t// | Max:    10 | | Max:    10 | | Max:     9 | | Max:     5 |\n\t\t\t\t// |------------| |------------| |------------| |------------|\n\t\t\t\t//                     ^\n\t\t\t\t//                     |\n\t\t\t\t//     pick this one  --\n\t\t\t\t//\n\t\t\t\tfor (let index = 0; index < sessions.length; index++) {\n\t\t\t\t\tconst session = sessions[index];\n\n\t\t\t\t\tconst sessionMaxConcurrentStreams = session.remoteSettings.maxConcurrentStreams;\n\n\t\t\t\t\tif (sessionMaxConcurrentStreams < maxConcurrentStreams) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!session[kOriginSet].includes(normalizedOrigin)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst sessionCurrentStreamsCount = session[kCurrentStreamCount];\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tsessionCurrentStreamsCount >= sessionMaxConcurrentStreams\n\t\t\t\t\t\t|| session[kGracefullyClosing]\n\t\t\t\t\t\t// Unfortunately the `close` event isn't called immediately,\n\t\t\t\t\t\t// so `session.destroyed` is `true`, but `session.closed` is `false`.\n\t\t\t\t\t\t|| session.destroyed\n\t\t\t\t\t) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// We only need set this once.\n\t\t\t\t\tif (!optimalSession) {\n\t\t\t\t\t\tmaxConcurrentStreams = sessionMaxConcurrentStreams;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Either get the session which has biggest current stream count or the lowest.\n\t\t\t\t\tif (this._isBetterSession(sessionCurrentStreamsCount, currentStreamsCount)) {\n\t\t\t\t\t\toptimalSession = session;\n\t\t\t\t\t\tcurrentStreamsCount = sessionCurrentStreamsCount;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (optimalSession) {\n\t\t\t\t\tthis._accept(optimalSession, listeners, normalizedOrigin, options);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (normalizedOptions in this.queue) {\n\t\t\t\tif (normalizedOrigin in this.queue[normalizedOptions]) {\n\t\t\t\t\t// There's already an item in the queue, just attach ourselves to it.\n\t\t\t\t\tthis.queue[normalizedOptions][normalizedOrigin].listeners.push(...listeners);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.queue[normalizedOptions] = {\n\t\t\t\t\t[kLength]: 0\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// The entry must be removed from the queue IMMEDIATELY when:\n\t\t\t// 1. the session connects successfully,\n\t\t\t// 2. an error occurs.\n\t\t\tconst removeFromQueue = () => {\n\t\t\t\t// Our entry can be replaced. We cannot remove the new one.\n\t\t\t\tif (normalizedOptions in this.queue && this.queue[normalizedOptions][normalizedOrigin] === entry) {\n\t\t\t\t\tdelete this.queue[normalizedOptions][normalizedOrigin];\n\n\t\t\t\t\tif (--this.queue[normalizedOptions][kLength] === 0) {\n\t\t\t\t\t\tdelete this.queue[normalizedOptions];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// The main logic is here\n\t\t\tconst entry = async () => {\n\t\t\t\tthis._sessionCount++;\n\n\t\t\t\tconst name = `${normalizedOrigin}:${normalizedOptions}`;\n\t\t\t\tlet receivedSettings = false;\n\t\t\t\tlet socket;\n\n\t\t\t\ttry {\n\t\t\t\t\tconst computedOptions = {...options};\n\n\t\t\t\t\tif (computedOptions.settings === undefined) {\n\t\t\t\t\t\tcomputedOptions.settings = this.settings;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (computedOptions.session === undefined) {\n\t\t\t\t\t\tcomputedOptions.session = this.tlsSessionCache.get(name);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst createConnection = computedOptions.createConnection || this.createConnection;\n\n\t\t\t\t\t// A hacky workaround to enable async `createConnection`\n\t\t\t\t\tsocket = await createConnection.call(this, origin, computedOptions);\n\t\t\t\t\tcomputedOptions.createConnection = () => socket;\n\n\t\t\t\t\tconst session = http2.connect(origin, computedOptions);\n\t\t\t\t\tsession[kCurrentStreamCount] = 0;\n\t\t\t\t\tsession[kGracefullyClosing] = false;\n\n\t\t\t\t\t// Node.js return https://false:443 instead of https://1.1.1.1:443\n\t\t\t\t\tconst getOriginSet = () => {\n\t\t\t\t\t\tconst {socket} = session;\n\n\t\t\t\t\t\tlet originSet;\n\t\t\t\t\t\tif (socket.servername === false) {\n\t\t\t\t\t\t\tsocket.servername = socket.remoteAddress;\n\t\t\t\t\t\t\toriginSet = session.originSet;\n\t\t\t\t\t\t\tsocket.servername = false;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\toriginSet = session.originSet;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn originSet;\n\t\t\t\t\t};\n\n\t\t\t\t\tconst isFree = () => session[kCurrentStreamCount] < session.remoteSettings.maxConcurrentStreams;\n\n\t\t\t\t\tsession.socket.once('session', tlsSession => {\n\t\t\t\t\t\tthis.tlsSessionCache.set(name, tlsSession);\n\t\t\t\t\t});\n\n\t\t\t\t\tsession.once('error', error => {\n\t\t\t\t\t\t// Listeners are empty when the session successfully connected.\n\t\t\t\t\t\tfor (let index = 0; index < listeners.length; index++) {\n\t\t\t\t\t\t\tlisteners[index].reject(error);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// The connection got broken, purge the cache.\n\t\t\t\t\t\tthis.tlsSessionCache.delete(name);\n\t\t\t\t\t});\n\n\t\t\t\t\tsession.setTimeout(this.timeout, () => {\n\t\t\t\t\t\t// Terminates all streams owned by this session.\n\t\t\t\t\t\tsession.destroy();\n\t\t\t\t\t});\n\n\t\t\t\t\tsession.once('close', () => {\n\t\t\t\t\t\tthis._sessionCount--;\n\n\t\t\t\t\t\tif (receivedSettings) {\n\t\t\t\t\t\t\t// Assumes session `close` is emitted after request `close`\n\t\t\t\t\t\t\tthis._emptySessionCount--;\n\n\t\t\t\t\t\t\t// This cannot be moved to the stream logic,\n\t\t\t\t\t\t\t// because there may be a session that hadn't made a single request.\n\t\t\t\t\t\t\tconst where = this.sessions[normalizedOptions];\n\n\t\t\t\t\t\t\tif (where.length === 1) {\n\t\t\t\t\t\t\t\tdelete this.sessions[normalizedOptions];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\twhere.splice(where.indexOf(session), 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Broken connection\n\t\t\t\t\t\t\tremoveFromQueue();\n\n\t\t\t\t\t\t\tconst error = new Error('Session closed without receiving a SETTINGS frame');\n\t\t\t\t\t\t\terror.code = 'HTTP2WRAPPER_NOSETTINGS';\n\n\t\t\t\t\t\t\tfor (let index = 0; index < listeners.length; index++) {\n\t\t\t\t\t\t\t\tlisteners[index].reject(error);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// There may be another session awaiting.\n\t\t\t\t\t\tthis._processQueue();\n\t\t\t\t\t});\n\n\t\t\t\t\t// Iterates over the queue and processes listeners.\n\t\t\t\t\tconst processListeners = () => {\n\t\t\t\t\t\tconst queue = this.queue[normalizedOptions];\n\t\t\t\t\t\tif (!queue) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst originSet = session[kOriginSet];\n\n\t\t\t\t\t\tfor (let index = 0; index < originSet.length; index++) {\n\t\t\t\t\t\t\tconst origin = originSet[index];\n\n\t\t\t\t\t\t\tif (origin in queue) {\n\t\t\t\t\t\t\t\tconst {listeners, completed} = queue[origin];\n\n\t\t\t\t\t\t\t\tlet index = 0;\n\n\t\t\t\t\t\t\t\t// Prevents session overloading.\n\t\t\t\t\t\t\t\twhile (index < listeners.length && isFree()) {\n\t\t\t\t\t\t\t\t\t// We assume `resolve(...)` calls `request(...)` *directly*,\n\t\t\t\t\t\t\t\t\t// otherwise the session will get overloaded.\n\t\t\t\t\t\t\t\t\tlisteners[index].resolve(session);\n\n\t\t\t\t\t\t\t\t\tindex++;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tqueue[origin].listeners.splice(0, index);\n\n\t\t\t\t\t\t\t\tif (queue[origin].listeners.length === 0 && !completed) {\n\t\t\t\t\t\t\t\t\tdelete queue[origin];\n\n\t\t\t\t\t\t\t\t\tif (--queue[kLength] === 0) {\n\t\t\t\t\t\t\t\t\t\tdelete this.queue[normalizedOptions];\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// We're no longer free, no point in continuing.\n\t\t\t\t\t\t\t\tif (!isFree()) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\t// The Origin Set cannot shrink. No need to check if it suddenly became covered by another one.\n\t\t\t\t\tsession.on('origin', () => {\n\t\t\t\t\t\tsession[kOriginSet] = getOriginSet() || [];\n\t\t\t\t\t\tsession[kGracefullyClosing] = false;\n\t\t\t\t\t\tcloseSessionIfCovered(this.sessions[normalizedOptions], session);\n\n\t\t\t\t\t\tif (session[kGracefullyClosing] || !isFree()) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tprocessListeners();\n\n\t\t\t\t\t\tif (!isFree()) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Close covered sessions (if possible).\n\t\t\t\t\t\tcloseCoveredSessions(this.sessions[normalizedOptions], session);\n\t\t\t\t\t});\n\n\t\t\t\t\tsession.once('remoteSettings', () => {\n\t\t\t\t\t\t// The Agent could have been destroyed already.\n\t\t\t\t\t\tif (entry.destroyed) {\n\t\t\t\t\t\t\tconst error = new Error('Agent has been destroyed');\n\n\t\t\t\t\t\t\tfor (let index = 0; index < listeners.length; index++) {\n\t\t\t\t\t\t\t\tlisteners[index].reject(error);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tsession.destroy();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// See https://github.com/nodejs/node/issues/38426\n\t\t\t\t\t\tif (session.setLocalWindowSize) {\n\t\t\t\t\t\t\tsession.setLocalWindowSize(1024 * 1024 * 4); // 4 MB\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tsession[kOriginSet] = getOriginSet() || [];\n\n\t\t\t\t\t\tif (session.socket.encrypted) {\n\t\t\t\t\t\t\tconst mainOrigin = session[kOriginSet][0];\n\t\t\t\t\t\t\tif (mainOrigin !== normalizedOrigin) {\n\t\t\t\t\t\t\t\tconst error = new Error(`Requested origin ${normalizedOrigin} does not match server ${mainOrigin}`);\n\n\t\t\t\t\t\t\t\tfor (let index = 0; index < listeners.length; index++) {\n\t\t\t\t\t\t\t\t\tlisteners[index].reject(error);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tsession.destroy();\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tremoveFromQueue();\n\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst where = this.sessions;\n\n\t\t\t\t\t\t\tif (normalizedOptions in where) {\n\t\t\t\t\t\t\t\tconst sessions = where[normalizedOptions];\n\t\t\t\t\t\t\t\tsessions.splice(getSortedIndex(sessions, session, compareSessions), 0, session);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\twhere[normalizedOptions] = [session];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treceivedSettings = true;\n\t\t\t\t\t\tthis._emptySessionCount++;\n\n\t\t\t\t\t\tthis.emit('session', session);\n\t\t\t\t\t\tthis._accept(session, listeners, normalizedOrigin, options);\n\n\t\t\t\t\t\tif (session[kCurrentStreamCount] === 0 && this._emptySessionCount > this.maxEmptySessions) {\n\t\t\t\t\t\t\tthis.closeEmptySessions(this._emptySessionCount - this.maxEmptySessions);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// `session.remoteSettings.maxConcurrentStreams` might get increased\n\t\t\t\t\t\tsession.on('remoteSettings', () => {\n\t\t\t\t\t\t\tif (!isFree()) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tprocessListeners();\n\n\t\t\t\t\t\t\tif (!isFree()) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// In case the Origin Set changes\n\t\t\t\t\t\t\tcloseCoveredSessions(this.sessions[normalizedOptions], session);\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\n\t\t\t\t\t// Shim `session.request()` in order to catch all streams\n\t\t\t\t\tsession[kRequest] = session.request;\n\t\t\t\t\tsession.request = (headers, streamOptions) => {\n\t\t\t\t\t\tif (session[kGracefullyClosing]) {\n\t\t\t\t\t\t\tthrow new Error('The session is gracefully closing. No new streams are allowed.');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst stream = session[kRequest](headers, streamOptions);\n\n\t\t\t\t\t\t// The process won't exit until the session is closed or all requests are gone.\n\t\t\t\t\t\tsession.ref();\n\n\t\t\t\t\t\tif (session[kCurrentStreamCount]++ === 0) {\n\t\t\t\t\t\t\tthis._emptySessionCount--;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstream.once('close', () => {\n\t\t\t\t\t\t\tif (--session[kCurrentStreamCount] === 0) {\n\t\t\t\t\t\t\t\tthis._emptySessionCount++;\n\t\t\t\t\t\t\t\tsession.unref();\n\n\t\t\t\t\t\t\t\tif (this._emptySessionCount > this.maxEmptySessions || session[kGracefullyClosing]) {\n\t\t\t\t\t\t\t\t\tsession.close();\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (session.destroyed || session.closed) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (isFree() && !closeSessionIfCovered(this.sessions[normalizedOptions], session)) {\n\t\t\t\t\t\t\t\tcloseCoveredSessions(this.sessions[normalizedOptions], session);\n\t\t\t\t\t\t\t\tprocessListeners();\n\n\t\t\t\t\t\t\t\tif (session[kCurrentStreamCount] === 0) {\n\t\t\t\t\t\t\t\t\tthis._processQueue();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturn stream;\n\t\t\t\t\t};\n\t\t\t\t} catch (error) {\n\t\t\t\t\tremoveFromQueue();\n\t\t\t\t\tthis._sessionCount--;\n\n\t\t\t\t\tfor (let index = 0; index < listeners.length; index++) {\n\t\t\t\t\t\tlisteners[index].reject(error);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tentry.listeners = listeners;\n\t\t\tentry.completed = false;\n\t\t\tentry.destroyed = false;\n\n\t\t\tthis.queue[normalizedOptions][normalizedOrigin] = entry;\n\t\t\tthis.queue[normalizedOptions][kLength]++;\n\t\t\tthis._processQueue();\n\t\t});\n\t}\n\n\trequest(origin, options, headers, streamOptions) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.getSession(origin, options, [{\n\t\t\t\treject,\n\t\t\t\tresolve: session => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst stream = session.request(headers, streamOptions);\n\n\t\t\t\t\t\t// Do not throw before `request(...)` has been awaited\n\t\t\t\t\t\tdelayAsyncDestroy(stream);\n\n\t\t\t\t\t\tresolve(stream);\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}]);\n\t\t});\n\t}\n\n\tasync createConnection(origin, options) {\n\t\treturn Agent.connect(origin, options);\n\t}\n\n\tstatic connect(origin, options) {\n\t\toptions.ALPNProtocols = ['h2'];\n\n\t\tconst port = origin.port || 443;\n\t\tconst host = origin.hostname;\n\n\t\tif (typeof options.servername === 'undefined') {\n\t\t\toptions.servername = host;\n\t\t}\n\n\t\tconst socket = tls.connect(port, host, options);\n\n\t\tif (options.socket) {\n\t\t\tsocket._peername = {\n\t\t\t\tfamily: undefined,\n\t\t\t\taddress: undefined,\n\t\t\t\tport\n\t\t\t};\n\t\t}\n\n\t\treturn socket;\n\t}\n\n\tcloseEmptySessions(maxCount = Number.POSITIVE_INFINITY) {\n\t\tlet closedCount = 0;\n\n\t\tconst {sessions} = this;\n\n\t\t// eslint-disable-next-line guard-for-in\n\t\tfor (const key in sessions) {\n\t\t\tconst thisSessions = sessions[key];\n\n\t\t\tfor (let index = 0; index < thisSessions.length; index++) {\n\t\t\t\tconst session = thisSessions[index];\n\n\t\t\t\tif (session[kCurrentStreamCount] === 0) {\n\t\t\t\t\tclosedCount++;\n\t\t\t\t\tsession.close();\n\n\t\t\t\t\tif (closedCount >= maxCount) {\n\t\t\t\t\t\treturn closedCount;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn closedCount;\n\t}\n\n\tdestroy(reason) {\n\t\tconst {sessions, queue} = this;\n\n\t\t// eslint-disable-next-line guard-for-in\n\t\tfor (const key in sessions) {\n\t\t\tconst thisSessions = sessions[key];\n\n\t\t\tfor (let index = 0; index < thisSessions.length; index++) {\n\t\t\t\tthisSessions[index].destroy(reason);\n\t\t\t}\n\t\t}\n\n\t\t// eslint-disable-next-line guard-for-in\n\t\tfor (const normalizedOptions in queue) {\n\t\t\tconst entries = queue[normalizedOptions];\n\n\t\t\t// eslint-disable-next-line guard-for-in\n\t\t\tfor (const normalizedOrigin in entries) {\n\t\t\t\tentries[normalizedOrigin].destroyed = true;\n\t\t\t}\n\t\t}\n\n\t\t// New requests should NOT attach to destroyed sessions\n\t\tthis.queue = {};\n\t\tthis.tlsSessionCache.clear();\n\t}\n\n\tget emptySessionCount() {\n\t\treturn this._emptySessionCount;\n\t}\n\n\tget pendingSessionCount() {\n\t\treturn this._sessionCount - this._emptySessionCount;\n\t}\n\n\tget sessionCount() {\n\t\treturn this._sessionCount;\n\t}\n}\n\nAgent.kCurrentStreamCount = kCurrentStreamCount;\nAgent.kGracefullyClosing = kGracefullyClosing;\n\nmodule.exports = {\n\tAgent,\n\tglobalAgent: new Agent()\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}