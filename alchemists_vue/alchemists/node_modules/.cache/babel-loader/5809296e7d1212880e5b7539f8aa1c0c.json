{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport net from 'node:net';\nimport unhandler from './utils/unhandle.js';\nconst reentry = Symbol('reentry');\n\nconst noop = () => {};\n\nexport class TimeoutError extends Error {\n  constructor(threshold, event) {\n    super(`Timeout awaiting '${event}' for ${threshold}ms`);\n    Object.defineProperty(this, \"event\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: event\n    });\n    Object.defineProperty(this, \"code\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.name = 'TimeoutError';\n    this.code = 'ETIMEDOUT';\n  }\n\n}\nexport default function timedOut(request, delays, options) {\n  if (reentry in request) {\n    return noop;\n  }\n\n  request[reentry] = true;\n  const cancelers = [];\n  const {\n    once,\n    unhandleAll\n  } = unhandler();\n\n  const addTimeout = (delay, callback, event) => {\n    const timeout = setTimeout(callback, delay, delay, event);\n    timeout.unref?.();\n\n    const cancel = () => {\n      clearTimeout(timeout);\n    };\n\n    cancelers.push(cancel);\n    return cancel;\n  };\n\n  const {\n    host,\n    hostname\n  } = options;\n\n  const timeoutHandler = (delay, event) => {\n    request.destroy(new TimeoutError(delay, event));\n  };\n\n  const cancelTimeouts = () => {\n    for (const cancel of cancelers) {\n      cancel();\n    }\n\n    unhandleAll();\n  };\n\n  request.once('error', error => {\n    cancelTimeouts(); // Save original behavior\n\n    /* istanbul ignore next */\n\n    if (request.listenerCount('error') === 0) {\n      throw error;\n    }\n  });\n\n  if (typeof delays.request !== 'undefined') {\n    const cancelTimeout = addTimeout(delays.request, timeoutHandler, 'request');\n    once(request, 'response', response => {\n      once(response, 'end', cancelTimeout);\n    });\n  }\n\n  if (typeof delays.socket !== 'undefined') {\n    const {\n      socket\n    } = delays;\n\n    const socketTimeoutHandler = () => {\n      timeoutHandler(socket, 'socket');\n    };\n\n    request.setTimeout(socket, socketTimeoutHandler); // `request.setTimeout(0)` causes a memory leak.\n    // We can just remove the listener and forget about the timer - it's unreffed.\n    // See https://github.com/sindresorhus/got/issues/690\n\n    cancelers.push(() => {\n      request.removeListener('timeout', socketTimeoutHandler);\n    });\n  }\n\n  const hasLookup = typeof delays.lookup !== 'undefined';\n  const hasConnect = typeof delays.connect !== 'undefined';\n  const hasSecureConnect = typeof delays.secureConnect !== 'undefined';\n  const hasSend = typeof delays.send !== 'undefined';\n\n  if (hasLookup || hasConnect || hasSecureConnect || hasSend) {\n    once(request, 'socket', socket => {\n      const {\n        socketPath\n      } = request;\n      /* istanbul ignore next: hard to test */\n\n      if (socket.connecting) {\n        const hasPath = Boolean(socketPath ?? net.isIP(hostname ?? host ?? '') !== 0);\n\n        if (hasLookup && !hasPath && typeof socket.address().address === 'undefined') {\n          const cancelTimeout = addTimeout(delays.lookup, timeoutHandler, 'lookup');\n          once(socket, 'lookup', cancelTimeout);\n        }\n\n        if (hasConnect) {\n          const timeConnect = () => addTimeout(delays.connect, timeoutHandler, 'connect');\n\n          if (hasPath) {\n            once(socket, 'connect', timeConnect());\n          } else {\n            once(socket, 'lookup', error => {\n              if (error === null) {\n                once(socket, 'connect', timeConnect());\n              }\n            });\n          }\n        }\n\n        if (hasSecureConnect && options.protocol === 'https:') {\n          once(socket, 'connect', () => {\n            const cancelTimeout = addTimeout(delays.secureConnect, timeoutHandler, 'secureConnect');\n            once(socket, 'secureConnect', cancelTimeout);\n          });\n        }\n      }\n\n      if (hasSend) {\n        const timeRequest = () => addTimeout(delays.send, timeoutHandler, 'send');\n        /* istanbul ignore next: hard to test */\n\n\n        if (socket.connecting) {\n          once(socket, 'connect', () => {\n            once(request, 'upload-complete', timeRequest());\n          });\n        } else {\n          once(request, 'upload-complete', timeRequest());\n        }\n      }\n    });\n  }\n\n  if (typeof delays.response !== 'undefined') {\n    once(request, 'upload-complete', () => {\n      const cancelTimeout = addTimeout(delays.response, timeoutHandler, 'response');\n      once(request, 'response', cancelTimeout);\n    });\n  }\n\n  if (typeof delays.read !== 'undefined') {\n    once(request, 'response', response => {\n      const cancelTimeout = addTimeout(delays.read, timeoutHandler, 'read');\n      once(response, 'end', cancelTimeout);\n    });\n  }\n\n  return cancelTimeouts;\n}","map":{"version":3,"names":["net","unhandler","reentry","Symbol","noop","TimeoutError","Error","constructor","threshold","event","Object","defineProperty","enumerable","configurable","writable","value","name","code","timedOut","request","delays","options","cancelers","once","unhandleAll","addTimeout","delay","callback","timeout","setTimeout","unref","cancel","clearTimeout","push","host","hostname","timeoutHandler","destroy","cancelTimeouts","error","listenerCount","cancelTimeout","response","socket","socketTimeoutHandler","removeListener","hasLookup","lookup","hasConnect","connect","hasSecureConnect","secureConnect","hasSend","send","socketPath","connecting","hasPath","Boolean","isIP","address","timeConnect","protocol","timeRequest","read"],"sources":["E:/web/alchemists_vue/alchemists/node_modules/got/dist/source/core/timed-out.js"],"sourcesContent":["import net from 'node:net';\nimport unhandler from './utils/unhandle.js';\nconst reentry = Symbol('reentry');\nconst noop = () => { };\nexport class TimeoutError extends Error {\n    constructor(threshold, event) {\n        super(`Timeout awaiting '${event}' for ${threshold}ms`);\n        Object.defineProperty(this, \"event\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: event\n        });\n        Object.defineProperty(this, \"code\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.name = 'TimeoutError';\n        this.code = 'ETIMEDOUT';\n    }\n}\nexport default function timedOut(request, delays, options) {\n    if (reentry in request) {\n        return noop;\n    }\n    request[reentry] = true;\n    const cancelers = [];\n    const { once, unhandleAll } = unhandler();\n    const addTimeout = (delay, callback, event) => {\n        const timeout = setTimeout(callback, delay, delay, event);\n        timeout.unref?.();\n        const cancel = () => {\n            clearTimeout(timeout);\n        };\n        cancelers.push(cancel);\n        return cancel;\n    };\n    const { host, hostname } = options;\n    const timeoutHandler = (delay, event) => {\n        request.destroy(new TimeoutError(delay, event));\n    };\n    const cancelTimeouts = () => {\n        for (const cancel of cancelers) {\n            cancel();\n        }\n        unhandleAll();\n    };\n    request.once('error', error => {\n        cancelTimeouts();\n        // Save original behavior\n        /* istanbul ignore next */\n        if (request.listenerCount('error') === 0) {\n            throw error;\n        }\n    });\n    if (typeof delays.request !== 'undefined') {\n        const cancelTimeout = addTimeout(delays.request, timeoutHandler, 'request');\n        once(request, 'response', (response) => {\n            once(response, 'end', cancelTimeout);\n        });\n    }\n    if (typeof delays.socket !== 'undefined') {\n        const { socket } = delays;\n        const socketTimeoutHandler = () => {\n            timeoutHandler(socket, 'socket');\n        };\n        request.setTimeout(socket, socketTimeoutHandler);\n        // `request.setTimeout(0)` causes a memory leak.\n        // We can just remove the listener and forget about the timer - it's unreffed.\n        // See https://github.com/sindresorhus/got/issues/690\n        cancelers.push(() => {\n            request.removeListener('timeout', socketTimeoutHandler);\n        });\n    }\n    const hasLookup = typeof delays.lookup !== 'undefined';\n    const hasConnect = typeof delays.connect !== 'undefined';\n    const hasSecureConnect = typeof delays.secureConnect !== 'undefined';\n    const hasSend = typeof delays.send !== 'undefined';\n    if (hasLookup || hasConnect || hasSecureConnect || hasSend) {\n        once(request, 'socket', (socket) => {\n            const { socketPath } = request;\n            /* istanbul ignore next: hard to test */\n            if (socket.connecting) {\n                const hasPath = Boolean(socketPath ?? net.isIP(hostname ?? host ?? '') !== 0);\n                if (hasLookup && !hasPath && typeof socket.address().address === 'undefined') {\n                    const cancelTimeout = addTimeout(delays.lookup, timeoutHandler, 'lookup');\n                    once(socket, 'lookup', cancelTimeout);\n                }\n                if (hasConnect) {\n                    const timeConnect = () => addTimeout(delays.connect, timeoutHandler, 'connect');\n                    if (hasPath) {\n                        once(socket, 'connect', timeConnect());\n                    }\n                    else {\n                        once(socket, 'lookup', (error) => {\n                            if (error === null) {\n                                once(socket, 'connect', timeConnect());\n                            }\n                        });\n                    }\n                }\n                if (hasSecureConnect && options.protocol === 'https:') {\n                    once(socket, 'connect', () => {\n                        const cancelTimeout = addTimeout(delays.secureConnect, timeoutHandler, 'secureConnect');\n                        once(socket, 'secureConnect', cancelTimeout);\n                    });\n                }\n            }\n            if (hasSend) {\n                const timeRequest = () => addTimeout(delays.send, timeoutHandler, 'send');\n                /* istanbul ignore next: hard to test */\n                if (socket.connecting) {\n                    once(socket, 'connect', () => {\n                        once(request, 'upload-complete', timeRequest());\n                    });\n                }\n                else {\n                    once(request, 'upload-complete', timeRequest());\n                }\n            }\n        });\n    }\n    if (typeof delays.response !== 'undefined') {\n        once(request, 'upload-complete', () => {\n            const cancelTimeout = addTimeout(delays.response, timeoutHandler, 'response');\n            once(request, 'response', cancelTimeout);\n        });\n    }\n    if (typeof delays.read !== 'undefined') {\n        once(request, 'response', (response) => {\n            const cancelTimeout = addTimeout(delays.read, timeoutHandler, 'read');\n            once(response, 'end', cancelTimeout);\n        });\n    }\n    return cancelTimeouts;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}