{"ast":null,"code":"const SocketIO = require('socket.io');\n\nmodule.exports = server => {\n  // 서버 연결, path는 프론트와 일치시켜준다.\n  const io = SocketIO(server, {\n    path: '/socket.io'\n  }); //* 웹소켓 연결 시\n\n  io.on('connection', socket => {\n    const req = socket.request; // 웹소켓과는 달리 req객체를 따로 뽑아야함\n    //* ip 정보 얻기\n\n    const ip = req.headers['x-forwarded-for'] || req.connection.remoteAddress;\n    console.log('새로운 클라이언트 접속!', ip, socket.id, req.ip); // socket.id 는 소켓 연결된 고유한 클라이언트 식별자라고 보면된다. 채팅방의 입장한 고유한 사람\n    //* 연결 종료 시\n\n    socket.on('disconnect', () => {\n      console.log('클라이언트 접속 해제', ip, socket.id);\n      clearInterval(socket.interval);\n    }); //* 에러 시\n\n    socket.on('error', error => {\n      console.error(error);\n    }); //* 클라이언트로부터 메시지\n\n    socket.on('reply', data => {\n      console.log(data);\n    }); //* 클라이언트로 메세지 보내기\n\n    socket.interval = setInterval(() => {\n      // 3초마다 클라이언트로 메시지 전송\n      socket.emit('news', 'Hello Socket.IO');\n    }, 3000);\n  });\n};","map":{"version":3,"names":["SocketIO","require","module","exports","server","io","path","on","socket","req","request","ip","headers","connection","remoteAddress","console","log","id","clearInterval","interval","error","data","setInterval","emit"],"sources":["E:/web/alchemists_vue/alchemists/src/assets/script/game_server.js"],"sourcesContent":["const SocketIO = require('socket.io');\r\n    module.exports = (server) => {\r\n        // 서버 연결, path는 프론트와 일치시켜준다.\r\n        const io = SocketIO(server, { path: '/socket.io' });\r\n        //* 웹소켓 연결 시\r\n        io.on('connection', (socket) => {\r\n            const req = socket.request; // 웹소켓과는 달리 req객체를 따로 뽑아야함\r\n            //* ip 정보 얻기\r\n            const ip = req.headers['x-forwarded-for'] || req.connection.remoteAddress;\r\n            console.log('새로운 클라이언트 접속!', ip, socket.id, req.ip);\r\n            // socket.id 는 소켓 연결된 고유한 클라이언트 식별자라고 보면된다. 채팅방의 입장한 고유한 사람\r\n            //* 연결 종료 시\r\n            socket.on('disconnect', () => {\r\n                console.log('클라이언트 접속 해제', ip, socket.id);\r\n                clearInterval(socket.interval);\r\n            });\r\n            //* 에러 시\r\n            socket.on('error', (error) => {\r\n                console.error(error);\r\n            });\r\n            //* 클라이언트로부터 메시지\r\n            socket.on('reply', (data) => {\r\n                console.log(data);\r\n            });\r\n            //* 클라이언트로 메세지 보내기\r\n            socket.interval = setInterval(() => {\r\n            // 3초마다 클라이언트로 메시지 전송\r\n                socket.emit('news', 'Hello Socket.IO');\r\n                }, 3000);\r\n        });\r\n};"],"mappings":"AAAA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,WAAD,CAAxB;;AACIC,MAAM,CAACC,OAAP,GAAkBC,MAAD,IAAY;EACzB;EACA,MAAMC,EAAE,GAAGL,QAAQ,CAACI,MAAD,EAAS;IAAEE,IAAI,EAAE;EAAR,CAAT,CAAnB,CAFyB,CAGzB;;EACAD,EAAE,CAACE,EAAH,CAAM,YAAN,EAAqBC,MAAD,IAAY;IAC5B,MAAMC,GAAG,GAAGD,MAAM,CAACE,OAAnB,CAD4B,CACA;IAC5B;;IACA,MAAMC,EAAE,GAAGF,GAAG,CAACG,OAAJ,CAAY,iBAAZ,KAAkCH,GAAG,CAACI,UAAJ,CAAeC,aAA5D;IACAC,OAAO,CAACC,GAAR,CAAY,eAAZ,EAA6BL,EAA7B,EAAiCH,MAAM,CAACS,EAAxC,EAA4CR,GAAG,CAACE,EAAhD,EAJ4B,CAK5B;IACA;;IACAH,MAAM,CAACD,EAAP,CAAU,YAAV,EAAwB,MAAM;MAC1BQ,OAAO,CAACC,GAAR,CAAY,aAAZ,EAA2BL,EAA3B,EAA+BH,MAAM,CAACS,EAAtC;MACAC,aAAa,CAACV,MAAM,CAACW,QAAR,CAAb;IACH,CAHD,EAP4B,CAW5B;;IACAX,MAAM,CAACD,EAAP,CAAU,OAAV,EAAoBa,KAAD,IAAW;MAC1BL,OAAO,CAACK,KAAR,CAAcA,KAAd;IACH,CAFD,EAZ4B,CAe5B;;IACAZ,MAAM,CAACD,EAAP,CAAU,OAAV,EAAoBc,IAAD,IAAU;MACzBN,OAAO,CAACC,GAAR,CAAYK,IAAZ;IACH,CAFD,EAhB4B,CAmB5B;;IACAb,MAAM,CAACW,QAAP,GAAkBG,WAAW,CAAC,MAAM;MACpC;MACId,MAAM,CAACe,IAAP,CAAY,MAAZ,EAAoB,iBAApB;IACC,CAHwB,EAGtB,IAHsB,CAA7B;EAIH,CAxBD;AAyBP,CA7BG"},"metadata":{},"sourceType":"script"}